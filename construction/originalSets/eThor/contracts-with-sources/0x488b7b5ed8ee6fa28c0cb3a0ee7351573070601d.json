{"SourceCode":"contract AmIOnTheFork {\r\n    function forked() constant returns(bool);\r\n}\r\n\r\ncontract SplitterEtcToEth {\r\n\r\n    event OnReceive(uint64);\r\n\r\n    struct Received {\r\n        address from;\r\n        uint256 value;\r\n    }\r\n\r\n    address intermediate;\r\n    address owner;\r\n    mapping (uint64 => Received) public received;\r\n    uint64 public seq = 1;\r\n\r\n    // there is a limit accepted by exchange\r\n    uint256 public upLimit = 50 ether;\r\n    // and exchange costs, ignore small transactions\r\n    uint256 public lowLimit = 0.1 ether;\r\n\r\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\r\n\r\n    function SplitterEtcToEth() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function() {\r\n        //stop too small transactions\r\n        if (msg.value < lowLimit) throw;\r\n\r\n        // always return value from FORK chain\r\n        if (amIOnTheFork.forked()) {\r\n            if (!msg.sender.send(msg.value)) throw;\r\n\r\n        // process with exchange on the CLASSIC chain\r\n        } else {\r\n            // check that received less or equal to conversion up limit\r\n            if (msg.value <= upLimit) {\r\n                if (!intermediate.send(msg.value)) throw;\r\n                uint64 id = seq++;\r\n                received[id] = Received(msg.sender, msg.value);\r\n                OnReceive(id);\r\n            } else {\r\n                // send only acceptable value, return rest\r\n                if (!intermediate.send(upLimit)) throw;\r\n                if (!msg.sender.send(msg.value - upLimit)) throw;\r\n                uint64 idp = seq++;\r\n                received[idp] = Received(msg.sender, upLimit);\r\n                OnReceive(idp);\r\n            }\r\n        }\r\n    }\r\n\r\n    function processed(uint64 _id) {\r\n        if (msg.sender != owner) throw;\r\n        delete received[_id];\r\n    }\r\n\r\n    function setIntermediate(address _intermediate) {\r\n        if (msg.sender != owner) throw;\r\n        intermediate = _intermediate;\r\n    }\r\n    function setUpLimit(uint _limit) {\r\n        if (msg.sender != owner) throw;\r\n        upLimit = _limit;\r\n    }\r\n    function setLowLimit(uint _limit) {\r\n        if (msg.sender != owner) throw;\r\n        lowLimit = _limit;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint64\"}],\"name\":\"processed\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setUpLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seq\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setLowLimit\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_intermediate\",\"type\":\"address\"}],\"name\":\"setIntermediate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"received\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"OnReceive\",\"type\":\"event\"}]","ContractName":"SplitterEtcToEth","CompilerVersion":"v0.3.5-2016-08-10-fc60839","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
