{"SourceCode":"contract LittleEthereumDoubler {\r\n//--------------------------------------------------USERS-----------------------------------------------------------\r\n    struct User {\r\n        address addr;\r\n        uint paidOut;\r\n        uint payoutLeft;\r\n    }\r\n    User[] private users;\r\n    uint private index;\r\n//--------------------------------------------------DEPLOYMENT AND FEES---------------------------------------------\r\n    address private feeAddress;\r\n\r\n    modifier execute { if (feeAddress == tx.origin) _ }\r\n    \r\n    function NewFeeAddress(address newFeeAddress) execute {\r\n        if (msg.value != 0) tx.origin.send(msg.value);\r\n        feeAddress = newFeeAddress;\r\n    }\r\n    \r\n    function LittleEthereumDoubler() {\r\n        feeAddress = tx.origin;\r\n    }\r\n//--------------------------------------------------CONTRACT--------------------------------------------------------\r\n    function() {\r\n        Start();\r\n    }\r\n    \r\n    function Start() internal {\r\n        uint a = msg.value;     // a = amount\r\n        a = DepositLimit(a);    // trim if too much, throw is too little\r\n        Fees(a);                // 2,5% fees goes to the fee address\r\n        NewDeposit(a);          // put user in the usersdatabase\r\n        Payout();               // pay out who is in the index\r\n    }\r\n    \r\n    function DepositLimit(uint a) internal returns (uint x){\r\n        x = a;\r\n        if (x < 100 finney) throw;\r\n        if (x > 50 ether) {\r\n            x = 50 ether;\r\n            tx.origin.send(a - x);\r\n        }\r\n    }\r\n    \r\n    function Fees(uint a) internal {\r\n        feeAddress.send(a * 25 / 1000);\r\n    }\r\n    \r\n    function NewDeposit(uint a) internal {\r\n        users.length++;\r\n        users[users.length - 1].addr = tx.origin;\r\n        users[users.length - 1].payoutLeft = a * 2;\r\n    }\r\n    \r\n    function Payout() internal {\r\n        while (this.balance != 0) {\r\n            if (users[index].payoutLeft > this.balance) {\r\n                users[index].payoutLeft -= this.balance;\r\n                users[index].paidOut += this.balance;\r\n                users[index].addr.send(this.balance);\r\n            }\r\n            else {\r\n                users[index].paidOut += users[index].payoutLeft;\r\n                users[index].addr.send(users[index].payoutLeft);\r\n                delete users[index].payoutLeft;\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n//--------------------------------------------------MIST GUI--------------------------------------------------------\r\n    function UserDatabase(uint id) constant returns(address Address, uint Payout, uint PaidOut, uint PayoutLeft, string info) {\r\n        Address = users[id].addr;\r\n        PaidOut = users[id].paidOut / 100 finney;\r\n        PayoutLeft = users[id].payoutLeft / 100 finney;\r\n        Payout = (users[id].paidOut + users[id].payoutLeft) / 100 finney;\r\n        info = 'values are shown in a denomination of 100 finneys ( 100 finney = 0.1 ether = minimum input)';\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"NewFeeAddress\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"UserDatabase\",\"outputs\":[{\"name\":\"Address\",\"type\":\"address\"},{\"name\":\"Payout\",\"type\":\"uint256\"},{\"name\":\"PaidOut\",\"type\":\"uint256\"},{\"name\":\"PayoutLeft\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"LittleEthereumDoubler","CompilerVersion":"v0.3.1-2016-04-12-3ad5e82","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
