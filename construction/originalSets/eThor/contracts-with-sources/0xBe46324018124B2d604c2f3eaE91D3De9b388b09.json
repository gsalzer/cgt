{"SourceCode":"contract RobinHoodPonzi {\r\n\r\n//  Robin Hood Ponzi\r\n//\r\n// Payout from   1 Finney to   10 Finney 300%  \r\n// Payout from  10 Finney to  100 Finney 200% \r\n// Payout from 100 Finney to    1 Ether  180% \r\n// Payout from   1 Ether  to   10 Ether  150% \r\n// Payout from  10 Ether  to  100 Ether  125% \r\n// Payout from 100 Ether  to  500 Ether  110% \r\n// Payout from 500 Ether  to 1000 Ether  105% \r\n \r\n\r\n\r\n\r\n\r\n  struct Participant {\r\n      address etherAddress;\r\n      uint payin;\r\n      uint payout;\t\r\n  }\r\n\r\n  Participant[] private participants;\r\n\r\n  uint private payoutIdx = 0;\r\n  uint private collectedFees;\r\n  uint private balance = 0;\r\n  uint private fee = 1; // 1%\r\n  uint private factor = 200; \r\n\r\n  address private owner;\r\n\r\n  // simple single-sig function modifier\r\n  modifier onlyowner { if (msg.sender == owner) _ }\r\n\r\n  // this function is executed at initialization and sets the owner of the contract\r\n  function RobinHoodPonzi() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  // fallback function - simple transactions trigger this\r\n  function() {\r\n    enter();\r\n  }\r\n  \r\n\r\n  function enter() private {\r\n    if (msg.value < 1 finney) {\r\n        msg.sender.send(msg.value);\r\n        return;\r\n    }\r\n\t\tuint amount;\r\n\t\tif (msg.value > 1000 ether) {\r\n\t\t\tmsg.sender.send(msg.value - 1000 ether);\t\r\n\t\t\tamount = 1000 ether;\r\n    }\r\n\t\telse {\r\n\t\t\tamount = msg.value;\r\n\t\t}\r\n\r\n  \t// add a new participant to array\r\n\r\n    uint idx = participants.length;\r\n    participants.length += 1;\r\n    participants[idx].etherAddress = msg.sender;\r\n    participants[idx].payin = amount;\r\n\r\n\tif(amount>= 1 finney){factor=300;}\r\n\tif(amount>= 10 finney){factor=200;}\r\n\tif(amount>= 100 finney){factor=180;}\r\n\tif(amount>= 1 ether) {factor=150;}\r\n\tif(amount>= 10 ether) {factor=125;}\r\n\tif(amount>= 100 ether) {factor=110;}\r\n\tif(amount>= 500 ether) {factor=105;}\r\n\r\n    participants[idx].payout = amount *factor/100;\t\r\n\t\r\n \r\n    \r\n    // collect fees and update contract balance\r\n    \r\n     collectedFees += amount *fee/100;\r\n     balance += amount - amount *fee/100;\r\n     \r\n\r\n\r\n\r\n// while there are enough ether on the balance we can pay out to an earlier participant\r\n    while (balance > participants[payoutIdx].payout) \r\n\t{\r\n\t      uint transactionAmount = participants[payoutIdx].payout;\r\n\t      participants[payoutIdx].etherAddress.send(transactionAmount);\r\n\t      balance -= transactionAmount;\r\n\t      payoutIdx += 1;\r\n\t}\r\n\r\n \tif (collectedFees >1 ether) \r\n\t{\r\n\t\r\n      \t\towner.send(collectedFees);\r\n      \t\tcollectedFees = 0;\r\n\t}\r\n  }\r\n\r\n // function collectFees() onlyowner {\r\n //     if (collectedFees == 0) return;\r\n//      owner.send(collectedFees);\r\n //     collectedFees = 0;\r\n // }\r\n\r\n // function setOwner(address _owner) onlyowner {\r\n //     owner = _owner;\r\n // }\r\n\r\n\r\n\tfunction Infos() constant returns (address Owner, uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) \r\n\t{\r\n\t\tOwner=owner;\r\n        \tBalanceInFinney = balance / 1 finney;\r\n        \tPayOutIndex=payoutIdx;\r\n\t\tParticipants=participants.length;\r\n\t\tNextPayout =participants[payoutIdx].payout / 1 finney;\r\n\t\tinfo = 'All amounts in Finney (1 Ether = 1000 Finney)';\r\n    \t}\r\n\r\n\tfunction participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)\r\n    \t{\r\n\t\t\r\n\t\tPaidOut='N.A.';\r\n\t\tAddress=0;\r\n\t\tPayinInFinney=0;\r\n\t\tPayoutInFinney=0;\r\n        \tif (nr < participants.length) {\r\n            \tAddress = participants[nr].etherAddress;\r\n\r\n            \tPayinInFinney = participants[nr].payin / 1 finney;\r\n\t\tPayoutInFinney= participants[nr].payout / 1 finney;\r\n\t\tPaidOut='no';\r\n\t\tif (nr<payoutIdx){PaidOut='yes';}\t\t\r\n\r\n       }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"Infos\",\"outputs\":[{\"name\":\"Owner\",\"type\":\"address\"},{\"name\":\"BalanceInFinney\",\"type\":\"uint256\"},{\"name\":\"Participants\",\"type\":\"uint256\"},{\"name\":\"PayOutIndex\",\"type\":\"uint256\"},{\"name\":\"NextPayout\",\"type\":\"uint256\"},{\"name\":\"info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nr\",\"type\":\"uint256\"}],\"name\":\"participantDetails\",\"outputs\":[{\"name\":\"Address\",\"type\":\"address\"},{\"name\":\"PayinInFinney\",\"type\":\"uint256\"},{\"name\":\"PayoutInFinney\",\"type\":\"uint256\"},{\"name\":\"PaidOut\",\"type\":\"string\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"RobinHoodPonzi","CompilerVersion":"v0.2.1-2016-01-30-91a6b35","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
