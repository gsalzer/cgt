{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\nlibrary TokenEventLib {\r\n    /*\r\n     * When underlying solidity issue is fixed this library will not be needed.\r\n     * https://github.com/ethereum/solidity/issues/1215\r\n     */\r\n    event Transfer(address indexed _from,\r\n                   address indexed _to);\r\n    event Approval(address indexed _owner,\r\n                   address indexed _spender);\r\n\r\n    function _Transfer(address _from, address _to) internal {\r\n        Transfer(_from, _to);\r\n    }\r\n\r\n    function _Approval(address _owner, address _spender) internal {\r\n        Approval(_owner, _spender);\r\n    }\r\n}\r\n\r\ncontract TokenInterface {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Mint(address indexed _owner);\r\n    event Destroy(address _owner);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event MinterAdded(address who);\r\n    event MinterRemoved(address who);\r\n\r\n    /*\r\n     *  Minting\r\n     */\r\n    /// @dev Mints a new token.\r\n    /// @param _owner Address of token owner.\r\n    function mint(address _owner) returns (bool success);\r\n\r\n    /// @dev Destroy a token\r\n    /// @param _owner Bytes32 id of the owner of the token\r\n    function destroy(address _owner) returns (bool success);\r\n\r\n    /// @dev Add a new minter\r\n    /// @param who Address the address that can now mint tokens.\r\n    function addMinter(address who) returns (bool);\r\n\r\n    /// @dev Remove a minter\r\n    /// @param who Address the address that will no longer be a minter.\r\n    function removeMinter(address who) returns (bool);\r\n\r\n    /*\r\n     *  Read and write storage functions\r\n     */\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() constant returns (uint supply);\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    /*\r\n     * Read storage functions\r\n     */\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool);\r\n}\r\n\r\ncontract IndividualityTokenInterface {\r\n    /*\r\n     * Read storage functions\r\n     */\r\n\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    /*\r\n     *  Write storage functions\r\n     */\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transfer(address _to) public returns (bool success);\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to) public returns (bool success);\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function approve(address _spender) public returns (bool success);\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool);\r\n}\r\n\r\n\r\ncontract IndividualityToken is TokenInterface, IndividualityTokenInterface {\r\n    function IndividualityToken() {\r\n        minters[msg.sender] = true;\r\n        MinterAdded(msg.sender);\r\n    }\r\n\r\n    modifier minterOnly {\r\n        if(!minters[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    // address => canmint\r\n    mapping (address => bool) minters;\r\n    \r\n    // owner => balance\r\n    mapping (address => uint) balances;\r\n\r\n    // owner => spender => balance\r\n    mapping (address => mapping (address => uint)) approvals;\r\n\r\n    uint numTokens;\r\n\r\n    /// @dev Mints a new token.\r\n    /// @param _to Address of token owner.\r\n    function mint(address _to) minterOnly returns (bool success) {\r\n        // ensure that the token owner doesn't already own a token.\r\n        if (balances[_to] != 0x0) return false;\r\n\r\n        balances[_to] = 1;\r\n\r\n        // log the minting of this token.\r\n        Mint(_to);\r\n        Transfer(0x0, _to, 1);\r\n        TokenEventLib._Transfer(0x0, _to);\r\n\r\n        // increase the supply.\r\n        numTokens += 1;\r\n\r\n        return true;\r\n    }\r\n    \r\n    // @dev Mint many new tokens\r\n    function mint(address[] _to) minterOnly returns (bool success) {\r\n        for(uint i = 0; i < _to.length; i++) {\r\n            if(balances[_to[i]] != 0x0) return false;\r\n            balances[_to[i]] = 1;\r\n            Mint(_to[i]);\r\n            Transfer(0x0, _to[i], 1);\r\n            TokenEventLib._Transfer(0x0, _to[i]);\r\n        }\r\n        numTokens += _to.length;\r\n        return true;\r\n    }\r\n\r\n    /// @dev Destroy a token\r\n    /// @param _owner address owner of the token to destroy\r\n    function destroy(address _owner) minterOnly returns (bool success) {\r\n        if(balances[_owner] != 1) throw;\r\n        \r\n        balances[_owner] = 0;\r\n        numTokens -= 1;\r\n        Destroy(_owner);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Add a new minter\r\n    /// @param who Address the address that can now mint tokens.\r\n    function addMinter(address who) minterOnly returns (bool) {\r\n        minters[who] = true;\r\n        MinterAdded(who);\r\n    }\r\n\r\n    /// @dev Remove a minter\r\n    /// @param who Address the address that will no longer be a minter.\r\n    function removeMinter(address who) minterOnly returns (bool) {\r\n        minters[who] = false;\r\n        MinterRemoved(who);\r\n    }\r\n\r\n    /// @dev Return the number of tokens\r\n    function totalSupply() constant returns (uint supply) {\r\n        return numTokens;\r\n    }\r\n\r\n    /// @dev Returns id of token owned by given address (encoded as an integer).\r\n    /// @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        if (_owner == 0x0) {\r\n            return 0;\r\n        } else {\r\n            return balances[_owner];\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the token id that may transfer from _owner account by _spender..\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    function allowance(address _owner,\r\n                       address _spender) constant returns (uint256 remaining) {\r\n        return approvals[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transfer(address _to,\r\n                      uint256 _value) public returns (bool success) {\r\n        if (_value != 1) {\r\n            // 1 is the only value that makes any sense here.\r\n            return false;\r\n        } else if (_to == 0x0) {\r\n            // cannot transfer to the null address.\r\n            return false;\r\n        } else if (balances[msg.sender] == 0x0) {\r\n            // msg.sender is not a token owner\r\n            return false;\r\n        } else if (balances[_to] != 0x0) {\r\n            // cannot transfer to an address that already owns a token.\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] = 0;\r\n        balances[_to] = 1;\r\n        Transfer(msg.sender, _to, 1);\r\n        TokenEventLib._Transfer(msg.sender, _to);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers sender token to given address. Returns success.\r\n    /// @param _to Address of new token owner.\r\n    function transfer(address _to) public returns (bool success) {\r\n        return transfer(_to, 1);\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    /// @param _value Bytes32 id of the token to transfer.\r\n    function transferFrom(address _from,\r\n                          address _to,\r\n                          uint256 _value) public returns (bool success) {\r\n        if (_value != 1) {\r\n            // Cannot transfer anything other than 1 token.\r\n            return false;\r\n        } else if (_to == 0x0) {\r\n            // Cannot transfer to the null address\r\n            return false;\r\n        } else if (balances[_from] == 0x0) {\r\n            // Cannot transfer if _from is not a token owner\r\n            return false;\r\n        } else if (balances[_to] != 0x0) {\r\n            // Cannot transfer to an existing token owner\r\n            return false;\r\n        } else if (approvals[_from][msg.sender] == 0) {\r\n            // The approved token doesn't match the token being transferred.\r\n            return false;\r\n        }\r\n\r\n        // null out the approval\r\n        approvals[_from][msg.sender] = 0x0;\r\n\r\n        // remove the token from the sender.\r\n        balances[_from] = 0;\r\n\r\n        // assign the token to the new owner\r\n        balances[_to] = 1;\r\n\r\n        // log the transfer\r\n        Transfer(_from, _to, 1);\r\n        TokenEventLib._Transfer(_from, _to);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    /// @param _from Address of token owner.\r\n    /// @param _to Address of new token owner.\r\n    function transferFrom(address _from, address _to) public returns (bool success) {\r\n        return transferFrom(_from, _to, 1);\r\n    }\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    /// @param _value Bytes32 id of token that can be spend.\r\n    function approve(address _spender,\r\n                     uint256 _value) public returns (bool success) {\r\n        if (_value != 1) {\r\n            // cannot approve any value other than 1\r\n            return false;\r\n        } else if (_spender == 0x0) {\r\n            // cannot approve the null address as a spender.\r\n            return false;\r\n        } else if (balances[msg.sender] == 0x0) {\r\n            // cannot approve if not a token owner.\r\n            return false;\r\n        }\r\n\r\n        approvals[msg.sender][_spender] = 1;\r\n\r\n        Approval(msg.sender, _spender, 1);\r\n        TokenEventLib._Approval(msg.sender, _spender);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Sets approval spender to transfer ownership of token. Returns success.\r\n    /// @param _spender Address of spender..\r\n    function approve(address _spender) public returns (bool success) {\r\n        return approve(_spender, 1);\r\n    }\r\n\r\n    /*\r\n     *  Extra non ERC20 functions\r\n     */\r\n    /// @dev Returns whether the address owns a token.\r\n    /// @param _owner Address to check.\r\n    function isTokenOwner(address _owner) constant returns (bool) {\r\n        return balances[_owner] != 0;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"}]","ContractName":"IndividualityToken","CompilerVersion":"v0.4.8+commit.60cc1668","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://e7d1ec7aee624d06d099208b696a2678b13b1633eab8c723c2db49792afe9dd0"}
