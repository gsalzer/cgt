{"SourceCode":"// A name registry in Ethereum\r\n\r\n// \"Real\" attempts to a name registry with Ethereum:\r\n// <http://etherid.org/> <https://github.com/sinking-point/dns2/>\r\n\r\n// TODO: use the registry interface described in\r\n// <https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs>?\r\n\r\n// Standard strings are poor, we need an extension library,\r\n// github.com/Arachnid/solidity-stringutils/strings.sol TODO: use it as soon as https://github.com/Arachnid/solidity-stringutils/issues/1 is solved.\r\n// import \"strings.sol\";\r\n\r\ncontract Registry {\r\n\r\n  // using strings for *; // TODO see above\r\n\r\n  address public nic; // The Network Information Center\r\n  \r\n  struct Record {\r\n    string value; // IP addresses, emails, etc TODO accept an array\r\n\t\t     // as soon as we have a strings library to\r\n\t\t     // serialize/deserialize. TODO type the values with an Enum\r\n    address holder;\r\n    bool exists; // Or a more detailed state, with an enum?\r\n    uint idx;\r\n  }\r\n  mapping (string => Record) records;\r\n  mapping (uint => string) index;\r\n  \r\n  // TODO define accessors instead\r\n  uint public maxRecords;\r\n  uint public currentRecords;\r\n\r\n  event debug(string indexed label, string msg);\r\n  event created(string indexed label, string indexed name, address holder, uint block);\r\n  event deleted(string indexed label, string indexed name, address holder, uint block);\r\n  \r\n  // \"value\" should be a comma-separated list of values. Solidity\r\n  // public functions cannot use arrays of strings :-( TODO: solve it\r\n  // when we'll have strings.\r\n  function register(string name, string value) {\r\n    /* TODO: pay the price */\r\n    uint i;\r\n    if (records[name].exists) {\r\n      if (msg.sender != records[name].holder) { // TODO: use modifiers instead\r\n\tthrow;\r\n      }\r\n      else {\r\n\ti = records[name].idx;\r\n      }\r\n    }\r\n    else {\r\n      records[name].idx = maxRecords;\r\n      i = maxRecords;\r\n      maxRecords++;\r\n    }\r\n    records[name].value = value;\r\n    records[name].holder = msg.sender;\r\n    records[name].exists = true;\r\n    currentRecords++;\r\n    index[i] = name;\r\n    created(\"CREATION\", name, msg.sender, block.number);\t  \r\n  }\r\n\r\n  function transfer(string name, address to) {\r\n    if (records[name].exists) {\r\n      if (msg.sender != records[name].holder) {\r\n\tthrow;\r\n      }\r\n      records[name].holder = to;\r\n    }\r\n    else {\r\n      throw;\r\n    }\r\n  }\r\n  \r\n  function get(string name) constant returns(bool exists, string value) {\r\n    if (records[name].exists) {\r\n      exists = true;\r\n      value = records[name].value;\r\n    } else {\r\n      exists = false;\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n  function Registry() {\r\n    nic = msg.sender;\r\n    currentRecords = 0;\r\n    maxRecords = 0;\r\n    register(\"NIC\", \"Automatically created by for the registry\"); // TODO may fail if not\r\n    // enough gas in the creating transaction?\r\n  }\r\n  \r\n\r\n  function whois(string name) constant returns(bool exists, string value, address holder) {\r\n    if (records[name].exists) {\r\n      exists = true;\r\n      value = records[name].value;\r\n      holder = records[name].holder;\r\n    } else {\r\n      exists = false;\r\n    }\r\n  }\r\n\r\n  function remove(string name) {\r\n    uint i;\r\n    if (records[name].exists) {\r\n      if (msg.sender != records[name].holder) {\r\n\tthrow;\r\n      }\r\n      else {\r\n\ti = records[name].idx;\r\n      }\r\n    }\r\n    else {\r\n      throw; // 404. Too bad we cannot add content to throw.\r\n    }\r\n    records[name].exists = false;\r\n    currentRecords--;\r\n    deleted(\"DELETION\", name, msg.sender, block.number);\t  \r\n  }\r\n\r\n  function download() returns(string all) {\r\n    if (msg.sender != nic) {\r\n\tthrow;\r\n      }\r\n    all = \"NOT YET IMPLEMENTED\";\r\n    // Looping over all the records is easy:\r\n    //for uint (i = 0; i < maxRecords; i++) {\r\n    //\tif (records[index[i]].exists) {\r\n    \r\n    // Or we could use an iterable mapping may\r\n    // be this library\r\n    // <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>\r\n\r\n    // The difficult part is to construct an answer, since Solidity\r\n    // does not provide string concatenation, or the ability to return\r\n    // arrays.\r\n\r\n\t// TODO: provide a function to access one item, using its index,\r\n\t// and to let the caller loops from 0 to maxRecords\r\n\t// http://stackoverflow.com/questions/37606839/how-to-return-mapping-list-in-solidity-ethereum-contract/37643972#37643972\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"download\",\"outputs\":[{\"name\":\"all\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRecords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"remove\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"whois\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"string\"},{\"name\":\"holder\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"debug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"deleted\",\"type\":\"event\"}]","ContractName":"Registry","CompilerVersion":"v0.3.5-2016-07-01-48238c9","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
