{"SourceCode":"pragma solidity ^0.4.3;\r\n\r\ncontract Avatars {\r\n    \r\n    uint avatarsCount = 0;\r\n\r\n    struct Avatar {\r\n        uint id;\r\n        \r\n        /**\r\n         * Avatar's owner.\r\n         */ \r\n        address owner;\r\n        \r\n        /**\r\n         * First byte is gender, 1 / 0 for male / female. \r\n         * Then every byte describe choosen avatar part. \r\n         * The order is : backs, clothes, ears, eyebrows, eyesfront, eyesiris, faceshape, glasses, hair, mouth, nose, beard, mustache. \r\n         */ \r\n        bytes32 shapes;\r\n        \r\n        /**\r\n         * Each 3 bytes describe color for 5 first shapes.\r\n         */\r\n        bytes32 colorsPrimary;\r\n        \r\n        /**\r\n         * Each 3 bytes describe color for 8 last shapes.\r\n         */\r\n        bytes32 colorsSecondary;\r\n        \r\n        /**\r\n         * Each byte describes up/down position for every shape. \r\n         * High nibble depicts the sign of number, 1 - up, 0 - down.\r\n         * Low nibble shows number of steps to move the shape in selected direction.\r\n         * \r\n         */\r\n        bytes32 positions;\r\n    }\r\n    \r\n    mapping(bytes32 => Avatar) avatars;\r\n    \r\n    /**\r\n     * Stores an avatar on the blockchain.\r\n     * Throws if avatar with such shapes combination is already exists.\r\n     * \r\n     * @param shapes - hex string, depicts gender and combinations of shapes.\r\n     * @param colorsPrimary - hex string, colors of the first 5 shapes.\r\n     * @param colorsSecondary - hex string, colors of the last 8 shapes.\r\n     * @param positions - hex string, up/down positions of all shapes\r\n     * \r\n     * @return Hash of the avatar.\r\n     */\r\n    function register(string shapes, string colorsPrimary, string colorsSecondary, string positions) returns (bytes32 avatarHash) {\r\n        bytes32 shapesBytes = strToBytes(shapes);\r\n        bytes32 colorsPrimaryBytes = strToBytes(colorsPrimary);\r\n        bytes32 colorsSecondaryBytes = strToBytes(colorsSecondary);\r\n        bytes32 positionsBytes = strToBytes(positions);\r\n\r\n        // unique by shapes composition\r\n        bytes32 hash = sha3(shapes);\r\n\r\n        Avatar memory existingAvatar = avatars[hash];\r\n        if (existingAvatar.id != 0)\r\n            throw;\r\n        \r\n        Avatar memory avatar = Avatar(++avatarsCount, msg.sender, \r\n            shapesBytes,\r\n            colorsPrimaryBytes,\r\n            colorsSecondaryBytes,\r\n            positionsBytes);\r\n\r\n        avatars[hash] = avatar;\r\n        return hash;\r\n    }\r\n    \r\n    /**\r\n     * Returns an avatar by it's hash.\r\n     * Throws if avatar is not exists.\r\n     */ \r\n    function get(bytes32 avatarHash) constant returns (bytes32 shapes, bytes32 colorsPrimary, bytes32 colorsSecondary, bytes32 positions) {\r\n        Avatar memory avatar = getAvatar(avatarHash);\r\n        \r\n        shapes = avatar.shapes;\r\n        colorsPrimary = avatar.colorsPrimary;\r\n        colorsSecondary = avatar.colorsSecondary;\r\n        positions = avatar.positions;\r\n    }\r\n    \r\n    /**\r\n     * Returns an avatar owner address by avatar's hash.\r\n     * Throws if avatar is not exists.\r\n     */ \r\n    function getOwner(bytes32 avatarHash) constant returns (address) {\r\n        Avatar memory avatar = getAvatar(avatarHash);\r\n        return avatar.owner;\r\n    }\r\n    \r\n        \r\n    /**\r\n     * Returns if avatar of the given hash exists.\r\n     */ \r\n    function isExists(bytes32 avatarHash) constant returns (bool) {\r\n        Avatar memory avatar = avatars[avatarHash];\r\n        if (avatar.id == 0)\r\n            return false;\r\n            \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Returns an avatar by it's hash.\r\n     * Throws if avatar is not exists.\r\n     */ \r\n    function getAvatar(bytes32 avatarHash) private constant returns (Avatar) {\r\n        Avatar memory avatar = avatars[avatarHash];\r\n        if (avatar.id == 0)\r\n           throw;\r\n           \r\n        return avatar;\r\n    }\r\n    \r\n    /**\r\n     * @dev Low level function.\r\n     * Converts string to bytes32 array.\r\n     * Throws if string length is more than 32 bytes\r\n     * \r\n     * @param str string\r\n     * @return bytes32 representation of str\r\n     */\r\n    function strToBytes(string str) constant private returns (bytes32 ret) {\r\n        // var g = bytes(str).length;\r\n        // if (bytes(str).length > 32) throw;\r\n        \r\n        assembly {\r\n            ret := mload(add(str, 32))\r\n        }\r\n    } \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"shapes\",\"type\":\"string\"},{\"name\":\"colorsPrimary\",\"type\":\"string\"},{\"name\":\"colorsSecondary\",\"type\":\"string\"},{\"name\":\"positions\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"avatarHash\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"avatarHash\",\"type\":\"bytes32\"}],\"name\":\"isExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"avatarHash\",\"type\":\"bytes32\"}],\"name\":\"get\",\"outputs\":[{\"name\":\"shapes\",\"type\":\"bytes32\"},{\"name\":\"colorsPrimary\",\"type\":\"bytes32\"},{\"name\":\"colorsSecondary\",\"type\":\"bytes32\"},{\"name\":\"positions\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"avatarHash\",\"type\":\"bytes32\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"}]","ContractName":"Avatars","CompilerVersion":"v0.4.9+commit.364da425","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":"bzzr://31a5d757f81f0bf1c0dda3691a8f2d1bc7b86cf2fecc9b9a418e31f6aed61f15"}
