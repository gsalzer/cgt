{"SourceCode":"// Copyright 2016 The go-ethereum Authors\r\n// This file is part of the go-ethereum library.\r\n//\r\n// The go-ethereum library is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Lesser General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// The go-ethereum library is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Lesser General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Lesser General Public License\r\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// ReleaseOracle is an Ethereum contract to store the current and previous\r\n// versions of the go-ethereum implementation. Its goal is to allow Geth to\r\n// check for new releases automatically without the need to consult a central\r\n// repository.\r\n//\r\n// The contract takes a vote based approach on both assigning authorised signers\r\n// as well as signing off on new Geth releases.\r\n//\r\n// Note, when a signer is demoted, the currently pending release is auto-nuked.\r\n// The reason is to prevent suprises where a demotion actually tilts the votes\r\n// in favor of one voter party and pushing out a new release as a consequence of\r\n// a simple demotion.\r\ncontract ReleaseOracle {\r\n  // Votes is an internal data structure to count votes on a specific proposal\r\n  struct Votes {\r\n    address[] pass; // List of signers voting to pass a proposal\r\n    address[] fail; // List of signers voting to fail a proposal\r\n  }\r\n\r\n  // Version is the version details of a particular Geth release\r\n  struct Version {\r\n    uint32  major;  // Major version component of the release\r\n    uint32  minor;  // Minor version component of the release\r\n    uint32  patch;  // Patch version component of the release\r\n    bytes20 commit; // Git SHA1 commit hash of the release\r\n\r\n    uint64  time;  // Timestamp of the release approval\r\n    Votes   votes; // Votes that passed this release\r\n  }\r\n\r\n  // Oracle authorization details\r\n  mapping(address => bool) authorised; // Set of accounts allowed to vote on updating the contract\r\n  address[]                voters;     // List of addresses currently accepted as signers\r\n\r\n  // Various proposals being voted on\r\n  mapping(address => Votes) authProps; // Currently running user authorization proposals\r\n  address[]                 authPend;  // List of addresses being voted on (map indexes)\r\n\r\n  Version   verProp;  // Currently proposed release being voted on\r\n  Version[] releases; // All the positively voted releases\r\n\r\n  // isSigner is a modifier to authorize contract transactions.\r\n  modifier isSigner() {\r\n    if (authorised[msg.sender]) {\r\n      _\r\n    }\r\n  }\r\n\r\n  // Constructor to assign the initial set of signers.\r\n  function ReleaseOracle(address[] signers) {\r\n    // If no signers were specified, assign the creator as the sole signer\r\n    if (signers.length == 0) {\r\n      authorised[msg.sender] = true;\r\n      voters.push(msg.sender);\r\n      return;\r\n    }\r\n    // Otherwise assign the individual signers one by one\r\n    for (uint i = 0; i < signers.length; i++) {\r\n      authorised[signers[i]] = true;\r\n      voters.push(signers[i]);\r\n    }\r\n  }\r\n\r\n  // signers is an accessor method to retrieve all te signers (public accessor\r\n  // generates an indexed one, not a retreive-all version).\r\n  function signers() constant returns(address[]) {\r\n    return voters;\r\n  }\r\n\r\n  // authProposals retrieves the list of addresses that authorization proposals\r\n  // are currently being voted on.\r\n  function authProposals() constant returns(address[]) {\r\n    return authPend;\r\n  }\r\n\r\n  // authVotes retrieves the current authorization votes for a particular user\r\n  // to promote him into the list of signers, or demote him from there.\r\n  function authVotes(address user) constant returns(address[] promote, address[] demote) {\r\n    return (authProps[user].pass, authProps[user].fail);\r\n  }\r\n\r\n  // currentVersion retrieves the semantic version, commit hash and release time\r\n  // of the currently votec active release.\r\n  function currentVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, uint time) {\r\n    if (releases.length == 0) {\r\n      return (0, 0, 0, 0, 0);\r\n    }\r\n    var release = releases[releases.length - 1];\r\n\r\n    return (release.major, release.minor, release.patch, release.commit, release.time);\r\n  }\r\n\r\n  // proposedVersion retrieves the semantic version, commit hash and the current\r\n  // votes for the next proposed release.\r\n  function proposedVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, address[] pass, address[] fail) {\r\n    return (verProp.major, verProp.minor, verProp.patch, verProp.commit, verProp.votes.pass, verProp.votes.fail);\r\n  }\r\n\r\n  // promote pitches in on a voting campaign to promote a new user to a signer\r\n  // position.\r\n  function promote(address user) {\r\n    updateSigner(user, true);\r\n  }\r\n\r\n  // demote pitches in on a voting campaign to demote an authorised user from\r\n  // its signer position.\r\n  function demote(address user) {\r\n    updateSigner(user, false);\r\n  }\r\n\r\n  // release votes for a particular version to be included as the next release.\r\n  function release(uint32 major, uint32 minor, uint32 patch, bytes20 commit) {\r\n    updateRelease(major, minor, patch, commit, true);\r\n  }\r\n\r\n  // nuke votes for the currently proposed version to not be included as the next\r\n  // release. Nuking doesn't require a specific version number for simplicity.\r\n  function nuke() {\r\n    updateRelease(0, 0, 0, 0, false);\r\n  }\r\n\r\n  // updateSigner marks a vote for changing the status of an Ethereum user, either\r\n  // for or against the user being an authorised signer.\r\n  function updateSigner(address user, bool authorize) internal isSigner {\r\n    // Gather the current votes and ensure we don't double vote\r\n    Votes votes = authProps[user];\r\n    for (uint i = 0; i < votes.pass.length; i++) {\r\n      if (votes.pass[i] == msg.sender) {\r\n        return;\r\n      }\r\n    }\r\n    for (i = 0; i < votes.fail.length; i++) {\r\n      if (votes.fail[i] == msg.sender) {\r\n        return;\r\n      }\r\n    }\r\n    // If no authorization proposal is open, add the user to the index for later lookups\r\n    if (votes.pass.length == 0 && votes.fail.length == 0) {\r\n      authPend.push(user);\r\n    }\r\n    // Cast the vote and return if the proposal cannot be resolved yet\r\n    if (authorize) {\r\n      votes.pass.push(msg.sender);\r\n      if (votes.pass.length <= voters.length / 2) {\r\n        return;\r\n      }\r\n    } else {\r\n      votes.fail.push(msg.sender);\r\n      if (votes.fail.length <= voters.length / 2) {\r\n        return;\r\n      }\r\n    }\r\n    // Proposal resolved in our favor, execute whatever we voted on\r\n    if (authorize && !authorised[user]) {\r\n      authorised[user] = true;\r\n      voters.push(user);\r\n    } else if (!authorize && authorised[user]) {\r\n      authorised[user] = false;\r\n\r\n      for (i = 0; i < voters.length; i++) {\r\n        if (voters[i] == user) {\r\n          voters[i] = voters[voters.length - 1];\r\n          voters.length--;\r\n\r\n          delete verProp; // Nuke any version proposal (no suprise releases!)\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    // Finally delete the resolved proposal, index and garbage collect\r\n    delete authProps[user];\r\n\r\n    for (i = 0; i < authPend.length; i++) {\r\n      if (authPend[i] == user) {\r\n        authPend[i] = authPend[authPend.length - 1];\r\n        authPend.length--;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // updateRelease votes for a particular version to be included as the next release,\r\n  // or for the currently proposed release to be nuked out.\r\n  function updateRelease(uint32 major, uint32 minor, uint32 patch, bytes20 commit, bool release) internal isSigner {\r\n    // Skip nuke votes if no proposal is pending\r\n    if (!release && verProp.votes.pass.length == 0) {\r\n      return;\r\n    }\r\n    // Mark a new release if no proposal is pending\r\n    if (verProp.votes.pass.length == 0) {\r\n      verProp.major  = major;\r\n      verProp.minor  = minor;\r\n      verProp.patch  = patch;\r\n      verProp.commit = commit;\r\n    }\r\n    // Make sure positive votes match the current proposal\r\n    if (release && (verProp.major != major || verProp.minor != minor || verProp.patch != patch || verProp.commit != commit)) {\r\n      return;\r\n    }\r\n    // Gather the current votes and ensure we don't double vote\r\n    Votes votes = verProp.votes;\r\n    for (uint i = 0; i < votes.pass.length; i++) {\r\n      if (votes.pass[i] == msg.sender) {\r\n        return;\r\n      }\r\n    }\r\n    for (i = 0; i < votes.fail.length; i++) {\r\n      if (votes.fail[i] == msg.sender) {\r\n        return;\r\n      }\r\n    }\r\n    // Cast the vote and return if the proposal cannot be resolved yet\r\n    if (release) {\r\n      votes.pass.push(msg.sender);\r\n      if (votes.pass.length <= voters.length / 2) {\r\n        return;\r\n      }\r\n    } else {\r\n      votes.fail.push(msg.sender);\r\n      if (votes.fail.length <= voters.length / 2) {\r\n        return;\r\n      }\r\n    }\r\n    // Proposal resolved in our favor, execute whatever we voted on\r\n    if (release) {\r\n      verProp.time = uint64(now);\r\n      releases.push(verProp);\r\n      delete verProp;\r\n    } else {\r\n      delete verProp;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"proposedVersion\",\"outputs\":[{\"name\":\"major\",\"type\":\"uint32\"},{\"name\":\"minor\",\"type\":\"uint32\"},{\"name\":\"patch\",\"type\":\"uint32\"},{\"name\":\"commit\",\"type\":\"bytes20\"},{\"name\":\"pass\",\"type\":\"address[]\"},{\"name\":\"fail\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"demote\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"authVotes\",\"outputs\":[{\"name\":\"promote\",\"type\":\"address[]\"},{\"name\":\"demote\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentVersion\",\"outputs\":[{\"name\":\"major\",\"type\":\"uint32\"},{\"name\":\"minor\",\"type\":\"uint32\"},{\"name\":\"patch\",\"type\":\"uint32\"},{\"name\":\"commit\",\"type\":\"bytes20\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nuke\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"promote\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"major\",\"type\":\"uint32\"},{\"name\":\"minor\",\"type\":\"uint32\"},{\"name\":\"patch\",\"type\":\"uint32\"},{\"name\":\"commit\",\"type\":\"bytes20\"}],\"name\":\"release\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[{\"name\":\"signers\",\"type\":\"address[]\"}],\"type\":\"constructor\"}]","ContractName":"ReleaseOracle","CompilerVersion":"v0.3.2-2016-05-01-bee80f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000030000000000000000000000007aa09142176ef9a18ab242aa9c51991d705e05e0000000000000000000000000e8deef3079e3e0afd38d2ba76b0815b9ea43bd1300000000000000000000000002e816afc1b5c0f39852131959d946eb3b07b5ad","Library":"","LicenseType":"","SwarmSource":""}
