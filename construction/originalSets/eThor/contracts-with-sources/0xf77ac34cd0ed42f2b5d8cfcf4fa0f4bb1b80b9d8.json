{"SourceCode":"pragma solidity ^0.4.6;\r\n\r\ncontract RES { \r\n\r\n    /* Public variables of the token */\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    \r\n    uint public totalSupply;\r\n    \r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    \r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n\r\n    /* Bought or sold */\r\n\r\n    event Bought(address from, uint amount);\r\n    event Sold(address from, uint amount);\r\n    event BoughtViaJohan(address from, uint amount);\r\n\r\n    /* Initializes contract with name, symbol and decimals */\r\n\r\n    function RES() {\r\n        name = \"RES\";     \r\n        symbol = \"RES\";\r\n        decimals = 18;\r\n    }\r\n\r\n}\r\n\r\ncontract SwarmRedistribution is RES {\r\n    \r\n    address public JohanNygren;\r\n    bool public campaignOpen;    \r\n\r\n    struct dividendPathway {\r\n      address from;\r\n      uint amount;\r\n      uint timeStamp;\r\n    }\r\n\r\n    mapping(address => dividendPathway[]) public dividendPathways;\r\n    \r\n    mapping(address => uint256) public totalBasicIncome;\r\n\r\n    uint taxRate;\r\n\r\n    struct Node {\r\n      address node;\r\n      address parent;\r\n      uint index;\r\n    }\r\n    \r\n    /* Generate a swarm tree */\r\n    Node[] swarmTree;\r\n    \r\n    mapping(address => bool) inSwarmTree;\r\n    \r\n    bool JohanInSwarm;\r\n\r\n    event Swarm(address indexed leaf, address indexed node, uint256 share);\r\n\r\n    function SwarmRedistribution() {\r\n      \r\n    /* Tax-rate in parts per thousand */\r\n    taxRate = 20;\r\n    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;\r\n    campaignOpen = true;\r\n    \r\n    }\r\n    \r\n    modifier onlyJohan {\r\n      if(msg.sender != JohanNygren) throw;\r\n      _;\r\n    }\r\n\r\n    modifier isOpen {\r\n      if(campaignOpen != true) throw;\r\n      _;\r\n    }\r\n    \r\n    function changeJohanNygrensAddress(address _newAddress) onlyJohan {\r\n      JohanNygren = _newAddress;\r\n    }\r\n    \r\n    function closeCampaign() onlyJohan {\r\n        campaignOpen = false;\r\n    }\r\n\r\n    function buy() isOpen public payable {\r\n      balanceOf[msg.sender] = msg.value;\r\n      totalSupply += msg.value;\r\n      Bought(msg.sender, msg.value);\r\n    }  \r\n\r\n    function buyViaJohan() isOpen public payable {\r\n      balanceOf[msg.sender] = msg.value;\r\n      totalSupply += msg.value;  \r\n\r\n      /* Create the dividend pathway */\r\n      dividendPathways[msg.sender].push(dividendPathway({\r\n                                      from: JohanNygren, \r\n                                      amount:  msg.value,\r\n                                      timeStamp: now\r\n                                    }));\r\n\r\n      BoughtViaJohan(msg.sender, msg.value);\r\n    }\r\n\r\n    function sell(uint256 _value) public {\r\n      if(balanceOf[msg.sender] < _value) throw;\r\n      balanceOf[msg.sender] -= _value;\r\n    \r\n      if (!msg.sender.send(_value)) throw;\r\n\r\n      totalSupply -= _value;\r\n      Sold(msg.sender, _value);\r\n\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) isOpen {\r\n        /* reject transaction to self to prevent dividend pathway loops*/\r\n        if(_to == msg.sender) throw;\r\n        \r\n        /* if the sender doenst have enough balance then stop */\r\n        if (balanceOf[msg.sender] < _value) throw;\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n        \r\n        /* Calculate tax */\r\n        uint256 taxCollected = _value * taxRate / 1000;\r\n        uint256 sentAmount;\r\n\r\n        /* Create the dividend pathway */\r\n        dividendPathways[_to].push(dividendPathway({\r\n                                        from: msg.sender, \r\n                                        amount:  _value,\r\n                                        timeStamp: now\r\n                                      }));\r\n        \r\n        if(swarmRedistribution(_to, taxCollected) == true) {\r\n          sentAmount = _value;\r\n        }\r\n        else {\r\n          /* Return tax */\r\n          sentAmount = _value - taxCollected;\r\n        }\r\n        \r\n          /* Add and subtract new balances */\r\n\r\n          balanceOf[msg.sender] -= sentAmount;\r\n          balanceOf[_to] += _value - taxCollected;\r\n        \r\n\r\n        /* Notifiy anyone listening that this transfer took place */\r\n        Transfer(msg.sender, _to, sentAmount);\r\n    }\r\n\r\n    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {\r\n           iterateThroughSwarm(_to, now);\r\n           if(swarmTree.length != 0) {\r\n           return doSwarm(_to, _taxCollected);\r\n           }\r\n           else return false;\r\n      }\r\n\r\n    function iterateThroughSwarm(address _node, uint _timeStamp) internal {\r\n      if(dividendPathways[_node].length != 0) {\r\n        for(uint i = 0; i < dividendPathways[_node].length; i++) {\r\n          if(inSwarmTree[dividendPathways[_node][i].from] == false) { \r\n            \r\n            uint timeStamp = dividendPathways[_node][i].timeStamp;\r\n            if(timeStamp <= _timeStamp) {\r\n                \r\n              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;\r\n    \r\n                Node memory node = Node({\r\n                            node: dividendPathways[_node][i].from, \r\n                            parent: _node,\r\n                            index: i\r\n                          });\r\n                          \r\n                  swarmTree.push(node);\r\n                  inSwarmTree[node.node] = true;\r\n                  iterateThroughSwarm(node.node, timeStamp);\r\n              }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {\r\n      \r\n      uint256 share;\r\n      if(JohanInSwarm) share = _taxCollected;\r\n      else share = 0;\r\n    \r\n      for(uint i = 0; i < swarmTree.length; i++) {\r\n        \r\n        address node = swarmTree[i].node;\r\n        address parent = swarmTree[i].parent;\r\n        uint index = swarmTree[i].index;\r\n        \r\n        bool isJohan;\r\n        if(node == JohanNygren) isJohan = true;\r\n\r\n        if(isJohan) {\r\n          balanceOf[swarmTree[i].node] += share;\r\n        totalBasicIncome[node] += share;\r\n        }\r\n          \r\n        if(dividendPathways[parent][index].amount - _taxCollected > 0) {\r\n          dividendPathways[parent][index].amount -= _taxCollected; \r\n        }\r\n        else removeDividendPathway(parent, index);\r\n        \r\n        inSwarmTree[node] = false;\r\n        \r\n        /* Notifiy anyone listening that this swarm took place */\r\n        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);\r\n      }\r\n      delete swarmTree;\r\n      bool JohanWasInSwarm = JohanInSwarm;\r\n      delete JohanInSwarm;\r\n\r\n      if(!JohanWasInSwarm) return false;\r\n      return true;\r\n    }\r\n    \r\n    function removeDividendPathway(address node, uint index) internal {\r\n                delete dividendPathways[node][index];\r\n                for (uint i = index; i < dividendPathways[node].length - 1; i++) {\r\n                        dividendPathways[node][i] = dividendPathways[node][i + 1];\r\n                }\r\n                dividendPathways[node].length--;\r\n        }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividendPathways\",\"outputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"campaignOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeJohanNygrensAddress\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyViaJohan\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBasicIncome\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeCampaign\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JohanNygren\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"leaf\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"Swarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BoughtViaJohan\",\"type\":\"event\"}]","ContractName":"SwarmRedistribution","CompilerVersion":"v0.4.6+commit.2dabbdf0","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
