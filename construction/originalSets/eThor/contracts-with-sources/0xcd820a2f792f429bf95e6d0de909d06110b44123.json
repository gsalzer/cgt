{"SourceCode":"contract RequiringFunds {\r\n   modifier NeedEth () {\r\n       if (msg.value <= 0 ) throw;\r\n       _\r\n   }\r\n}\r\n\r\ncontract AmIOnTheFork {\r\n   function forked() constant returns(bool);\r\n}\r\n\r\ncontract ReplaySafeSplit is RequiringFunds {\r\n   // address private constant oracleAddress = 0x8128B12cABc6043d94BD3C4d9B9455077Eb18807;    // testnet\r\n   address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;   // mainnet\r\n\r\n   // Fork oracle to use\r\n   AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);\r\n\r\n   // Splits the funds into 2 addresses\r\n   function split(address targetFork, address targetNoFork) NeedEth returns(bool) {\r\n       // The 2 checks are to ensure that users provide BOTH addresses\r\n       // and prevent funds to be sent to 0x0 on one fork or the other.\r\n       if (targetFork == 0) throw;\r\n       if (targetNoFork == 0) throw;\r\n\r\n       if (amIOnTheFork.forked()                   // if we are on the fork\r\n           && targetFork.send(msg.value)) {        // send the ETH to the targetFork address\r\n           return true;\r\n       } else if (!amIOnTheFork.forked()           // if we are NOT on the fork\r\n           && targetNoFork.send(msg.value)) {      // send the ETH to the targetNoFork address\r\n           return true;\r\n       }\r\n\r\n       throw;                                      // don't accept value transfer, otherwise it would be trapped.\r\n   }\r\n\r\n   // Reject value transfers.\r\n   function() {\r\n       throw;\r\n   }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"targetFork\",\"type\":\"address\"},{\"name\":\"targetNoFork\",\"type\":\"address\"}],\"name\":\"split\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"}]","ContractName":"ReplaySafeSplit","CompilerVersion":"v0.3.6-2016-08-10-3fc68da","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
