{"SourceCode":"contract RockPaperScissors {\r\n  /*\r\n    Brief introduction:\r\n    the game is about to submit your pick (R/P/S) with fee to the blockchain,\r\n    join players into pairs and withdraw 2x the fee, or just 1x the fee in case of draw.\r\n    if there will be no other player in \"LimitOfMinutes\" minutes you can refund your fee.\r\n\r\n    The whole thing is made by picking a random value called SECRET_RAND, where (SECRET_RAND % 3) gives 0,1 or 2 for Rock,Paper or Scissors,\r\n    then taking a hash of SECRET_RAND and submitting it as your ticket.\r\n    At this moment player waits for opponent. If there is no opponent in \"LimitOfMinutes\", player can refund or wait more.\r\n    When both players sended their hashes then they have \"LimitOfMinutes\" minutes to announce their SECRET_RAND.\r\n    As soon as both players provided their SECRET_RAND the withdraw is possible.\r\n    If opponent will not announce his SECRET_RAND in LimitOfMinutes then the players bet is treated as a winning one.\r\n    In any case (win, draw, refund) you should use Withdraw() function to pay out.\r\n\r\n    There is fee of 1% for contract owner, charged while player withdraws.\r\n    There is no fee for contract owner in case of refund.\r\n   */\r\n\r\n  /*\r\n  JSON Interface:\r\n\r\n[{\"constant\":true,\"inputs\":[],\"name\":\"Announcement\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"name\":\"play\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MySecretRand\",\"type\":\"bytes32\"}],\"name\":\"announce\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"MyHash\",\"type\":\"bytes32\"}],\"name\":\"IsPayoutReady__InfoFunction\",\"outputs\":[{\"name\":\"Info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"RockPaperOrScissors\",\"type\":\"uint8\"},{\"name\":\"WriteHereSomeUniqeRandomStuff\",\"type\":\"string\"}],\"name\":\"CreateHash\",\"outputs\":[{\"name\":\"SendThisHashToStart\",\"type\":\"bytes32\"},{\"name\":\"YourSecretRandKey\",\"type\":\"bytes32\"},{\"name\":\"Info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"SecretRand\",\"type\":\"bytes32\"}],\"name\":\"WhatWasMyHash\",\"outputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LimitOfMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Cost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]\r\n */\r\n  modifier OnlyOwner()\r\n  { // Modifier\r\n    if (msg.sender != owner) throw;\r\n    _\r\n  }\r\n  \r\n  uint8 public LimitOfMinutes;//number of minutes you have to announce (1)your choice or (2)wait to withdraw funds back if no one else will play\r\n  uint public Cost;\r\n  string public Announcement;\r\n\r\n  address owner;\r\n  uint TimeOfLastPriceChange;\r\n  mapping(bytes32=>bet_t) bets;\r\n  uint playerssofar;\r\n  struct bet_t {\r\n    bytes32 OpponentHash;\r\n    address sender;\r\n    uint timestamp;\r\n    int8 Pick;\r\n    bool can_withdraw;//default==false\r\n  }\r\n  bytes32 LastHash;\r\n  \r\n  function RockPaperScissors()\r\n  {\r\n    playerssofar=0;\r\n    owner=msg.sender;\r\n    //SetInternalValues(limitofminutes, cost);\r\n    LimitOfMinutes=255;\r\n    Cost=100000000000000000;//0.1ETH\r\n    TimeOfLastPriceChange = now - 255*60;\r\n  }\r\n  function SetInternalValues(uint8 limitofminutes, uint cost)\r\n    OnlyOwner\r\n  {\r\n    LimitOfMinutes=limitofminutes;\r\n    if(Cost!=cost)\r\n      {\r\n\tCost=cost;\r\n\tTimeOfLastPriceChange=now;\r\n      }\r\n  }\r\n  function OwnerAnnounce(string announcement)\r\n    OnlyOwner\r\n  {\r\n    Announcement=announcement;\r\n  }\r\n \r\n  function play(bytes32 HASH)\r\n  {\r\n    if(now < TimeOfLastPriceChange + LimitOfMinutes*60 || //the game is temprorary off \r\n       msg.value != Cost || // pay to play \r\n       //bets[HASH].can_withdraw == true ||//to play twice, give another random seed in CreateHash() f-n\r\n       bets[HASH].sender != 0 || //throw because someone have already made this bet \r\n       HASH == 0 //this would be problematic situation\r\n       )\r\n      throw;\r\n\r\n    bets[HASH].sender=msg.sender;\r\n    bets[HASH].can_withdraw=true;\r\n    if(playerssofar%2 == 1)\r\n      {\r\n\tbets[HASH].OpponentHash=LastHash;\r\n\tbets[LastHash].OpponentHash=HASH;\r\n      }\r\n    else\r\n      LastHash=HASH;\r\n    bets[HASH].timestamp=now;\r\n    playerssofar++;\r\n  }\r\n\r\n  function announce(bytes32 MySecretRand)\r\n  {\r\n    if(msg.value != 0 ||\r\n       bets[sha3(MySecretRand)].can_withdraw==false)\r\n      throw; //if you try to announce non existing bet (do not waste your gas)\r\n    bets[sha3(MySecretRand)].Pick= int8( uint(MySecretRand)%3 + 1 );\r\n    //there is no check of msg.sender. If your secret rand was guessed by someone else it is no longer secret\r\n    //remember to give good 'random' seed as input of CreateHash f-n.\r\n    bets[sha3(MySecretRand)].timestamp=now;\r\n  }\r\n\r\n  function withdraw(bytes32 HASH)\r\n  { //3 ways to payout:\r\n    //1: both sides announced their picks and you have won OR draw happend\r\n    //2: no one else played - you can payout after LimitOfMinutes (100% refund)\r\n    //3: you have announced your pick but opponent not (you have won)\r\n    //note that both of you has \"LimitOfMinutes\" minutes to announce the SecretRand numbers after 2nd player played\r\n    if(msg.value != 0 || \r\n       bets[HASH].can_withdraw == false)\r\n      throw;\r\n\r\n    if(bets[HASH].OpponentHash!=0 && //case 1\r\n       bets[bets[HASH].OpponentHash].Pick != 0 && //check if opponent announced\r\n       bets[HASH].Pick != 0 //check if player announced\r\n       //it is impossible for val .Pick to be !=0 without broadcasting SecretRand\r\n       )\r\n      {\r\n\tint8 tmp = bets[HASH].Pick - bets[bets[HASH].OpponentHash].Pick;\r\n\tif(tmp==0)//draw?\r\n\t  {\r\n\t    bets[HASH].can_withdraw=false;\r\n\t    if(!bets[HASH].sender.send(Cost*99/100)) //return ETH\r\n\t      throw;\r\n\t    else\r\n\t      if(!owner.send(Cost/100))\r\n\t\tthrow;\r\n\t  }\r\n\telse if(tmp == 1 || tmp == -2)//you have won\r\n\t  {\r\n\t    bets[HASH].can_withdraw=false;\r\n\t    bets[bets[HASH].OpponentHash].can_withdraw=false;\r\n\t    if(!bets[HASH].sender.send(2*Cost*99/100)) //refund\r\n\t      throw;\t    \r\n\t    else\r\n\t      if(!owner.send(2*Cost/100))\r\n\t\tthrow;\r\n\t  }\r\n\telse\r\n\t  throw;\r\n      }\r\n    else if(bets[HASH].OpponentHash==0 && //case 2\r\n\t    now > bets[HASH].timestamp + LimitOfMinutes*60)\r\n      {\r\n\tbets[HASH].can_withdraw=false;\r\n\tif(!bets[HASH].sender.send(Cost)) //refund\r\n\t  throw;\r\n\r\n\t//if we are here that means we should repair playerssofar\r\n\t--playerssofar;\r\n      }\r\n    else if(bets[HASH].OpponentHash!=0 && \r\n\t    bets[bets[HASH].OpponentHash].Pick == 0 && //opponent did not announced\r\n\t    bets[HASH].Pick != 0 //check if player announced\r\n\t    )//case 3\r\n      {\r\n\t//now lets make sure that opponent had enough time to announce\r\n\tif(//now > (time of last interaction from player or opponent)\r\n\t   now > bets[HASH].timestamp + LimitOfMinutes*60 &&\r\n\t   now > bets[bets[HASH].OpponentHash].timestamp + LimitOfMinutes*60\r\n\t   )//then refund is possible\r\n\t  {\r\n\t    bets[HASH].can_withdraw=false;\r\n\t    bets[bets[HASH].OpponentHash].can_withdraw=false;\r\n\t    if(!bets[HASH].sender.send(2*Cost*99/100)) \r\n\t      throw;\r\n\t    else\r\n\t      if(!owner.send(2*Cost/100))\r\n\t\tthrow;\r\n\t  }\r\n\telse\r\n\t  throw;//you still need to wait some more time\r\n      }\r\n    else\r\n      throw; //throw in any other case\r\n    //here program flow jumps\r\n    //and program ends\r\n  }\r\n\r\n  function IsPayoutReady__InfoFunction(bytes32 MyHash)\r\n    constant\r\n    returns (string Info) \r\n  {\r\n    // \"write your hash\"\r\n    // \"you can send this hash and double your ETH!\"\r\n    // \"wait for opponent [Xmin left]\"\r\n    // \"you can announce your SecretRand\"\r\n    // \"wait for opponent SecretRand\"\r\n    // \"ready to withdraw - you have won!\"\r\n    // \"you have lost, try again\"\r\n    if(MyHash == 0)\r\n      return \"write your hash\";\r\n    if(bets[MyHash].sender == 0) \r\n      return \"you can send this hash and double your ETH!\";\r\n    if(bets[MyHash].sender != 0 &&\r\n       bets[MyHash].can_withdraw==false) \r\n      return \"this bet is burned\";\r\n    if(bets[MyHash].OpponentHash==0 &&\r\n       now < bets[MyHash].timestamp + LimitOfMinutes*60)\r\n      return \"wait for other player\";\r\n    if(bets[MyHash].OpponentHash==0)\r\n      return \"no one played, use withdraw() for refund\";\r\n    \r\n    //from now there is opponent\r\n    bool timeforaction =\r\n      (now < bets[MyHash].timestamp + LimitOfMinutes*60) ||\r\n      (now < bets[bets[MyHash].OpponentHash].timestamp + LimitOfMinutes*60 );\r\n    \r\n    if(bets[MyHash].Pick == 0 &&\r\n       timeforaction\r\n       )\r\n      return \"you can announce your SecretRand\";\r\n    if(bets[MyHash].Pick == 0)\r\n      return \"you have failed to announce your SecretRand but still you can try before opponent withdraws\";\r\n    if(bets[bets[MyHash].OpponentHash].Pick == 0 &&\r\n       timeforaction\r\n       )\r\n      return \"wait for opponent SecretRand\";\r\n\r\n\r\n    bool win=false;\r\n    bool draw=false;\r\n    int8 tmp = bets[MyHash].Pick - bets[bets[MyHash].OpponentHash].Pick;\r\n    if(tmp==0)//draw?\r\n      draw=true;\r\n    else if(tmp == 1 || tmp == -2)//you have won\r\n      win=true;\r\n    \r\n    if(bets[bets[MyHash].OpponentHash].Pick == 0 ||\r\n       win\r\n       )\r\n      return \"you have won! now you can withdraw your ETH\";\r\n    if(draw)\r\n      return \"Draw happend! withdraw back your funds\";\r\n\r\n\r\n    return \"you have lost, try again\";\r\n  }\r\n\r\n  function WhatWasMyHash(bytes32 SecretRand)\r\n    constant\r\n    returns (bytes32 HASH) \r\n  {\r\n    return sha3(SecretRand);\r\n  }\r\n\r\n  function CreateHash(uint8 RockPaperOrScissors, string WriteHereSomeUniqeRandomStuff)\r\n    constant\r\n    returns (bytes32 SendThisHashToStart,\r\n\t     bytes32 YourSecretRandKey,\r\n\t     string Info)\r\n  {\r\n    uint SecretRand;\r\n\r\n    SecretRand=3*( uint(sha3(WriteHereSomeUniqeRandomStuff))/3 ) + (RockPaperOrScissors-1)%3;\r\n    //SecretRand%3 ==\r\n    //0 - Rock\r\n    //1 - Paper\r\n    //2 - Scissors\r\n\r\n    if(RockPaperOrScissors==0)\r\n      return(0,0, \"enter 1 for Rock, 2 for Paper, 3 for Scissors\");\r\n\r\n    return (sha3(bytes32(SecretRand)),bytes32(SecretRand),  bets[sha3(bytes32(SecretRand))].sender != 0 ? \"someone have already used this random string - try another one\" :\r\n                                                            SecretRand%3==0 ? \"Rock\" :\r\n\t                                                        SecretRand%3==1 ? \"Paper\" :\r\n\t                                                        \"Scissors\");\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"limitofminutes\",\"type\":\"uint8\"},{\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"SetInternalValues\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Announcement\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LimitOfMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"MySecretRand\",\"type\":\"bytes32\"}],\"name\":\"announce\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"MyHash\",\"type\":\"bytes32\"}],\"name\":\"IsPayoutReady__InfoFunction\",\"outputs\":[{\"name\":\"Info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"SecretRand\",\"type\":\"bytes32\"}],\"name\":\"WhatWasMyHash\",\"outputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"HASH\",\"type\":\"bytes32\"}],\"name\":\"play\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"announcement\",\"type\":\"string\"}],\"name\":\"OwnerAnnounce\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"RockPaperOrScissors\",\"type\":\"uint8\"},{\"name\":\"WriteHereSomeUniqeRandomStuff\",\"type\":\"string\"}],\"name\":\"CreateHash\",\"outputs\":[{\"name\":\"SendThisHashToStart\",\"type\":\"bytes32\"},{\"name\":\"YourSecretRandKey\",\"type\":\"bytes32\"},{\"name\":\"Info\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Cost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]","ContractName":"RockPaperScissors","CompilerVersion":"v0.3.6+commit.3fc68da","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"","SwarmSource":""}
