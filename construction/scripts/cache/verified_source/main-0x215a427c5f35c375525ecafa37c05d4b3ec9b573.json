{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.8;\r\n\r\ncontract BetterAuction {\r\n    // Mapping for members of multisig\r\n    mapping (address => bool) public members;\r\n    // Auction start time, seconds from 1970-01-01\r\n    uint256 public auctionStart;\r\n    // Auction bidding period in seconds, relative to auctionStart\r\n    uint256 public biddingPeriod;\r\n    // Period after auction ends when the multisig proposals can withdraw all funds, relative to auctionStart\r\n    uint256 public recoveryAfterPeriod;\r\n    // User sends this amount to the contract to withdraw funds, 0.0001 ETH\r\n    uint256 public constant WITHDRAWAL_TRIGGER_AMOUNT = 100000000000000;\r\n    // Number of required signatures\r\n    uint256 public constant REQUIRED_SIGNATURES = 2;\r\n    // Proposal to spend\r\n    Proposal[] public proposals;\r\n    // Number of proposals\r\n    uint256 public numProposals;\r\n    // Address of the highest bidder\r\n    address public highestBidder;\r\n    // Highest bid amount\r\n    uint256 public highestBid;\r\n    // Allowed withdrawals of previous bids\r\n    mapping(address => uint256) pendingReturns;\r\n    // Set to true at the end, disallows any change\r\n    bool auctionClosed;\r\n\r\n     address _address1 =0xb7cf43651d8f370218cF92B00261cA3e1B02Fda0;\r\n     address _address2 = 0x60CE2769E5d330303Bd9Df88F7b843A40510F173;\r\n     address _address3 = 0x7422B53EB5f57AdAea0DdffF82ef765Cfbc4DBf0;\r\n     uint256 _biddingPeriod = 1800;\r\n     uint256 _recoveryAfterPeriod = 1000000;\r\n     \r\n     \r\n    struct Proposal {\r\n        address recipient;\r\n        uint256 numVotes;\r\n        mapping (address => bool) voted;\r\n        bool isRecover;\r\n    }\r\n \r\n    modifier isMember {\r\n        if (members[msg.sender] == false) throw;\r\n        _;\r\n    }\r\n \r\n    modifier isAuctionActive {\r\n        if (now < auctionStart || now > (auctionStart + biddingPeriod)) throw;\r\n        _;\r\n    }\r\n \r\n    modifier isAuctionEnded {\r\n        if (now < (auctionStart + biddingPeriod)) throw;\r\n        _;\r\n    }\r\n\r\n    event HighestBidIncreased(address bidder, uint256 amount);\r\n    event AuctionClosed(address winner, uint256 amount);\r\n    event ProposalAdded(uint proposalID, address recipient);\r\n    event Voted(uint proposalID, address voter);\r\n\r\n    // Auction starts at deployment, runs for _biddingPeriod (seconds from \r\n    // auction start), and funds can be recovered after _recoverPeriod \r\n    // (seconds from auction start)\r\n    function BetterAuction(\r\n\r\n    ) {\r\n        if (_address1 == 0 || _address2 == 0 || _address3 == 0) throw;\r\n        members[_address1] = true;\r\n        members[_address2] = true;\r\n        members[_address3] = true;\r\n        auctionStart = now;\r\n        if (_biddingPeriod > _recoveryAfterPeriod) throw;\r\n        biddingPeriod = _biddingPeriod;\r\n        recoveryAfterPeriod = _recoveryAfterPeriod;\r\n    }\r\n \r\n    // Users want to know when the auction ends, seconds from 1970-01-01\r\n    function auctionEndTime() constant returns (uint256) {\r\n        return auctionStart + biddingPeriod;\r\n    }\r\n\r\n    // Users want to know theirs or someones current bid\r\n    function getBid(address _address) constant returns (uint256) {\r\n        if (_address == highestBidder) {\r\n            return highestBid;\r\n        } else {\r\n            return pendingReturns[_address];\r\n        }\r\n    }\r\n\r\n    // Update highest bid or top up previous bid\r\n    function bidderUpdateBid() internal {\r\n        if (msg.sender == highestBidder) {\r\n            highestBid += msg.value;\r\n            HighestBidIncreased(msg.sender, highestBid);\r\n        } else if (pendingReturns[msg.sender] + msg.value > highestBid) {\r\n            var amount = pendingReturns[msg.sender] + msg.value;\r\n            pendingReturns[msg.sender] = 0;\r\n            // Save previous highest bidders funds\r\n            pendingReturns[highestBidder] = highestBid;\r\n            // Record the highest bid\r\n            highestBid = amount;\r\n            highestBidder = msg.sender;\r\n            HighestBidIncreased(msg.sender, amount);\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n \r\n    // Bidders can only place bid while the auction is active \r\n    function bidderPlaceBid() isAuctionActive payable {\r\n        if ((pendingReturns[msg.sender] > 0 || msg.sender == highestBidder) && msg.value > 0) {\r\n            bidderUpdateBid();\r\n        } else {\r\n            // Reject bids below the highest bid\r\n            if (msg.value <= highestBid) throw;\r\n            // Save previous highest bidders funds\r\n            if (highestBidder != 0) {\r\n                pendingReturns[highestBidder] = highestBid;\r\n            }\r\n            // Record the highest bid\r\n            highestBidder = msg.sender;\r\n            highestBid = msg.value;\r\n            HighestBidIncreased(msg.sender, msg.value);\r\n        }\r\n    }\r\n \r\n    // Withdraw a bid that was overbid.\r\n    function nonHighestBidderRefund() payable {\r\n        var amount = pendingReturns[msg.sender];\r\n        if (amount > 0) {\r\n            pendingReturns[msg.sender] = 0;\r\n            if (!msg.sender.send(amount + msg.value)) throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Multisig member creates a proposal to send ether out of the contract\r\n    function createProposal (address recipient, bool isRecover) isMember isAuctionEnded {\r\n        var proposalID = proposals.length++;\r\n        Proposal p = proposals[proposalID];\r\n        p.recipient = recipient;\r\n        p.voted[msg.sender] = true;\r\n        p.numVotes = 1;\r\n        numProposals++;\r\n        Voted(proposalID, msg.sender);\r\n        ProposalAdded(proposalID, recipient);\r\n    }\r\n\r\n    // Multisig member votes on a proposal\r\n    function voteProposal (uint256 proposalID) isMember isAuctionEnded {\r\n        Proposal p = proposals[proposalID];\r\n        \r\n        if ( p.voted[msg.sender] ) throw;\r\n        p.voted[msg.sender] = true;\r\n        p.numVotes++;\r\n\r\n        // Required signatures have been met\r\n        if (p.numVotes >= REQUIRED_SIGNATURES) {\r\n            if ( p.isRecover ) {\r\n                // Is it too early for recovery?\r\n                if (now < (auctionStart + recoveryAfterPeriod)) throw;\r\n                // Recover any ethers accidentally sent to contract\r\n                if (!p.recipient.send(this.balance)) throw;\r\n            } else {\r\n                if (auctionClosed) throw;\r\n                auctionClosed = true;\r\n                AuctionClosed(highestBidder, highestBid);\r\n                // Send highest bid to recipient\r\n                if (!p.recipient.send(highestBid)) throw;\r\n            }\r\n        }\r\n    }\r\n \r\n    // Bidders send their bids to the contract. If this is the trigger amount\r\n    // allow non-highest bidders to withdraw their funds\r\n    function () payable {\r\n        if (msg.value == WITHDRAWAL_TRIGGER_AMOUNT) {\r\n            nonHighestBidderRefund();\r\n        } else {\r\n            bidderPlaceBid();\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"numVotes\",\"type\":\"uint256\"},{\"name\":\"isRecover\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recoveryAfterPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_TRIGGER_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"biddingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nonHighestBidderRefund\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bidderPlaceBid\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"voteProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestBidder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REQUIRED_SIGNATURES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"isRecover\",\"type\":\"bool\"}],\"name\":\"createProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"highestBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"HighestBidIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuctionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proposalID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"}]", "ContractName": "BetterAuction", "CompilerVersion": "v0.4.14-nightly.2017.7.21+commit.75b48616", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://5fc4a90668b7df64db678e581fcc47deb3b8b9ee0420d0115bc7efc4b5b9a194"}]}