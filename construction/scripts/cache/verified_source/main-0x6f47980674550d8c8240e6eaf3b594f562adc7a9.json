{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.2;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner == 0x0000000000000000000000000000000000000000) throw;\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\n\r\n\r\n\r\n/* Dentacoin Contract */\r\ncontract token is owned {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n    uint256 public buyPriceEth;\r\n    uint256 public sellPriceEth;\r\n    uint256 public minBalanceForAccounts;\r\n//Public variables of the token\r\n\r\n\r\n/* Creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\r\n/* Generates a public event on the blockchain that will notify clients */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n/* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function token() {\r\n        totalSupply = 8000000000000;\r\n        balanceOf[msg.sender] = totalSupply;\r\n// Give the creator all tokens\r\n        name = \"Dentacoin\";\r\n// Set the name for display purposes\r\n        symbol = \"\u0668\";\r\n// Set the symbol for display purposes\r\n        decimals = 0;\r\n// Amount of decimals for display purposes\r\n        buyPriceEth = 1 finney;\r\n        sellPriceEth = 1 finney;\r\n// Sell and buy prices for Dentacoins\r\n        minBalanceForAccounts = 5 finney;\r\n// Minimal eth balance of sender and receiver\r\n    }\r\n\r\n\r\n\r\n\r\n/* Constructor parameters */\r\n    function setEtherPrices(uint256 newBuyPriceEth, uint256 newSellPriceEth) onlyOwner {\r\n        buyPriceEth = newBuyPriceEth;\r\n        sellPriceEth = newSellPriceEth;\r\n    }\r\n\r\n    function setMinBalance(uint minimumBalanceInWei) onlyOwner {\r\n     minBalanceForAccounts = minimumBalanceInWei;\r\n    }\r\n\r\n\r\n\r\n\r\n/* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (_value < 1) throw;\r\n// Prevents drain, spam and overflows\r\n        address DentacoinAddress = this;\r\n        if (msg.sender != owner && _to == DentacoinAddress) {\r\n            sellDentacoinsAgainstEther(_value);\r\n// Sell Dentacoins against eth by sending to the token contract\r\n        } else {\r\n            if (balanceOf[msg.sender] < _value) throw;\r\n// Check if the sender has enough\r\n            if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n// Check for overflows\r\n            balanceOf[msg.sender] -= _value;\r\n// Subtract from the sender\r\n            if (msg.sender.balance >= minBalanceForAccounts && _to.balance >= minBalanceForAccounts) {\r\n                balanceOf[_to] += _value;\r\n// Add the same to the recipient\r\n                Transfer(msg.sender, _to, _value);\r\n// Notify anyone listening that this transfer took place\r\n            } else {\r\n                balanceOf[this] += 1;\r\n                balanceOf[_to] += (_value - 1);\r\n// Add the same to the recipient\r\n                Transfer(msg.sender, _to, _value);\r\n// Notify anyone listening that this transfer took place\r\n                if(msg.sender.balance < minBalanceForAccounts) {\r\n                    if(!msg.sender.send(minBalanceForAccounts * 3)) throw;\r\n// Send minBalance to Sender\r\n                }\r\n                if(_to.balance < minBalanceForAccounts) {\r\n                    if(!_to.send(minBalanceForAccounts)) throw;\r\n// Send minBalance to Receiver\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n/* User buys Dentacoins and pays in Ether */\r\n    function buyDentacoinsAgainstEther() payable returns (uint amount) {\r\n        if (buyPriceEth == 0) throw;\r\n// Avoid buying if not allowed\r\n        if (msg.value < buyPriceEth) throw;\r\n// Avoid sending small amounts and spam\r\n        amount = msg.value / buyPriceEth;\r\n// Calculate the amount of Dentacoins\r\n        if (balanceOf[this] < amount) throw;\r\n// Check if it has enough to sell\r\n        balanceOf[msg.sender] += amount;\r\n// Add the amount to buyer's balance\r\n        balanceOf[this] -= amount;\r\n// Subtract amount from seller's balance\r\n        Transfer(this, msg.sender, amount);\r\n// Execute an event reflecting the change\r\n        return amount;\r\n    }\r\n\r\n\r\n/* User sells Dentacoins and gets Ether */\r\n    function sellDentacoinsAgainstEther(uint256 amount) returns (uint revenue) {\r\n        if (sellPriceEth == 0) throw;\r\n// Avoid selling\r\n        if (amount < 1) throw;\r\n// Avoid spam\r\n        if (balanceOf[msg.sender] < amount) throw;\r\n// Check if the sender has enough to sell\r\n        revenue = amount * sellPriceEth;\r\n// revenue = eth that will be send to the user\r\n        if ((this.balance - revenue) < (100 * minBalanceForAccounts)) throw;\r\n// Keep certain amount of eth in contract for tx fees\r\n        balanceOf[this] += amount;\r\n// Add the amount to owner's balance\r\n        balanceOf[msg.sender] -= amount;\r\n// Subtract the amount from seller's balance\r\n        if (!msg.sender.send(revenue)) {\r\n// Send ether to the seller. It's important\r\n            throw;\r\n// To do this last to avoid recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amount);\r\n// Execute an event reflecting on the change\r\n            return revenue;\r\n// End function and returns\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n/* Allow another contract to spend some tokens in your behalf */\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        return true;\r\n    }\r\n\r\n\r\n/* Approve and then comunicate the approved contract in a single tx */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n/* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balanceOf[_from] < _value) throw;\r\n// Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\r\n// Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;\r\n// Check allowance\r\n        balanceOf[_from] -= _value;\r\n// Subtract from the sender\r\n        balanceOf[_to] += _value;\r\n// Add the same to the recipient\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n/* refund To Owner */\r\n    function refundToOwner (uint256 amountOfEth, uint256 dcn) onlyOwner {\r\n        uint256 eth = amountOfEth * 1 ether;\r\n        if (!msg.sender.send(eth)) {\r\n// Send ether to the owner. It's important\r\n            throw;\r\n// To do this last to avoid recursion attacks\r\n        } else {\r\n            Transfer(msg.sender, this, amountOfEth);\r\n// Execute an event reflecting on the change\r\n        }\r\n        if (balanceOf[this] < dcn) throw;\r\n// Check if it has enough to sell\r\n        balanceOf[msg.sender] += dcn;\r\n// Add the amount to buyer's balance\r\n        balanceOf[this] -= dcn;\r\n// Subtract amount from seller's balance\r\n        Transfer(this, msg.sender, dcn);\r\n// Execute an event reflecting the change\r\n    }\r\n\r\n\r\n/* This unnamed function is called whenever someone tries to send ether to it and sells Dentacoins */\r\n    function() payable {\r\n        if (msg.sender != owner) {\r\n            buyDentacoinsAgainstEther();\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"sellPriceEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyDentacoinsAgainstEther\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBalanceForAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBuyPriceEth\",\"type\":\"uint256\"},{\"name\":\"newSellPriceEth\",\"type\":\"uint256\"}],\"name\":\"setEtherPrices\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPriceEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountOfEth\",\"type\":\"uint256\"},{\"name\":\"dcn\",\"type\":\"uint256\"}],\"name\":\"refundToOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellDentacoinsAgainstEther\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minimumBalanceInWei\",\"type\":\"uint256\"}],\"name\":\"setMinBalance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "token", "CompilerVersion": "v0.4.2+commit.af6afb04", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}