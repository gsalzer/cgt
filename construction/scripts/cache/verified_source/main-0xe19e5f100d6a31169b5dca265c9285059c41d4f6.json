{"status": "1", "message": "OK", "result": [{"SourceCode": "contract NanoPyramid {\r\n    \r\n    uint private pyramidMultiplier = 140;\r\n    uint private minAmount = 1 finney;\r\n    uint private maxAmount = 1 ether;\r\n    uint private fee = 2;\r\n    uint private collectedFees = 0;\r\n    uint private minFeePayout = 100 finney;\r\n    \r\n    address private owner;\r\n    \r\n    \r\n    function NanoPyramid() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyowner { if (msg.sender == owner) _ }\r\n    \r\n    \r\n    struct Participant {\r\n        address etherAddress;\r\n        uint payout;\r\n    }\r\n    \r\n    Participant[] public participants;\r\n    \r\n    \r\n    uint public payoutOrder = 0;\r\n    uint public balance = 0;\r\n    \r\n    \r\n    function() {\r\n        enter();\r\n    }\r\n    \r\n    function enter() {\r\n        // Check if amount is too small\r\n        if (msg.value < minAmount) {\r\n            // Amount is too small, no need to think about refund\r\n            collectedFees += msg.value;\r\n            return;\r\n        }\r\n        \r\n        // Check if amount is too high\r\n        uint amount;\r\n        if (msg.value > maxAmount) {\r\n            uint amountToRefund =  msg.value - maxAmount;\r\n            if (amountToRefund >= minAmount) {\r\n            \tif (!msg.sender.send(amountToRefund)) {\r\n            \t    throw;\r\n            \t}\r\n        \t}\r\n            amount = maxAmount;\r\n        }\r\n        else {\r\n        \tamount = msg.value;\r\n        }\r\n        \r\n        //Adds new address to the participant array\r\n        participants.push(Participant(\r\n            msg.sender, \r\n            amount * pyramidMultiplier / 100\r\n        ));\r\n            \r\n        // Update fees and contract balance\r\n        balance += (amount * (100 - fee)) / 100;\r\n        collectedFees += (amount * fee) / 100;\r\n        \r\n        //Pays earlier participiants if balance sufficient\r\n        while (balance > participants[payoutOrder].payout) {\r\n            uint payoutToSend = participants[payoutOrder].payout;\r\n            participants[payoutOrder].etherAddress.send(payoutToSend);\r\n            balance -= payoutToSend;\r\n            payoutOrder += 1;\r\n        }\r\n        \r\n        // Collect fees\r\n        if (collectedFees >= minFeePayout) {\r\n            if (!owner.send(collectedFees)) {\r\n                // Potentially sending money to a contract that\r\n                // has a fallback function.  So instead, try\r\n                // tranferring the funds with the call api.\r\n                if (owner.call.gas(msg.gas).value(collectedFees)()) {\r\n                    collectedFees = 0;\r\n                }\r\n            } else {\r\n                collectedFees = 0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function totalParticipants() constant returns (uint count) {\r\n        count = participants.length;\r\n    }\r\n\r\n    function awaitingParticipants() constant returns (uint count) {\r\n        count = participants.length - payoutOrder;\r\n    }\r\n\r\n    function outstandingBalance() constant returns (uint amount) {\r\n        uint payout = 0;\r\n        uint idx;\r\n        for (idx = payoutOrder; idx < participants.length; idx++) {\r\n            payout += participants[idx].payout;\r\n        }\r\n        amount = payout - balance;\r\n    }\r\n\r\n\r\n    function setOwner(address _owner) onlyowner {\r\n        owner = _owner;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outstandingBalance\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"etherAddress\",\"type\":\"address\"},{\"name\":\"payout\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"awaitingParticipants\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enter\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]", "ContractName": "NanoPyramid", "CompilerVersion": "v0.3.1-2016-03-31-c492d9b", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}