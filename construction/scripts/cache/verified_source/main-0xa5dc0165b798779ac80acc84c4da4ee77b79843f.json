{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n/**\r\n*\r\n*    I  N    P  I  Z  Z  A     W  E     C  R  U  S  T\r\n*  \r\n*    ______ ____   _____       _____ _\r\n*   |  ____/ __ \\ / ____|     |  __ (_)\r\n*   | |__ | |  | | (___       | |__) | __________ _\r\n*   |  __|| |  | |\\___ \\      |  ___/ |_  /_  / _` |\r\n*   | |___| |__| |____) |  _  | |   | |/ / / / (_| |\r\n*   |______\\____/|_____/  (_) |_|   |_/___/___\\__,_|\r\n*\r\n*\r\n*\r\n*   CHECK HTTPS://EOS.PIZZA ON HOW TO GET YOUR SLICE\r\n*   END: 18 MAY 2018\r\n*\r\n*   This is for the fun. Thank you token factory for your smart contract inspiration.\r\n*   Jummy & crusty. Get your ?EPS while it's hot. \r\n*\r\n*   https://eos.pizza\r\n*\r\n*\r\n**/\r\n\r\n// File: contracts\\configs\\EosPizzaSliceConfig.sol\r\n\r\n\r\n/**\r\n * @title EosPizzaSliceConfig\r\n *\r\n * @dev The static configuration for the EOS Pizza Slice.\r\n */\r\ncontract EosPizzaSliceConfig {\r\n    // The name of the token.\r\n    string constant NAME = \"EOS.Pizza\";\r\n\r\n    // The symbol of the token.\r\n    string constant SYMBOL = \"EPS\";\r\n\r\n    // The number of decimals for the token.\r\n    uint8 constant DECIMALS = 18;  // Same as ethers.\r\n\r\n    // Decimal factor for multiplication purposes.\r\n    uint constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC20TokenInterface.sol\r\n\r\n/**\r\n * @dev The standard ERC20 Token interface.\r\n */\r\ncontract ERC20TokenInterface {\r\n    uint public totalSupply;  /* shorthand for public function and a property */\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\n/**\r\n * @dev Library that helps prevent integer overflows and underflows,\r\n * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\r\n */\r\nlibrary SafeMath {\r\n    function plus(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\ERC20Token.sol\r\n\r\n/**\r\n * @title ERC20Token\r\n *\r\n * @dev Implements the operations declared in the `ERC20TokenInterface`.\r\n */\r\ncontract ERC20Token is ERC20TokenInterface {\r\n    using SafeMath for uint;\r\n\r\n    // Token account balances.\r\n    mapping (address => uint) balances;\r\n\r\n    // Delegated number of tokens to transfer.\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n\r\n\r\n    /**\r\n     * @dev Checks the balance of a certain address.\r\n     *\r\n     * @param _account The address which's balance will be checked.\r\n     *\r\n     * @return Returns the balance of the `_account` address.\r\n     */\r\n    function balanceOf(address _account) public constant returns (uint balance) {\r\n        return balances[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from one address to another.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        if (balances[msg.sender] < _value || _value == 0) {\r\n\r\n            return false;\r\n        }\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] = balances[_to].plus(_value);\r\n\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {\r\n            return false;\r\n        }\r\n\r\n        balances[_to] = balances[_to].plus(_value);\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\r\n     *\r\n     * @param _owner The account which allowed the transfer.\r\n     * @param _spender The account which will spend the tokens.\r\n     *\r\n     * @return The number of tokens to be transferred.\r\n     */\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\HasOwner.sol\r\n\r\n/**\r\n * @title HasOwner\r\n *\r\n * @dev Allows for exclusive access to certain functionality.\r\n */\r\ncontract HasOwner {\r\n    // Current owner.\r\n    address public owner;\r\n\r\n    // Conditionally the new owner.\r\n    address public newOwner;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _owner The address of the owner.\r\n     */\r\n    function HasOwner(address _owner) internal {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only the current owner to call the function.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev The event is fired when the current owner is changed.\r\n     *\r\n     * @param _oldOwner The address of the previous owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Transfering the ownership is a two-step process, as we prepare\r\n     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\r\n     * the transfer. This prevents accidental lock-out if something goes wrong\r\n     * when passing the `newOwner` address.\r\n     *\r\n     * @param _newOwner The address of the proposed new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev The `newOwner` finishes the ownership transfer process by accepting the\r\n     * ownership.\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n\r\n        OwnershipTransfer(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\Freezable.sol\r\n\r\n/**\r\n * @title Freezable\r\n * @dev This trait allows to freeze the transactions in a Token\r\n */\r\ncontract Freezable is HasOwner {\r\n  bool public frozen = false;\r\n\r\n  /**\r\n   * @dev Modifier makes methods callable only when the contract is not frozen.\r\n   */\r\n  modifier requireNotFrozen() {\r\n    require(!frozen);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"freeze\" the contract.\r\n   */\r\n  function freeze() onlyOwner public {\r\n    frozen = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the owner to \"unfreeze\" the contract.\r\n   */\r\n  function unfreeze() onlyOwner public {\r\n    frozen = false;\r\n  }\r\n}\r\n\r\n// File: contracts\\traits\\FreezableERC20Token.sol\r\n\r\n/**\r\n * @title FreezableERC20Token\r\n *\r\n * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\r\n */\r\ncontract FreezableERC20Token is ERC20Token, Freezable {\r\n    /**\r\n     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\r\n     *\r\n     * @param _to The target address to which the `_value` number of tokens will be sent.\r\n     * @param _value The number of tokens to send.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\r\n     *\r\n     * @param _from The address of the sender.\r\n     * @param _to The address of the recipient.\r\n     * @param _value The number of tokens to be transferred.\r\n     *\r\n     * @return Whether the transfer was successful or not.\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows another contract to spend some tokens on your behalf.\r\n     *\r\n     * @param _spender The address of the account which will be approved for transfer of tokens.\r\n     * @param _value The number of tokens to be approved for transfer.\r\n     *\r\n     * @return Whether the approval was successful or not.\r\n     */\r\n    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\EosPizzaSlice.sol\r\n\r\n/**\r\n * @title EOS Pizza Slice\r\n *\r\n * @dev A standard token implementation of the ERC20 token standard with added\r\n *      HasOwner trait and initialized using the configuration constants.\r\n */\r\ncontract EosPizzaSlice is EosPizzaSliceConfig, HasOwner, FreezableERC20Token {\r\n    // The name of the token.\r\n    string public name;\r\n\r\n    // The symbol for the token.\r\n    string public symbol;\r\n\r\n    // The decimals of the token.\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @dev The constructor. Initially sets `totalSupply` and the balance of the\r\n     *      `owner` address according to the initialization parameter.\r\n     */\r\n    function EosPizzaSlice(uint _totalSupply) public\r\n        HasOwner(msg.sender)\r\n    {\r\n        name = NAME;\r\n        symbol = SYMBOL;\r\n        decimals = DECIMALS;\r\n        totalSupply = _totalSupply;\r\n        balances[owner] = _totalSupply;\r\n    }\r\n}\r\n\r\n// File: contracts\\configs\\EosPizzaSliceDonationraiserConfig.sol\r\n\r\n/**\r\n * @title EosPizzaSliceDonationraiserConfig\r\n *\r\n * @dev The static configuration for the EOS Pizza Slice donationraiser.\r\n */\r\ncontract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig {\r\n    // The number of ? per 1 ETH.\r\n    uint constant CONVERSION_RATE = 100000;\r\n\r\n    // The public sale hard cap of the donationraiser.\r\n    uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR;\r\n\r\n    // The start date of the donationraiser: Friday, 9 March 2018 21:22:22 UTC.\r\n    uint constant START_DATE = 1520630542;\r\n\r\n    // The end date of the donationraiser:  May 18, 2018, 12:35:20 AM UTC - Bitcoin Pizza 8th year celebration moment.\r\n    uint constant END_DATE =  1526603720;\r\n\r\n\r\n    // Total number of tokens locked for the ? core team.\r\n    uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR;\r\n\r\n    // Total number of tokens locked for ? advisors.\r\n    uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR;\r\n\r\n    // The release date for tokens locked for the ? core team.\r\n    uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days;\r\n\r\n    // The release date for tokens locked for ? advisors.\r\n    uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days;\r\n\r\n    // Total number of tokens locked for bounty program.\r\n    uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR;\r\n\r\n    // Maximum gas price limit\r\n    uint constant MAX_GAS_PRICE = 90000000000 wei; // 90 gwei/shanon\r\n\r\n    // Minimum individual contribution\r\n    uint constant MIN_CONTRIBUTION =  0.05 ether;\r\n\r\n    // Individual limit in ether\r\n    uint constant INDIVIDUAL_ETHER_LIMIT =  4999 ether;\r\n}\r\n\r\n// File: contracts\\traits\\TokenSafe.sol\r\n\r\n/**\r\n * @title TokenSafe\r\n *\r\n * @dev A multi-bundle token safe contract that contains locked tokens released after a date for the specific bundle type.\r\n */\r\ncontract TokenSafe {\r\n    using SafeMath for uint;\r\n\r\n    struct AccountsBundle {\r\n        // The total number of tokens locked.\r\n        uint lockedTokens;\r\n        // The release date for the locked tokens\r\n        // Note: Unix timestamp fits uint32, however block.timestamp is uint\r\n        uint releaseDate;\r\n        // The balances for the ? locked token accounts.\r\n        mapping (address => uint) balances;\r\n    }\r\n\r\n    // The account bundles of locked tokens grouped by release date\r\n    mapping (uint8 => AccountsBundle) public bundles;\r\n\r\n    // The `ERC20TokenInterface` contract.\r\n    ERC20TokenInterface token;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the EOS Pizza Slices (donation) contract.\r\n     */\r\n    function TokenSafe(address _token) public {\r\n        token = ERC20TokenInterface(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev The function initializes the bundle of accounts with a release date.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _releaseDate Unix timestamp of the time after which the tokens can be released\r\n     */\r\n    function initBundle(uint8 _type, uint _releaseDate) internal {\r\n        bundles[_type].releaseDate = _releaseDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Add new account with locked token balance to the specified bundle type.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _account The address of the account to be added.\r\n     * @param _balance The number of tokens to be locked.\r\n     */\r\n    function addLockedAccount(uint8 _type, address _account, uint _balance) internal {\r\n        var bundle = bundles[_type];\r\n        bundle.balances[_account] = bundle.balances[_account].plus(_balance);\r\n        bundle.lockedTokens = bundle.lockedTokens.plus(_balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows an account to be released if it meets the time constraints.\r\n     *\r\n     * @param _type Bundle type.\r\n     * @param _account The address of the account to be released.\r\n     */\r\n    function releaseAccount(uint8 _type, address _account) internal {\r\n        var bundle = bundles[_type];\r\n        require(now >= bundle.releaseDate);\r\n        uint tokens = bundle.balances[_account];\r\n        require(tokens > 0);\r\n        bundle.balances[_account] = 0;\r\n        bundle.lockedTokens = bundle.lockedTokens.minus(tokens);\r\n        if (!token.transfer(_account, tokens)) {\r\n            revert();\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\EosPizzaSliceSafe.sol\r\n\r\n/**\r\n * @title EosPizzaSliceSafe\r\n *\r\n * @dev The EOS Pizza Slice safe containing all details about locked tokens.\r\n */\r\ncontract EosPizzaSliceSafe is TokenSafe, EosPizzaSliceDonationraiserConfig {\r\n    // Bundle type constants\r\n    uint8 constant CORE_TEAM = 0;\r\n    uint8 constant ADVISORS = 1;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _token The address of the EOS Pizza (donation) contract.\r\n     */\r\n    function EosPizzaSliceSafe(address _token) public\r\n        TokenSafe(_token)\r\n    {\r\n        token = ERC20TokenInterface(_token);\r\n\r\n        /// Core team.\r\n        initBundle(CORE_TEAM,\r\n            TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE\r\n        );\r\n\r\n        // Accounts with tokens locked for the ? core team.\r\n        addLockedAccount(CORE_TEAM, 0x3ce215b2e4dC9D2ba0e2fC5099315E4Fa05d8AA2, 35 * (10**6) * DECIMALS_FACTOR);\r\n\r\n\r\n        // Verify that the tokens add up to the constant in the configuration.\r\n        assert(bundles[CORE_TEAM].lockedTokens == TOKENS_LOCKED_CORE_TEAM);\r\n\r\n        /// Advisors.\r\n        initBundle(ADVISORS,\r\n            TOKENS_LOCKED_ADVISORS_RELEASE_DATE\r\n        );\r\n\r\n        // Accounts with ? tokens locked for advisors.\r\n        addLockedAccount(ADVISORS, 0xC0e321E9305c21b72F5Ee752A9E8D9eCD0f2e2b1, 25 * (10**5) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0x55798CF234FEa760b0591537517C976FDb0c53Ba, 25 * (10**5) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0xbc732e73B94A5C4a8f60d0D98C4026dF21D500f5, 25 * (10**5) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0x088EEEe7C4c26041FBb4e83C10CB0784C81c86f9, 25 * (10**5) * DECIMALS_FACTOR);\r\n        addLockedAccount(ADVISORS, 0x52d640c9c417D9b7E3770d960946Dd5Bd2EB63db, 25 * (10**5) * DECIMALS_FACTOR);\r\n\r\n\r\n        // Verify that the tokens add up to the constant in the configuration.\r\n        assert(bundles[ADVISORS].lockedTokens == TOKENS_LOCKED_ADVISORS);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total locked tokens. This function is called by the donationraiser to determine number of tokens to create upon finalization.\r\n     *\r\n     * @return The current total number of locked EOS Pizza Slices.\r\n     */\r\n    function totalTokensLocked() public constant returns (uint) {\r\n        return bundles[CORE_TEAM].lockedTokens.plus(bundles[ADVISORS].lockedTokens);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows core team account ? tokens to be released.\r\n     */\r\n    function releaseCoreTeamAccount() public {\r\n        releaseAccount(CORE_TEAM, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows advisors account ? tokens to be released.\r\n     */\r\n    function releaseAdvisorsAccount() public {\r\n        releaseAccount(ADVISORS, msg.sender);\r\n    }\r\n}\r\n\r\n// File: contracts\\traits\\Whitelist.sol\r\n\r\ncontract Whitelist is HasOwner\r\n{\r\n    // Whitelist mapping\r\n    mapping(address => bool) public whitelist;\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     */\r\n    function Whitelist(address _owner) public\r\n        HasOwner(_owner)\r\n    {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Access control modifier that allows only whitelisted address to call the method.\r\n     */\r\n    modifier onlyWhitelisted {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that sets whitelist status in batch.\r\n     *\r\n     * @param _entries An array with the entries to be updated\r\n     * @param _status The new status to apply\r\n     */\r\n    function setWhitelistEntries(address[] _entries, bool _status) internal {\r\n        for (uint32 i = 0; i < _entries.length; ++i) {\r\n            whitelist[_entries[i]] = _status;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to whitelist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be whitelisted\r\n     */\r\n    function whitelistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Public function that allows the owner to blacklist multiple entries\r\n     *\r\n     * @param _entries An array with the entries to be blacklist\r\n     */\r\n    function blacklistAddresses(address[] _entries) public onlyOwner {\r\n        setWhitelistEntries(_entries, false);\r\n    }\r\n}\r\n\r\n// File: contracts\\EosPizzaSliceDonationraiser.sol\r\n\r\n/**\r\n * @title EosPizzaSliceDonationraiser\r\n *\r\n * @dev The EOS Pizza Slice donationraiser contract.\r\n */\r\ncontract EosPizzaSliceDonationraiser is EosPizzaSlice, EosPizzaSliceDonationraiserConfig, Whitelist {\r\n    // Indicates whether the donationraiser has ended or not.\r\n    bool public finalized = false;\r\n\r\n    // The address of the account which will receive the funds gathered by the donationraiser.\r\n    address public beneficiary;\r\n\r\n    // The number of ? participants will receive per 1 ETH.\r\n    uint public conversionRate;\r\n\r\n    // Donationraiser start date.\r\n    uint public startDate;\r\n\r\n    // Donationraiser end date.\r\n    uint public endDate;\r\n\r\n    // Donationraiser tokens hard cap.\r\n    uint public hardCap;\r\n\r\n    // The `EosPizzaSliceSafe` contract.\r\n    EosPizzaSliceSafe public eosPizzaSliceSafe;\r\n\r\n    // The minimum amount of ether allowed in the public sale\r\n    uint internal minimumContribution;\r\n\r\n    // The maximum amount of ether allowed per address\r\n    uint internal individualLimit;\r\n\r\n    // Number of tokens sold during the donationraiser.\r\n    uint private tokensSold;\r\n\r\n\r\n\r\n    /**\r\n     * @dev The event fires every time a new buyer enters the donationraiser.\r\n     *\r\n     * @param _address The address of the buyer.\r\n     * @param _ethers The number of ethers sent.\r\n     * @param _tokens The number of tokens received by the buyer.\r\n     * @param _newTotalSupply The updated total number of tokens currently in circulation.\r\n     * @param _conversionRate The conversion rate at which the tokens were bought.\r\n     */\r\n    event FundsReceived(address indexed _address, uint _ethers, uint _tokens, uint _newTotalSupply, uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the beneficiary of the donationraiser is changed.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    event BeneficiaryChange(address _beneficiary);\r\n\r\n    /**\r\n     * @dev The event fires when the number of ?EPS per 1 ETH is changed.\r\n     *\r\n     * @param _conversionRate The new number of ?EPS per 1 ETH.\r\n     */\r\n    event ConversionRateChange(uint _conversionRate);\r\n\r\n    /**\r\n     * @dev The event fires when the donationraiser is successfully finalized.\r\n     *\r\n     * @param _beneficiary The address of the beneficiary.\r\n     * @param _ethers The number of ethers transfered to the beneficiary.\r\n     * @param _totalSupply The total number of tokens in circulation.\r\n     */\r\n    event Finalized(address _beneficiary, uint _ethers, uint _totalSupply);\r\n\r\n    /**\r\n     * @dev The constructor.\r\n     *\r\n     * @param _beneficiary The address which will receive the funds gathered by the donationraiser.\r\n     */\r\n    function EosPizzaSliceDonationraiser(address _beneficiary) public\r\n        EosPizzaSlice(0)\r\n        Whitelist(msg.sender)\r\n    {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n        conversionRate = CONVERSION_RATE;\r\n        startDate = START_DATE;\r\n        endDate = END_DATE;\r\n        hardCap = TOKENS_HARD_CAP;\r\n        tokensSold = 0;\r\n        minimumContribution = MIN_CONTRIBUTION;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * CONVERSION_RATE;\r\n\r\n        eosPizzaSliceSafe = new EosPizzaSliceSafe(this);\r\n\r\n        // Freeze the transfers for the duration of the donationraiser. Removed this, you can immediately transfer your ?EPS to any ether address you like!\r\n        // freeze();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the beneficiary of the donationraiser.\r\n     *\r\n     * @param _beneficiary The address of the new beneficiary.\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        require(_beneficiary != 0);\r\n\r\n        beneficiary = _beneficiary;\r\n\r\n        BeneficiaryChange(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets converstion rate of 1 ETH to ?EPS. Can only be changed before the donationraiser starts.\r\n     *\r\n     * @param _conversionRate The new number of EOS Pizza Slices per 1 ETH.\r\n     */\r\n    function setConversionRate(uint _conversionRate) public onlyOwner {\r\n        require(now < startDate);\r\n        require(_conversionRate > 0);\r\n\r\n        conversionRate = _conversionRate;\r\n        individualLimit = INDIVIDUAL_ETHER_LIMIT * _conversionRate;\r\n\r\n        ConversionRateChange(_conversionRate);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev The default function which will fire every time someone sends ethers to this contract's address.\r\n     */\r\n    function() public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    /**\r\n     * @dev Creates new tokens based on the number of ethers sent and the conversion rate.\r\n     */\r\n    //function buyTokens() public payable onlyWhitelisted {\r\n    function buyTokens() public payable {\r\n        require(!finalized);\r\n        require(now >= startDate);\r\n        require(now <= endDate);\r\n        require(tx.gasprice <= MAX_GAS_PRICE);  // gas price limit\r\n        require(msg.value >= minimumContribution);  // required minimum contribution\r\n        require(tokensSold <= hardCap);\r\n\r\n        // Calculate the number of tokens the buyer will receive.\r\n        uint tokens = msg.value.mul(conversionRate);\r\n        balances[msg.sender] = balances[msg.sender].plus(tokens);\r\n\r\n        // Ensure that the individual contribution limit has not been reached\r\n        require(balances[msg.sender] <= individualLimit);\r\n\r\n\r\n\r\n        tokensSold = tokensSold.plus(tokens);\r\n        totalSupply = totalSupply.plus(tokens);\r\n\r\n        Transfer(0x0, msg.sender, tokens);\r\n\r\n        FundsReceived(\r\n            msg.sender,\r\n            msg.value,\r\n            tokens,\r\n            totalSupply,\r\n            conversionRate\r\n        );\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Finalize the donationraiser if `endDate` has passed or if `hardCap` is reached.\r\n     */\r\n    function finalize() public onlyOwner {\r\n        require((totalSupply >= hardCap) || (now >= endDate));\r\n        require(!finalized);\r\n\r\n        address contractAddress = this;\r\n        Finalized(beneficiary, contractAddress.balance, totalSupply);\r\n\r\n        /// Send the total number of ETH gathered to the beneficiary.\r\n        beneficiary.transfer(contractAddress.balance);\r\n\r\n        /// Allocate locked tokens to the `EosPizzaSliceSafe` contract.\r\n        uint totalTokensLocked = eosPizzaSliceSafe.totalTokensLocked();\r\n        balances[address(eosPizzaSliceSafe)] = balances[address(eosPizzaSliceSafe)].plus(totalTokensLocked);\r\n        totalSupply = totalSupply.plus(totalTokensLocked);\r\n\r\n        // Transfer the funds for the bounty program.\r\n        balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);\r\n        totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);\r\n\r\n        /// Finalize the donationraiser. Keep in mind that this cannot be undone.\r\n        finalized = true;\r\n\r\n        // Unfreeze transfers\r\n        unfreeze();\r\n    }\r\n\r\n    /**\r\n     * @dev allow owner to collect balance of contract during donation period\r\n     */\r\n\r\n    function collect() public onlyOwner {\r\n\r\n        address contractAddress = this;\r\n        /// Send the total number of ETH gathered to the beneficiary.\r\n        beneficiary.transfer(contractAddress.balance);\r\n\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"whitelistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eosPizzaSliceSafe\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entries\",\"type\":\"address[]\"}],\"name\":\"blacklistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"setConversionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newTotalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"FundsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"}],\"name\":\"ConversionRateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "EosPizzaSliceDonationraiser", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000021dba5e12eb593c55bd3894a91634ac3895581b", "Library": "", "SwarmSource": "bzzr://1ec5fbf198085e3ef4939f7f51d67702b24d537d1ae1b5f79321b572535d197a"}]}