{"status": "1", "message": "OK", "result": [{"SourceCode": "contract AbstractDaoChallenge {\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool);\r\n\tfunction tokenPrice() returns (uint256);\r\n}\r\n\r\ncontract DaoAccount\r\n{\r\n\t/**************************\r\n\t\t\t    Constants\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\t// No events\r\n\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n\taddress public daoChallenge; // the DaoChallenge this account belongs to\r\n\r\n\t// Owner of the challenge with backdoor access.\r\n  // Remove for a real DAO contract:\r\n  address public challengeOwner;\r\n\r\n\t/**************************\r\n\t     Private variables\r\n\t***************************/\r\n\r\n\tuint256 tokenBalance; // number of tokens in this account\r\n  address owner;        // owner of the tokens\r\n\r\n\t/**************************\r\n\t\t\t     Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyOwner() {if (owner != msg.sender) throw; _}\r\n\r\n\tmodifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n  function DaoAccount (address _owner, address _challengeOwner) noEther {\r\n    owner = _owner;\r\n    daoChallenge = msg.sender;\r\n\t\ttokenBalance = 0;\r\n\r\n    // Remove for a real DAO contract:\r\n    challengeOwner = _challengeOwner;\r\n\t}\r\n\r\n\tfunction () {\r\n\t\tthrow;\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\t/**************************\r\n\t\t\t Public functions\r\n\t***************************/\r\n\r\n\tfunction getOwnerAddress() constant returns (address ownerAddress) {\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction getTokenBalance() constant returns (uint256 tokens) {\r\n\t\treturn tokenBalance;\r\n\t}\r\n\r\n\tfunction buyTokens() onlyDaoChallenge returns (uint256 tokens) {\r\n\t\tuint256 amount = msg.value;\r\n\t\tuint256 tokenPrice = AbstractDaoChallenge(daoChallenge).tokenPrice();\r\n\r\n\t\t// No free tokens:\r\n\t\tif (amount == 0) throw;\r\n\r\n\t\t// No fractional tokens:\r\n\t\tif (amount % tokenPrice != 0) throw;\r\n\r\n\t\ttokens = amount / tokenPrice;\r\n\r\n\t\ttokenBalance += tokens;\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\tfunction transfer(uint256 tokens, DaoAccount recipient) noEther onlyDaoChallenge {\r\n\t\tif (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\r\n\t\tif (tokenBalance - tokens > tokenBalance) throw; // Overflow\r\n\t\ttokenBalance -= tokens;\r\n\t\trecipient.receiveTokens(tokens);\r\n\t}\r\n\r\n\tfunction receiveTokens(uint256 tokens) {\r\n\t\t// Check that the sender is a DaoAccount and belongs to our DaoChallenge\r\n\t\tDaoAccount sender = DaoAccount(msg.sender);\r\n\t\tif (!AbstractDaoChallenge(daoChallenge).isMember(sender, sender.getOwnerAddress())) throw;\r\n\r\n\t\tif (tokens > sender.getTokenBalance()) throw;\r\n\r\n\t\t// Protect against overflow:\r\n\t\tif (tokenBalance + tokens < tokenBalance) throw;\r\n\r\n\t\ttokenBalance += tokens;\r\n\t}\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}\r\n\r\ncontract DaoChallenge\r\n{\r\n\t/**************************\r\n\t\t\t\t\tConstants\r\n\t***************************/\r\n\r\n\r\n\t/**************************\r\n\t\t\t\t\tEvents\r\n\t***************************/\r\n\r\n\tevent notifyTerminate(uint256 finalBalance);\r\n\tevent notifyTokenIssued(uint256 n, uint256 price, uint deadline);\r\n\r\n\tevent notifyNewAccount(address owner, address account);\r\n\tevent notifyBuyToken(address owner, uint256 tokens, uint256 price);\r\n\tevent notifyTransfer(address owner, address recipient, uint256 tokens);\r\n\r\n\t/**************************\r\n\t     Public variables\r\n\t***************************/\r\n\r\n\t// For the current token issue:\r\n\tuint public tokenIssueDeadline = now;\r\n\tuint256 public tokensIssued = 0;\r\n\tuint256 public tokensToIssue = 0;\r\n\tuint256 public tokenPrice = 1000000000000000; // 1 finney\r\n\r\n\tmapping (address => DaoAccount) public daoAccounts;\r\n\r\n\t/**************************\r\n\t\t\t Private variables\r\n\t***************************/\r\n\r\n\t// Owner of the challenge; a real DAO doesn't an owner.\r\n\taddress challengeOwner;\r\n\r\n\t/**************************\r\n\t\t\t\t\t Modifiers\r\n\t***************************/\r\n\r\n\tmodifier noEther() {if (msg.value > 0) throw; _}\r\n\r\n\tmodifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\r\n\r\n\t/**************************\r\n\t Constructor and fallback\r\n\t**************************/\r\n\r\n\tfunction DaoChallenge () {\r\n\t\tchallengeOwner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\r\n\t}\r\n\r\n\tfunction () noEther {\r\n\t}\r\n\r\n\t/**************************\r\n\t     Private functions\r\n\t***************************/\r\n\r\n\tfunction accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\r\n\t\tDaoAccount account = daoAccounts[accountOwner];\r\n\r\n\t\tif(account == DaoAccount(0x00) && createNew) {\r\n\t\t\taccount = new DaoAccount(accountOwner, challengeOwner);\r\n\t\t\tdaoAccounts[accountOwner] = account;\r\n\t\t\tnotifyNewAccount(accountOwner, address(account));\r\n\t\t}\r\n\r\n\t\treturn account;\r\n\t}\r\n\r\n\t/**************************\r\n\t     Public functions\r\n\t***************************/\r\n\r\n\tfunction createAccount () {\r\n\t\taccountFor(msg.sender, true);\r\n\t}\r\n\r\n\t// Check if a given account belongs to this DaoChallenge.\r\n\tfunction isMember (DaoAccount account, address allegedOwnerAddress) returns (bool) {\r\n\t\tif (account == DaoAccount(0x00)) return false;\r\n\t\tif (allegedOwnerAddress == 0x00) return false;\r\n\t\tif (daoAccounts[allegedOwnerAddress] == DaoAccount(0x00)) return false;\r\n\t\t// allegedOwnerAddress is passed in for performance reasons, but not trusted\r\n\t\tif (daoAccounts[allegedOwnerAddress] != account) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getTokenBalance () constant noEther returns (uint256 tokens) {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) return 0;\r\n\t\treturn account.getTokenBalance();\r\n\t}\r\n\r\n\t// n: max number of tokens to be issued\r\n\t// price: in szabo, e.g. 1 finney = 1,000 szabo = 0.001 ether\r\n\t// deadline: unix timestamp in seconds\r\n\tfunction issueTokens (uint256 n, uint256 price, uint deadline) noEther onlyChallengeOwner {\r\n\t\t// Only allow one issuing at a time:\r\n\t\tif (now < tokenIssueDeadline) throw;\r\n\r\n\t\t// Deadline can't be in the past:\r\n\t\tif (deadline < now) throw;\r\n\r\n\t\t// Issue at least 1 token\r\n\t\tif (n == 0) throw;\r\n\r\n\t\ttokenPrice = price * 1000000000000;\r\n\t\ttokenIssueDeadline = deadline;\r\n\t\ttokensToIssue = n;\r\n\t\ttokensIssued = 0;\r\n\r\n\t\tnotifyTokenIssued(n, price, deadline);\r\n\t}\r\n\r\n\tfunction buyTokens () returns (uint256 tokens) {\r\n\t\ttokens = msg.value / tokenPrice;\r\n\r\n\t\tif (now > tokenIssueDeadline) throw;\r\n\t\tif (tokensIssued >= tokensToIssue) throw;\r\n\r\n\t\t// This hopefully prevents issuing too many tokens\r\n\t\t// if there's a race condition:\r\n\t\ttokensIssued += tokens;\r\n\t\tif (tokensIssued > tokensToIssue) throw;\r\n\r\n\t  DaoAccount account = accountFor(msg.sender, true);\r\n\t\tif (account.buyTokens.value(msg.value)() != tokens) throw;\r\n\r\n\t\tnotifyBuyToken(msg.sender, tokens, msg.value);\r\n\t\treturn tokens;\r\n \t}\r\n\r\n\tfunction transfer(uint256 tokens, address recipient) noEther {\r\n\t\tDaoAccount account = accountFor(msg.sender, false);\r\n\t\tif (account == DaoAccount(0x00)) throw;\r\n\r\n\t\tDaoAccount recipientAcc = accountFor(recipient, false);\r\n\t\tif (recipientAcc == DaoAccount(0x00)) throw;\r\n\r\n\t\taccount.transfer(tokens, recipientAcc);\r\n\t\tnotifyTransfer(msg.sender, recipient, tokens);\r\n\t}\r\n\r\n\t// The owner of the challenge can terminate it. Don't use this in a real DAO.\r\n\tfunction terminate() noEther onlyChallengeOwner {\r\n\t\tnotifyTerminate(this.balance);\r\n\t\tsuicide(challengeOwner);\r\n\t}\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"terminate\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenIssueDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"allegedOwnerAddress\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensIssued\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createAccount\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"daoAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensToIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"finalBalance\",\"type\":\"uint256\"}],\"name\":\"notifyTerminate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"n\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"notifyTokenIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"notifyNewAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"notifyBuyToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"notifyTransfer\",\"type\":\"event\"}]", "ContractName": "DaoChallenge", "CompilerVersion": "v0.3.5-2016-07-01-48238c9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}