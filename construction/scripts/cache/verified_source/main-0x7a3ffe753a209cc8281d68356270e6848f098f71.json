{"status": "1", "message": "OK", "result": [{"SourceCode": "//! By Parity Technologies, 2017.\r\n//! Released under the Apache Licence 2.\r\n\r\npragma solidity ^0.4.15;\r\n\r\n// ECR20 standard token interface\r\ncontract Token {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\tfunction approve(address _spender, uint256 _value) returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n// Owner-specific contract interface\r\ncontract Owned {\r\n\tevent NewOwner(address indexed old, address indexed current);\r\n\r\n\tmodifier only_owner {\r\n\t\trequire (msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\taddress public owner = msg.sender;\r\n\r\n\tfunction setOwner(address _new) only_owner {\r\n\t\tNewOwner(owner, _new);\r\n\t\towner = _new;\r\n\t}\r\n}\r\n\r\n/// Stripped down certifier interface.\r\ncontract Certifier {\r\n\tfunction certified(address _who) constant returns (bool);\r\n}\r\n\r\n// BasicCoin, ECR20 tokens that all belong to the owner for sending around\r\ncontract AmberToken is Token, Owned {\r\n\tstruct Account {\r\n\t\t// Balance is always less than or equal totalSupply since totalSupply is increased straight away of when releasing locked tokens.\r\n\t\tuint balance;\r\n\t\tmapping (address => uint) allowanceOf;\r\n\r\n\t\t// TokensPerPhase is always less than or equal to totalSupply since anything added to it is UNLOCK_PHASES times lower than added to totalSupply.\r\n\t\tuint tokensPerPhase;\r\n\t\tuint nextPhase;\r\n\t}\r\n\r\n\tevent Minted(address indexed who, uint value);\r\n\tevent MintedLocked(address indexed who, uint value);\r\n\r\n\tfunction AmberToken() {}\r\n\r\n\t// Mint a certain number of tokens.\r\n\t// _value has to be bounded not to overflow.\r\n\tfunction mint(address _who, uint _value)\r\n\t\tonly_owner\r\n\t\tpublic\r\n\t{\r\n\t\taccounts[_who].balance += _value;\r\n\t\ttotalSupply += _value;\r\n\t\tMinted(_who, _value);\r\n\t}\r\n\r\n\t// Mint a certain number of tokens that are locked up.\r\n\t// _value has to be bounded not to overflow.\r\n\tfunction mintLocked(address _who, uint _value)\r\n\t\tonly_owner\r\n\t\tpublic\r\n\t{\r\n\t\taccounts[_who].tokensPerPhase += _value / UNLOCK_PHASES;\r\n\t\ttotalSupply += _value;\r\n\t\tMintedLocked(_who, _value);\r\n\t}\r\n\r\n\t/// Finalise any minting operations. Resets the owner and causes normal tokens\r\n\t/// to be liquid. Also begins the countdown for locked-up tokens.\r\n\tfunction finalise()\r\n\t\tonly_owner\r\n\t\tpublic\r\n\t{\r\n\t\tlocked = false;\r\n\t\towner = 0;\r\n\t\tphaseStart = now;\r\n\t}\r\n\r\n\t/// Return the current unlock-phase. Won't work until after the contract\r\n\t/// has `finalise()` called.\r\n\tfunction currentPhase()\r\n\t\tpublic\r\n\t\tconstant\r\n\t\treturns (uint)\r\n\t{\r\n\t\trequire (phaseStart > 0);\r\n\t\tuint p = (now - phaseStart) / PHASE_DURATION;\r\n\t\treturn p > UNLOCK_PHASES ? UNLOCK_PHASES : p;\r\n\t}\r\n\r\n\t/// Unlock any now freeable tokens that are locked up for account `_who`.\r\n\tfunction unlockTokens(address _who)\r\n\t\tpublic\r\n\t{\r\n\t\tuint phase = currentPhase();\r\n\t\tuint tokens = accounts[_who].tokensPerPhase;\r\n\t\tuint nextPhase = accounts[_who].nextPhase;\r\n\t\tif (tokens > 0 && phase > nextPhase) {\r\n\t\t\taccounts[_who].balance += tokens * (phase - nextPhase);\r\n\t\t\taccounts[_who].nextPhase = phase;\r\n\t\t}\r\n\t}\r\n\r\n\t// Transfer tokens between accounts.\r\n\tfunction transfer(address _to, uint256 _value)\r\n\t\twhen_owns(msg.sender, _value)\r\n\t\twhen_liquid\r\n\t\treturns (bool)\r\n\t{\r\n\t\tTransfer(msg.sender, _to, _value);\r\n\t\taccounts[msg.sender].balance -= _value;\r\n\t\taccounts[_to].balance += _value;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Transfer via allowance.\r\n\tfunction transferFrom(address _from, address _to, uint256 _value)\r\n\t\twhen_owns(_from, _value)\r\n\t\twhen_has_allowance(_from, msg.sender, _value)\r\n\t\twhen_liquid\r\n\t\treturns (bool)\r\n\t{\r\n\t\tTransfer(_from, _to, _value);\r\n\t\taccounts[_from].allowanceOf[msg.sender] -= _value;\r\n\t\taccounts[_from].balance -= _value;\r\n\t\taccounts[_to].balance += _value;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Approve allowances\r\n\tfunction approve(address _spender, uint256 _value)\r\n\t\twhen_liquid\r\n\t\treturns (bool)\r\n\t{\r\n\t\t// Mitigate the race condition described here:\r\n\t\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t\trequire (_value == 0 || accounts[msg.sender].allowanceOf[_spender] == 0);\r\n\t\tApproval(msg.sender, _spender, _value);\r\n\t\taccounts[msg.sender].allowanceOf[_spender] = _value;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Get the balance of a specific address.\r\n\tfunction balanceOf(address _who) constant returns (uint256) {\r\n\t\treturn accounts[_who].balance;\r\n\t}\r\n\r\n\t// Available allowance\r\n\tfunction allowance(address _owner, address _spender)\r\n\t\tconstant\r\n\t\treturns (uint256)\r\n\t{\r\n\t\treturn accounts[_owner].allowanceOf[_spender];\r\n\t}\r\n\r\n\t// The balance should be available\r\n\tmodifier when_owns(address _owner, uint _amount) {\r\n\t\trequire (accounts[_owner].balance >= _amount);\r\n\t\t_;\r\n\t}\r\n\r\n\t// An allowance should be available\r\n\tmodifier when_has_allowance(address _owner, address _spender, uint _amount) {\r\n\t\trequire (accounts[_owner].allowanceOf[_spender] >= _amount);\r\n\t\t_;\r\n\t}\r\n\r\n\t// Tokens must not be locked.\r\n\tmodifier when_liquid {\r\n\t\trequire (!locked);\r\n\t\t_;\r\n\t}\r\n\r\n\t/// Usual token descriptors.\r\n\tstring constant public name = \"Amber Token\";\r\n\tuint8 constant public decimals = 18;\r\n\tstring constant public symbol = \"AMB\";\r\n\r\n\t// Are the tokens non-transferrable?\r\n\tbool public locked = true;\r\n\r\n\t// Phase information for slow-release tokens.\r\n\tuint public phaseStart = 0;\r\n\tuint public constant PHASE_DURATION = 180 days;\r\n\tuint public constant UNLOCK_PHASES = 4;\r\n\r\n\t// available token supply\r\n\tuint public totalSupply;\r\n\r\n\t// storage and mapping of all balances & allowances\r\n\tmapping (address => Account) accounts;\r\n}\r\n\r\n/// Will accept Ether \"contributions\" and record each both as a log and in a\r\n/// queryable record.\r\ncontract AmbrosusSale {\r\n\t/// Constructor.\r\n\tfunction AmbrosusSale() {\r\n\t\ttokens = new AmberToken();\r\n\t}\r\n\r\n\t// Can only be called by the administrator.\r\n\tmodifier only_admin { require (msg.sender == ADMINISTRATOR); _; }\r\n\t// Can only be called by the prepurchaser.\r\n\tmodifier only_prepurchaser { require (msg.sender == PREPURCHASER); _; }\r\n\r\n\t// The transaction params are valid for buying in.\r\n\tmodifier is_valid_buyin { require (tx.gasprice <= MAX_BUYIN_GAS_PRICE && msg.value >= MIN_BUYIN_VALUE); _; }\r\n\t// Requires the hard cap to be respected given the desired amount for `buyin`.\r\n\tmodifier is_under_cap_with(uint buyin) { require (buyin + saleRevenue <= MAX_REVENUE); _; }\r\n\t// Requires sender to be certified.\r\n\tmodifier only_certified(address who) { require (CERTIFIER.certified(who)); _; }\r\n\r\n\t/*\r\n\t\tSale life cycle:\r\n\t\t1. Not yet started.\r\n\t\t2. Started, further purchases possible.\r\n\t\t\ta. Normal operation (next step can be 2b or 3)\r\n\t\t\tb. Paused (next step can be 2a or 3)\r\n\t\t3. Complete (equivalent to Allocation Lifecycle 2 & 3).\r\n\t*/\r\n\r\n\t// Can only be called by prior to the period (1).\r\n\tmodifier only_before_period { require (now < BEGIN_TIME); _; }\r\n\t// Can only be called during the period when not paused (2a).\r\n\tmodifier only_during_period { require (now >= BEGIN_TIME && now < END_TIME && !isPaused); _; }\r\n\t// Can only be called during the period when paused (2b)\r\n\tmodifier only_during_paused_period { require (now >= BEGIN_TIME && now < END_TIME && isPaused); _; }\r\n\t// Can only be called after the period (3).\r\n\tmodifier only_after_sale { require (now >= END_TIME || saleRevenue >= MAX_REVENUE); _; }\r\n\r\n\t/*\r\n\t\tAllocation life cycle:\r\n\t\t1. Uninitialised (sale not yet started/ended, equivalent to Sale Lifecycle 1 & 2).\r\n\t\t2. Initialised, not yet completed (further allocations possible).\r\n\t\t3. Completed (no further allocations possible).\r\n\t*/\r\n\r\n\t// Only when allocations have not yet been initialised (1).\r\n\tmodifier when_allocations_uninitialised { require (!allocationsInitialised); _; }\r\n\t// Only when sufficient allocations remain for making this liquid allocation (2).\r\n\tmodifier when_allocatable_liquid(uint amount) { require (liquidAllocatable >= amount); _; }\r\n\t// Only when sufficient allocations remain for making this locked allocation (2).\r\n\tmodifier when_allocatable_locked(uint amount) { require (lockedAllocatable >= amount); _; }\r\n\t// Only when no further allocations are possible (3).\r\n\tmodifier when_allocations_complete { require (allocationsInitialised && liquidAllocatable == 0 && lockedAllocatable == 0); _; }\r\n\r\n\t/// Note a pre-ICO sale.\r\n\tevent Prepurchased(address indexed recipient, uint etherPaid, uint amberSold);\r\n\t/// Some contribution `amount` received from `recipient`.\r\n\tevent Purchased(address indexed recipient, uint amount);\r\n\t/// Some contribution `amount` received from `recipient`.\r\n\tevent SpecialPurchased(address indexed recipient, uint etherPaid, uint amberSold);\r\n\t/// Period paused abnormally.\r\n\tevent Paused();\r\n\t/// Period restarted after abnormal halt.\r\n\tevent Unpaused();\r\n\t/// Some contribution `amount` received from `recipient`.\r\n\tevent Allocated(address indexed recipient, uint amount, bool liquid);\r\n\r\n\t/// Note a prepurchase that has already happened.\r\n\t/// Up to owner to ensure that values do not overflow.\r\n\t///\r\n\t/// Preconditions: !sale_started\r\n\t/// Writes {Tokens, Sale}\r\n\tfunction notePrepurchase(address _who, uint _etherPaid, uint _amberSold)\r\n\t\tonly_prepurchaser\r\n\t\tonly_before_period\r\n\t\tpublic\r\n\t{\r\n\t\t// Admin ensures bounded value.\r\n\t\ttokens.mint(_who, _amberSold);\r\n\t\tsaleRevenue += _etherPaid;\r\n\t\ttotalSold += _amberSold;\r\n\t\tPrepurchased(_who, _etherPaid, _amberSold);\r\n\t}\r\n\r\n\t/// Make a purchase from a privileged account. No KYC is required and a\r\n\t/// preferential buyin rate may be given.\r\n\t///\r\n\t/// Preconditions: !paused, sale_ongoing\r\n\t/// Postconditions: !paused, ?!sale_ongoing\r\n\t/// Writes {Tokens, Sale}\r\n\tfunction specialPurchase()\r\n\t\tonly_before_period\r\n\t\tis_under_cap_with(msg.value)\r\n\t\tpayable\r\n\t\tpublic\r\n\t{\r\n\t\tuint256 bought = buyinReturn(msg.sender) * msg.value;\r\n\t\trequire (bought > 0);   // be kind and don't punish the idiots.\r\n\r\n\t\t// Bounded value, see STANDARD_BUYIN.\r\n\t\ttokens.mint(msg.sender, bought);\r\n\t\tTREASURY.transfer(msg.value);\r\n\t\tsaleRevenue += msg.value;\r\n\t\ttotalSold += bought;\r\n\t\tSpecialPurchased(msg.sender, msg.value, bought);\r\n   }\r\n\r\n\t/// Let sender make a purchase to their account.\r\n\t///\r\n\t/// Preconditions: !paused, sale_ongoing\r\n\t/// Postconditions: ?!sale_ongoing\r\n\t/// Writes {Tokens, Sale}\r\n\tfunction ()\r\n\t\tonly_certified(msg.sender)\r\n\t\tpayable\r\n\t\tpublic\r\n\t{\r\n\t\tprocessPurchase(msg.sender);\r\n\t}\r\n\r\n\t/// Let sender make a standard purchase; AMB goes into another account.\r\n\t///\r\n\t/// Preconditions: !paused, sale_ongoing\r\n\t/// Postconditions: ?!sale_ongoing\r\n\t/// Writes {Tokens, Sale}\r\n\tfunction purchaseTo(address _recipient)\r\n\t\tonly_certified(msg.sender)\r\n\t\tpayable\r\n\t\tpublic\r\n\t{\r\n\t\tprocessPurchase(_recipient);\r\n\t}\r\n\r\n\t/// Receive a contribution from `_recipient`.\r\n\t///\r\n\t/// Preconditions: !paused, sale_ongoing\r\n\t/// Postconditions: ?!sale_ongoing\r\n\t/// Writes {Tokens, Sale}\r\n\tfunction processPurchase(address _recipient)\r\n\t\tonly_during_period\r\n\t\tis_valid_buyin\r\n\t\tis_under_cap_with(msg.value)\r\n\t\tprivate\r\n\t{\r\n\t\t// Bounded value, see STANDARD_BUYIN.\r\n\t\ttokens.mint(_recipient, msg.value * STANDARD_BUYIN);\r\n\t\tTREASURY.transfer(msg.value);\r\n\t\tsaleRevenue += msg.value;\r\n\t\ttotalSold += msg.value * STANDARD_BUYIN;\r\n\t\tPurchased(_recipient, msg.value);\r\n\t}\r\n\r\n\t/// Determine purchase price for a given address.\r\n\tfunction buyinReturn(address _who)\r\n\t\tconstant\r\n\t\tpublic\r\n\t\treturns (uint)\r\n\t{\r\n\t\t// Chinese exchanges.\r\n\t\tif (\r\n\t\t\t_who == CHINESE_EXCHANGE_1 || _who == CHINESE_EXCHANGE_2 ||\r\n\t\t\t_who == CHINESE_EXCHANGE_3 || _who == CHINESE_EXCHANGE_4\r\n\t\t)\r\n\t\t\treturn CHINESE_EXCHANGE_BUYIN;\r\n\r\n\t\t// BTCSuisse tier 1\r\n\t\tif (_who == BTC_SUISSE_TIER_1)\r\n\t\t\treturn STANDARD_BUYIN;\r\n\t\t// BTCSuisse tier 2\r\n\t\tif (_who == BTC_SUISSE_TIER_2)\r\n\t\t\treturn TIER_2_BUYIN;\r\n\t\t// BTCSuisse tier 3\r\n\t\tif (_who == BTC_SUISSE_TIER_3)\r\n\t\t\treturn TIER_3_BUYIN;\r\n\t\t// BTCSuisse tier 4\r\n\t\tif (_who == BTC_SUISSE_TIER_4)\r\n\t\t\treturn TIER_4_BUYIN;\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/// Halt the contribution period. Any attempt at contributing will fail.\r\n\t///\r\n\t/// Preconditions: !paused, sale_ongoing\r\n\t/// Postconditions: paused\r\n\t/// Writes {Paused}\r\n\tfunction pause()\r\n\t\tonly_admin\r\n\t\tonly_during_period\r\n\t\tpublic\r\n\t{\r\n\t\tisPaused = true;\r\n\t\tPaused();\r\n\t}\r\n\r\n\t/// Unhalt the contribution period.\r\n\t///\r\n\t/// Preconditions: paused\r\n\t/// Postconditions: !paused\r\n\t/// Writes {Paused}\r\n\tfunction unpause()\r\n\t\tonly_admin\r\n\t\tonly_during_paused_period\r\n\t\tpublic\r\n\t{\r\n\t\tisPaused = false;\r\n\t\tUnpaused();\r\n\t}\r\n\r\n\t/// Called once by anybody after the sale ends.\r\n\t/// Initialises the specific values (i.e. absolute token quantities) of the\r\n\t/// allowed liquid/locked allocations.\r\n\t///\r\n\t/// Preconditions: !allocations_initialised\r\n\t/// Postconditions: allocations_initialised, !allocations_complete\r\n\t/// Writes {Allocations}\r\n\tfunction initialiseAllocations()\r\n\t\tpublic\r\n\t\tonly_after_sale\r\n\t\twhen_allocations_uninitialised\r\n\t{\r\n\t\tallocationsInitialised = true;\r\n\t\tliquidAllocatable = LIQUID_ALLOCATION_PPM * totalSold / SALES_ALLOCATION_PPM;\r\n\t\tlockedAllocatable = LOCKED_ALLOCATION_PPM * totalSold / SALES_ALLOCATION_PPM;\r\n\t}\r\n\r\n\t/// Preallocate a liquid portion of tokens.\r\n\t/// Admin may call this to allocate a share of the liquid tokens.\r\n\t/// Up to admin to ensure that value does not overflow.\r\n\t///\r\n\t/// Preconditions: allocations_initialised\r\n\t/// Postconditions: ?allocations_complete\r\n\t/// Writes {Allocations, Tokens}\r\n\tfunction allocateLiquid(address _who, uint _value)\r\n\t\tonly_admin\r\n\t\twhen_allocatable_liquid(_value)\r\n\t\tpublic\r\n\t{\r\n\t\t// Admin ensures bounded value.\r\n\t\ttokens.mint(_who, _value);\r\n\t\tliquidAllocatable -= _value;\r\n\t\tAllocated(_who, _value, true);\r\n\t}\r\n\r\n\t/// Preallocate a locked-up portion of tokens.\r\n\t/// Admin may call this to allocate a share of the locked tokens.\r\n\t/// Up to admin to ensure that value does not overflow and _value is divisible by UNLOCK_PHASES.\r\n\t///\r\n\t/// Preconditions: allocations_initialised\r\n\t/// Postconditions: ?allocations_complete\r\n\t/// Writes {Allocations, Tokens}\r\n\tfunction allocateLocked(address _who, uint _value)\r\n\t\tonly_admin\r\n\t\twhen_allocatable_locked(_value)\r\n\t\tpublic\r\n\t{\r\n\t\t// Admin ensures bounded value.\r\n\t\ttokens.mintLocked(_who, _value);\r\n\t\tlockedAllocatable -= _value;\r\n\t\tAllocated(_who, _value, false);\r\n\t}\r\n\r\n\t/// End of the sale and token allocation; retire this contract.\r\n\t/// Once called, no more tokens can be minted, basic tokens are now liquid.\r\n\t/// Anyone can call, but only once this contract can properly be retired.\r\n\t///\r\n\t/// Preconditions: allocations_complete\r\n\t/// Postconditions: liquid_tokens_transferable, this_is_dead\r\n\t/// Writes {Tokens}\r\n\tfunction finalise()\r\n\t\twhen_allocations_complete\r\n\t\tpublic\r\n\t{\r\n\t\ttokens.finalise();\r\n\t}\r\n\r\n\t//////\r\n\t// STATE\r\n\t//////\r\n\r\n\t// How much is enough?\r\n\tuint public constant MIN_BUYIN_VALUE = 1;\r\n\t// Max gas price for buyins.\r\n\tuint public constant MAX_BUYIN_GAS_PRICE = 25000000000;\r\n\t// The exposed hard cap.\r\n\tuint public constant MAX_REVENUE = 328103 ether;\r\n\r\n\t// The total share of tokens, expressed in PPM, allocated to pre-ICO and ICO.\r\n\tuint constant public SALES_ALLOCATION_PPM = 400000;\r\n\t// The total share of tokens, expressed in PPM, the admin may later allocate, as locked tokens.\r\n\tuint constant public LOCKED_ALLOCATION_PPM = 337000;\r\n\t// The total share of tokens, expressed in PPM, the admin may later allocate, as liquid tokens.\r\n\tuint constant public LIQUID_ALLOCATION_PPM = 263000;\r\n\r\n\t/// The certifier resource. TODO: set address\r\n\tCertifier public constant CERTIFIER = Certifier(0x1e2F058C43ac8965938F6e9CA286685A3E63F24E);\r\n\t// Who can halt/unhalt/kill?\r\n\taddress public constant ADMINISTRATOR = 0x11bF17B890a80080A8F9C1673D2951296a6F3D91;\r\n\t// Who can prepurchase?\r\n\taddress public constant PREPURCHASER = 0x00C269e9D02188E39C9922386De631c6AED5b4d4;\r\n\t// Who gets the stash? Should not release funds during minting process.\r\n\taddress public constant TREASURY = 0xB47aD434C6e401473F1d3442001Ac69cda1dcFDd;\r\n\t// When does the contribution period begin?\r\n\tuint public constant BEGIN_TIME = 1506168000;\r\n\t// How long does the sale last for?\r\n\tuint public constant DURATION = 30 days;\r\n\t// When does the period end?\r\n\tuint public constant END_TIME = BEGIN_TIME + DURATION;\r\n\r\n\t// The privileged buyin accounts.\r\n\taddress public constant BTC_SUISSE_TIER_1 = 0x53B3D4f98fcb6f0920096fe1cCCa0E4327Da7a1D;\r\n\taddress public constant BTC_SUISSE_TIER_2 = 0x642fDd12b1Dd27b9E19758F0AefC072dae7Ab996;\r\n\taddress public constant BTC_SUISSE_TIER_3 = 0x64175446A1e3459c3E9D650ec26420BA90060d28;\r\n\taddress public constant BTC_SUISSE_TIER_4 = 0xB17C2f9a057a2640309e41358a22Cf00f8B51626;\r\n\taddress public constant CHINESE_EXCHANGE_1 = 0x36f548fAB37Fcd39cA8725B8fA214fcd784FE0A3;\r\n\taddress public constant CHINESE_EXCHANGE_2 = 0x877Da872D223AB3D073Ab6f9B4bb27540E387C5F;\r\n\taddress public constant CHINESE_EXCHANGE_3 = 0xCcC088ec38A4dbc15Ba269A176883F6ba302eD8d;\r\n\t// TODO: set address\r\n\taddress public constant CHINESE_EXCHANGE_4 = 0;\r\n\r\n\t// Tokens per eth for the various buy-in rates.\r\n\t// 1e8 ETH in existence, means at most 1.5e11 issued.\r\n\tuint public constant STANDARD_BUYIN = 1000;\r\n\tuint public constant TIER_2_BUYIN = 1111;\r\n\tuint public constant TIER_3_BUYIN = 1250;\r\n\tuint public constant TIER_4_BUYIN = 1429;\r\n\tuint public constant CHINESE_EXCHANGE_BUYIN = 1087;\r\n\r\n\t//////\r\n\t// State Subset: Allocations\r\n\t//\r\n\t// Invariants:\r\n\t// !allocationsInitialised ||\r\n\t//   (liquidAllocatable + tokens.liquidAllocated) / LIQUID_ALLOCATION_PPM == totalSold / SALES_ALLOCATION_PPM &&\r\n\t//   (lockedAllocatable + tokens.lockedAllocated) / LOCKED_ALLOCATION_PPM == totalSold / SALES_ALLOCATION_PPM\r\n\t//\r\n\t// when_allocations_complete || (now < END_TIME && saleRevenue < MAX_REVENUE)\r\n\r\n\t// Have post-sale token allocations been initialised?\r\n\tbool public allocationsInitialised = false;\r\n\t// How many liquid tokens may yet be allocated?\r\n\tuint public liquidAllocatable;\r\n\t// How many locked tokens may yet be allocated?\r\n\tuint public lockedAllocatable;\r\n\r\n\t//////\r\n\t// State Subset: Sale\r\n\t//\r\n\t// Invariants:\r\n\t// saleRevenue <= MAX_REVENUE\r\n\r\n\t// Total amount raised in both presale and sale, in Wei.\r\n\t// Assuming TREASURY locks funds, so can not exceed total amount of Ether 1e8.\r\n\tuint public saleRevenue = 0;\r\n\t// Total amount minted in both presale and sale, in AMB * 10^-18.\r\n\t// Assuming the TREASURY locks funds, msg.value * STANDARD_BUYIN will be less than 1.5e11.\r\n\tuint public totalSold = 0;\r\n\r\n\t//////\r\n\t// State Subset: Tokens\r\n\r\n\t// The contract which gets called whenever anything is received.\r\n\tAmberToken public tokens;\r\n\r\n\t//////\r\n\t// State Subset: Pause\r\n\r\n\t// Are contributions abnormally paused?\r\n\tbool public isPaused = false;\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"TIER_3_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHINESE_EXCHANGE_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BUYIN_VALUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TREASURY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHINESE_EXCHANGE_3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"allocateLiquid\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTC_SUISSE_TIER_4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER_2_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_etherPaid\",\"type\":\"uint256\"},{\"name\":\"_amberSold\",\"type\":\"uint256\"}],\"name\":\"notePrepurchase\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMINISTRATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"buyinReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REVENUE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUID_ALLOCATION_PPM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALES_ALLOCATION_PPM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOCKED_ALLOCATION_PPM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHINESE_EXCHANGE_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocationsInitialised\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTC_SUISSE_TIER_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHINESE_EXCHANGE_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STANDARD_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTC_SUISSE_TIER_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleRevenue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PREPURCHASER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedAllocatable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CERTIFIER\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidAllocatable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"allocateLocked\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BEGIN_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"purchaseTo\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIER_4_BUYIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHINESE_EXCHANGE_4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"specialPurchase\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BUYIN_GAS_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialiseAllocations\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BTC_SUISSE_TIER_3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amberSold\",\"type\":\"uint256\"}],\"name\":\"Prepurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amberSold\",\"type\":\"uint256\"}],\"name\":\"SpecialPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"liquid\",\"type\":\"bool\"}],\"name\":\"Allocated\",\"type\":\"event\"}]", "ContractName": "AmbrosusSale", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://d9f286cae186603a2da1ddb3c0402799f67f26882ed29341ea6bac569e28dfc0"}]}