{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.0;\r\n\r\n/*\r\n * Token - is a smart contract interface \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract TokenInterface {\r\n\r\n        \r\n    // total amount of tokens\r\n    uint totalSupplyVar;\r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    \r\n    function transfer(address to, uint256 value) returns (bool success);\r\n\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how much is \r\n     *               permitted to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permitted to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n    \r\n    function totalSupply() constant returns (uint256 totalSupply){\r\n        return totalSupplyVar;    \r\n    }\r\n\r\n    // events notifications\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/*\r\n * StandardToken - is a smart contract  \r\n * for managing common functionality of \r\n * a token.\r\n *\r\n * ERC.20 Token standard: \r\n *         https://github.com/eth ereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is TokenInterface {\r\n\r\n\r\n    // token ownership\r\n    mapping (address => uint256) balances;\r\n\r\n    // spending permision management\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    \r\n    \r\n    function StandardToken(){\r\n    }\r\n    \r\n    \r\n    /**\r\n     * transfer() - transfer tokens from msg.sender balance \r\n     *              to requested account\r\n     *\r\n     *  @param to    - target address to transfer tokens\r\n     *  @param value - ammount of tokens to transfer\r\n     *\r\n     *  @return - success / failure of the transaction\r\n     */    \r\n    function transfer(address to, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        if (balances[msg.sender] >= value && value > 0) {\r\n\r\n            // do actual tokens transfer       \r\n            balances[msg.sender] -= value;\r\n            balances[to]         += value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**\r\n     * transferFrom() - used to move allowed funds from other owner\r\n     *                  account \r\n     *\r\n     *  @param from  - move funds from account\r\n     *  @param to    - move funds to account\r\n     *  @param value - move the value \r\n     *\r\n     *  @return - return true on success false otherwise \r\n     */\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success) {\r\n    \r\n        if ( balances[from] >= value && \r\n             allowed[from][msg.sender] >= value && \r\n             value > 0) {\r\n                                          \r\n    \r\n            // do the actual transfer\r\n            balances[from] -= value;    \r\n            balances[to]   += value;            \r\n            \r\n\r\n            // addjust the permision, after part of \r\n            // permited to spend value was used\r\n            allowed[from][msg.sender] -= value;\r\n            \r\n            // rise the Transfer event\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { \r\n            \r\n            return false; \r\n        }\r\n    }\r\n\r\n    \r\n\r\n    \r\n    /**\r\n     *\r\n     * balanceOf() - constant function check concrete tokens balance  \r\n     *\r\n     *  @param owner - account owner\r\n     *  \r\n     *  @return the value of balance \r\n     */                               \r\n    function balanceOf(address owner) constant returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     *\r\n     * approve() - function approves to a person to spend some tokens from \r\n     *           owner balance. \r\n     *\r\n     *  @param spender - person whom this right been granted.\r\n     *  @param value   - value to spend.\r\n     * \r\n     *  @return true in case of succes, otherwise failure\r\n     * \r\n     */\r\n    function approve(address spender, uint256 value) returns (bool success) {\r\n        \r\n        \r\n        \r\n        // now spender can use balance in \r\n        // ammount of value from owner balance\r\n        allowed[msg.sender][spender] = value;\r\n        \r\n        // rise event about the transaction\r\n        Approval(msg.sender, spender, value);\r\n        \r\n        return true;\r\n    }\r\n    \r\n\r\n    /**\r\n     *\r\n     * allowance() - constant function to check how mouch is \r\n     *               permited to spend to 3rd person from owner balance\r\n     *\r\n     *  @param owner   - owner of the balance\r\n     *  @param spender - permited to spend from this balance person \r\n     *  \r\n     *  @return - remaining right to spend \r\n     * \r\n     */\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n *\r\n * @title Hacker Gold\r\n * \r\n * The official token powering the hack.ether.camp virtual accelerator.\r\n * This is the only way to acquire tokens from startups during the event.\r\n *\r\n * Whitepaper https://hack.ether.camp/whitepaper\r\n *\r\n */\r\ncontract HackerGold is StandardToken {\r\n\r\n    // Name of the token    \r\n    string public name = \"HackerGold\";\r\n\r\n    // Decimal places\r\n    uint8  public decimals = 3;\r\n    // Token abbreviation        \r\n    string public symbol = \"HKG\";\r\n    \r\n    // 1 ether = 200 hkg\r\n    uint BASE_PRICE = 200;\r\n    // 1 ether = 150 hkg\r\n    uint MID_PRICE = 150;\r\n    // 1 ether = 100 hkg\r\n    uint FIN_PRICE = 100;\r\n    // Safety cap\r\n    uint SAFETY_LIMIT = 4000000 ether;\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    \r\n    // Total value in wei\r\n    uint totalValue;\r\n    \r\n    // Address of multisig wallet holding ether from sale\r\n    address wallet;\r\n\r\n    // Structure of sale increase milestones\r\n    struct milestones_struct {\r\n      uint p1;\r\n      uint p2; \r\n      uint p3;\r\n      uint p4;\r\n      uint p5;\r\n      uint p6;\r\n    }\r\n    // Milestones instance\r\n    milestones_struct milestones;\r\n    \r\n    /**\r\n     * Constructor of the contract.\r\n     * \r\n     * Passes address of the account holding the value.\r\n     * HackerGold contract itself does not hold any value\r\n     * \r\n     * @param multisig address of MultiSig wallet which will hold the value\r\n     */\r\n    function HackerGold(address multisig) {\r\n        \r\n        wallet = multisig;\r\n\r\n        // set time periods for sale\r\n        milestones = milestones_struct(\r\n        \r\n          1476972000,  // P1: GMT: 20-Oct-2016 14:00  => The Sale Starts\r\n          1478181600,  // P2: GMT: 03-Nov-2016 14:00  => 1st Price Ladder \r\n          1479391200,  // P3: GMT: 17-Nov-2016 14:00  => Price Stable, \r\n                       //                                Hackathon Starts\r\n          1480600800,  // P4: GMT: 01-Dec-2016 14:00  => 2nd Price Ladder\r\n          1481810400,  // P5: GMT: 15-Dec-2016 14:00  => Price Stable\r\n          1482415200   // P6: GMT: 22-Dec-2016 14:00  => Sale Ends, Hackathon Ends\r\n        );\r\n        \r\n        // assign recovery balance\r\n        totalSupplyVar   = 16110893000;\r\n        balances[0x342e62732b76875da9305083ea8ae63125a4e667] = 16110893000;\r\n        totalValue    = 85362 ether;        \r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function: called on ether sent.\r\n     * \r\n     * It calls to createHKG function with msg.sender \r\n     * as a value for holder argument\r\n     */\r\n    function () payable {\r\n        createHKG(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Creates HKG tokens.\r\n     * \r\n     * Runs sanity checks including safety cap\r\n     * Then calculates current price by getPrice() function, creates HKG tokens\r\n     * Finally sends a value of transaction to the wallet\r\n     * \r\n     * Note: due to lack of floating point types in Solidity,\r\n     * contract assumes that last 3 digits in tokens amount are stood after the point.\r\n     * It means that if stored HKG balance is 100000, then its real value is 100 HKG\r\n     * \r\n     * @param holder token holder\r\n     */\r\n    function createHKG(address holder) payable {\r\n        \r\n        if (now < milestones.p1) throw;\r\n        if (now >= milestones.p6) throw;\r\n        if (msg.value == 0) throw;\r\n    \r\n        // safety cap\r\n        if (getTotalValue() + msg.value > SAFETY_LIMIT) throw; \r\n    \r\n        uint tokens = msg.value * getPrice() * DECIMAL_ZEROS / 1 ether;\r\n\r\n        totalSupplyVar += tokens;\r\n        balances[holder] += tokens;\r\n        totalValue += msg.value;\r\n        \r\n        if (!wallet.send(msg.value)) throw;\r\n    }\r\n    \r\n    /**\r\n     * Denotes complete price structure during the sale.\r\n     *\r\n     * @return HKG amount per 1 ETH for the current moment in time\r\n     */\r\n    function getPrice() constant returns (uint result) {\r\n        \r\n        if (now < milestones.p1) return 0;\r\n        \r\n        if (now >= milestones.p1 && now < milestones.p2) {\r\n        \r\n            return BASE_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p2 && now < milestones.p3) {\r\n            \r\n            uint days_in = 1 + (now - milestones.p2) / 1 days; \r\n            return BASE_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p3 && now < milestones.p4) {\r\n        \r\n            return MID_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p4 && now < milestones.p5) {\r\n            \r\n            days_in = 1 + (now - milestones.p4) / 1 days; \r\n            return MID_PRICE - days_in * 25 / 7;  // daily decrease 3.5\r\n        }\r\n\r\n        if (now >= milestones.p5 && now < milestones.p6) {\r\n        \r\n            return FIN_PRICE;\r\n        }\r\n        \r\n        if (now >= milestones.p6){\r\n\r\n            return 0;\r\n        }\r\n\r\n     }\r\n    \r\n    /**\r\n     * Returns total stored HKG amount.\r\n     * \r\n     * Contract assumes that last 3 digits of this value are behind the decimal place. i.e. 10001 is 10.001\r\n     * Thus, result of this function should be divided by 1000 to get HKG value\r\n     * \r\n     * @return result stored HKG amount\r\n     */\r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupplyVar;\r\n    } \r\n\r\n    /**\r\n     * It is used for test purposes.\r\n     * \r\n     * Returns the result of 'now' statement of Solidity language\r\n     * \r\n     * @return unix timestamp for current moment in time\r\n     */\r\n    function getNow() constant returns (uint result) {\r\n        return now;\r\n    }\r\n\r\n    /**\r\n     * Returns total value passed through the contract\r\n     * \r\n     * @return result total value in wei\r\n     */\r\n    function getTotalValue() constant returns (uint result) {\r\n        return totalValue;  \r\n    }\r\n}\r\n\r\n\r\n/**\r\n * \r\n * EventInfo - imutable class that denotes\r\n * the time of the virtual accelerator hack\r\n * event\r\n * \r\n */\r\ncontract EventInfo{\r\n    \r\n    \r\n    uint constant HACKATHON_5_WEEKS = 60 * 60 * 24 * 7 * 5;\r\n    uint constant T_1_WEEK = 60 * 60 * 24 * 7;\r\n\r\n    uint eventStart = 1479391200; // Thu, 17 Nov 2016 14:00:00 GMT\r\n    uint eventEnd = eventStart + HACKATHON_5_WEEKS;\r\n    \r\n    \r\n    /**\r\n     * getEventStart - return the start of the event time\r\n     */ \r\n    function getEventStart() constant returns (uint result){        \r\n       return eventStart;\r\n    } \r\n    \r\n    /**\r\n     * getEventEnd - return the end of the event time\r\n     */ \r\n    function getEventEnd() constant returns (uint result){        \r\n       return eventEnd;\r\n    } \r\n    \r\n    \r\n    /**\r\n     * getVotingStart - the voting starts 1 week after the \r\n     *                  event starts\r\n     */ \r\n    function getVotingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getTradingStart - the DST tokens trading starts 1 week \r\n     *                   after the event starts\r\n     */ \r\n    function getTradingStart() constant returns (uint result){\r\n        return eventStart+ T_1_WEEK;\r\n    }\r\n\r\n    /**\r\n     * getNow - helper class to check what time the contract see\r\n     */\r\n    function getNow() constant returns (uint result){        \r\n       return now;\r\n    } \r\n    \r\n}\r\n\r\n\r\n/*\r\n * DSTContract - DST stands for decentralized startup team.\r\n *               the contract ensures funding for a decentralized\r\n *               team in 2 phases: \r\n *\r\n *                +. Funding by HKG during the hackathon event. \r\n *                +. Funding by Ether after the event is over. \r\n *\r\n *               After the funds been collected there is a governence\r\n *               mechanism managed by proposition to withdraw funds\r\n *               for development usage. \r\n *\r\n *               The DST ensures that backers of the projects keeps\r\n *               some influence on the project by ability to reject\r\n *               propositions they find as non effective. \r\n *\r\n *               In very radical occasions the backers may loose \r\n *               the trust in the team completelly, in that case \r\n *               there is an option to propose impeachment process\r\n *               completelly removing the execute and assigning new\r\n *               person to manage the funds. \r\n *\r\n */\r\ncontract DSTContract is StandardToken{\r\n\r\n    // Zeros after the point\r\n    uint DECIMAL_ZEROS = 1000;\r\n    // Proposal lifetime\r\n    uint PROPOSAL_LIFETIME = 10 days;\r\n    // Proposal funds threshold, in percents\r\n    uint PROPOSAL_FUNDS_TH = 20;\r\n\r\n    address   executive; \r\n        \r\n    EventInfo eventInfo;\r\n    \r\n    // Indicated where the DST is traded\r\n    address virtualExchangeAddress;\r\n    \r\n    HackerGold hackerGold;\r\n        \r\n    mapping (address => uint256) votingRights;\r\n\r\n\r\n    // 1 - HKG => DST qty; tokens for 1 HKG\r\n    uint hkgPrice;\r\n    \r\n    // 1 - Ether => DST qty; tokens for 1 Ether\r\n    uint etherPrice;\r\n    \r\n    string public name = \"...\";                   \r\n    uint8  public decimals = 3;                 \r\n    string public symbol = \"...\";\r\n    \r\n    bool ableToIssueTokens = true; \r\n    \r\n    uint preferedQtySold;\r\n\r\n    uint collectedHKG; \r\n    uint collectedEther;    \r\n    \r\n    // Proposal of the funds spending\r\n    mapping (bytes32 => Proposal) proposals;\r\n\r\n    enum ProposalCurrency { HKG, ETHER }\r\n    ProposalCurrency enumDeclaration;\r\n                  \r\n       \r\n    struct Proposal{\r\n        \r\n        bytes32 id;\r\n        uint value;\r\n\r\n        string urlDetails;\r\n\r\n        uint votindEndTS;\r\n                \r\n        uint votesObjecting;\r\n        \r\n        address submitter;\r\n        bool redeemed;\r\n\r\n        ProposalCurrency proposalCurrency;\r\n        \r\n        mapping (address => bool) voted;\r\n    }\r\n    uint counterProposals;\r\n    uint timeOfLastProposal;\r\n    \r\n    Proposal[] listProposals;\r\n    \r\n\r\n    /**\r\n     * Impeachment process proposals\r\n     */    \r\n    struct ImpeachmentProposal{\r\n        \r\n        string urlDetails;\r\n        \r\n        address newExecutive;\r\n\r\n        uint votindEndTS;        \r\n        uint votesSupporting;\r\n        \r\n        mapping (address => bool) voted;        \r\n    }\r\n    ImpeachmentProposal lastImpeachmentProposal;\r\n\r\n        \r\n    /**\r\n     * \r\n     *  DSTContract: ctor for DST token and governence contract\r\n     *\r\n     *  @param eventInfoAddr EventInfo: address of object denotes events \r\n     *                                  milestones      \r\n     *  @param hackerGoldAddr HackerGold: address of HackerGold token\r\n     *\r\n     *  @param dstName string: dstName: real name of the team\r\n     *\r\n     *  @param dstSymbol string: 3 letter symbold of the team\r\n     *\r\n     */ \r\n    function DSTContract(EventInfo eventInfoAddr, HackerGold hackerGoldAddr, string dstName, string dstSymbol){\r\n    \r\n      executive   = msg.sender;  \r\n      name        = dstName;\r\n      symbol      = dstSymbol;\r\n\r\n      hackerGold = HackerGold(hackerGoldAddr);\r\n      eventInfo  = EventInfo(eventInfoAddr);\r\n    }\r\n    \r\n\r\n    function() payable\r\n               onlyAfterEnd {\r\n        \r\n        // there is tokens left from hackathon \r\n        if (etherPrice == 0) throw;\r\n        \r\n        uint tokens = msg.value * etherPrice * DECIMAL_ZEROS / (1 ether);\r\n        \r\n        // check if demand of tokens is \r\n        // overflow the supply \r\n        uint retEther = 0;\r\n        if (balances[this] < tokens) {\r\n            \r\n            tokens = balances[this];\r\n            retEther = msg.value - tokens / etherPrice * (1 finney);\r\n        \r\n            // return left ether \r\n            if (!msg.sender.send(retEther)) throw;\r\n        }\r\n        \r\n        \r\n        // do transfer\r\n        balances[msg.sender] += tokens;\r\n        balances[this] -= tokens;\r\n        \r\n        // count collected ether \r\n        collectedEther += msg.value - retEther; \r\n        \r\n        // rise event\r\n        BuyForEtherTransaction(msg.sender, collectedEther, totalSupplyVar, etherPrice, tokens);\r\n        \r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n     * setHKGPrice - set price: 1HKG => DST tokens qty\r\n     *\r\n     *  @param qtyForOneHKG uint: DST tokens for 1 HKG\r\n     * \r\n     */    \r\n     function setHKGPrice(uint qtyForOneHKG) onlyExecutive  {\r\n         \r\n         hkgPrice = qtyForOneHKG;\r\n         PriceHKGChange(qtyForOneHKG, preferedQtySold, totalSupplyVar);\r\n     }\r\n     \r\n     \r\n    \r\n    /**\r\n     * \r\n     * issuePreferedTokens - prefered tokens issued on the hackathon event\r\n     *                       grant special rights\r\n     *\r\n     *  @param qtyForOneHKG uint: price DST tokens for one 1 HKG\r\n     *  @param qtyToEmit uint: new supply of tokens \r\n     * \r\n     */\r\n    function issuePreferedTokens(uint qtyForOneHKG, \r\n                                 uint256 qtyToEmit) onlyExecutive \r\n                                                 onlyIfAbleToIssueTokens\r\n                                                 onlyBeforeEnd\r\n                                                 onlyAfterTradingStart {\r\n                \r\n        // no issuence is allowed before enlisted on the\r\n        // exchange \r\n        if (virtualExchangeAddress == 0x0) throw;\r\n            \r\n        totalSupplyVar += qtyToEmit;\r\n        balances[this] += qtyToEmit;\r\n        hkgPrice = qtyForOneHKG;\r\n        \r\n        \r\n        // now spender can use balance in \r\n        // amount of value from owner balance\r\n        allowed[this][virtualExchangeAddress] += qtyToEmit;\r\n        \r\n        // rise event about the transaction\r\n        Approval(this, virtualExchangeAddress, qtyToEmit);\r\n        \r\n        // rise event \r\n        DstTokensIssued(hkgPrice, preferedQtySold, totalSupplyVar, qtyToEmit);\r\n    }\r\n\r\n    \r\n    \r\n    \r\n    /**\r\n     * \r\n     * buyForHackerGold - on the hack event this function is available \r\n     *                    the buyer for hacker gold will gain votes to \r\n     *                    influence future proposals on the DST\r\n     *    \r\n     *  @param hkgValue - qty of this DST tokens for 1 HKG     \r\n     * \r\n     */\r\n    function buyForHackerGold(uint hkgValue) onlyBeforeEnd \r\n                                             returns (bool success) {\r\n    \r\n      // validate that the caller is official accelerator HKG Exchange\r\n      if (msg.sender != virtualExchangeAddress) throw;\r\n      \r\n      \r\n      // transfer token \r\n      address sender = tx.origin;\r\n      uint tokensQty = hkgValue * hkgPrice;\r\n\r\n      // gain voting rights\r\n      votingRights[sender] +=tokensQty;\r\n      preferedQtySold += tokensQty;\r\n      collectedHKG += hkgValue;\r\n\r\n      // do actual transfer\r\n      transferFrom(this, \r\n                   virtualExchangeAddress, tokensQty);\r\n      transfer(sender, tokensQty);        \r\n            \r\n      // rise event       \r\n      BuyForHKGTransaction(sender, preferedQtySold, totalSupplyVar, hkgPrice, tokensQty);\r\n        \r\n      return true;\r\n    }\r\n        \r\n    \r\n    /**\r\n     * \r\n     * issueTokens - function will issue tokens after the \r\n     *               event, able to sell for 1 ether \r\n     * \r\n     *  @param qtyForOneEther uint: DST tokens for 1 ETH\r\n     *  @param qtyToEmit uint: new tokens supply\r\n     *\r\n     */\r\n    function issueTokens(uint qtyForOneEther, \r\n                         uint qtyToEmit) onlyAfterEnd \r\n                                         onlyExecutive\r\n                                         onlyIfAbleToIssueTokens {\r\n         \r\n         balances[this] += qtyToEmit;\r\n         etherPrice = qtyForOneEther;\r\n         totalSupplyVar    += qtyToEmit;\r\n         \r\n         // rise event  \r\n         DstTokensIssued(qtyForOneEther, totalSupplyVar, totalSupplyVar, qtyToEmit);\r\n    }\r\n     \r\n    \r\n    /**\r\n     * setEtherPrice - change the token price\r\n     *\r\n     *  @param qtyForOneEther uint: new price - DST tokens for 1 ETH\r\n     */     \r\n    function setEtherPrice(uint qtyForOneEther) onlyAfterEnd\r\n                                                onlyExecutive {\r\n         etherPrice = qtyForOneEther; \r\n\r\n         // rise event for this\r\n         NewEtherPrice(qtyForOneEther);\r\n    }    \r\n    \r\n\r\n    /**\r\n     *  disableTokenIssuance - function will disable any \r\n     *                         option for future token \r\n     *                         issuence\r\n     */\r\n    function disableTokenIssuance() onlyExecutive {\r\n        ableToIssueTokens = false;\r\n        \r\n        DisableTokenIssuance();\r\n    }\r\n\r\n    \r\n    /**\r\n     *  burnRemainToken -  eliminated all available for sale\r\n     *                     tokens. \r\n     */\r\n    function burnRemainToken() onlyExecutive {\r\n    \r\n        totalSupplyVar -= balances[this];\r\n        balances[this] = 0;\r\n        \r\n        // rise event for this\r\n        BurnedAllRemainedTokens();\r\n    }\r\n    \r\n    /**\r\n     *  submitEtherProposal: submit proposal to use part of the \r\n     *                       collected ether funds\r\n     *\r\n     *   @param requestValue uint: value in wei \r\n     *   @param url string: details of the proposal \r\n     */ \r\n    function submitEtherProposal(uint requestValue, string url) onlyAfterEnd \r\n                                                                onlyExecutive returns (bytes32 resultId, bool resultSucces) {       \r\n    \r\n        // ensure there is no more issuence available \r\n        if (ableToIssueTokens) throw;\r\n            \r\n        // ensure there is no more tokens available \r\n        if (balanceOf(this) > 0) throw;\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n            \r\n        uint percent = collectedEther / 100;\r\n            \r\n        if (requestValue > PROPOSAL_FUNDS_TH * percent) throw;\r\n\r\n        // if remained value is less than requested gain all.\r\n        if (requestValue > this.balance) \r\n            requestValue = this.balance;    \r\n            \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n            \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.ETHER);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n            \r\n        timeOfLastProposal = now;                        \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);\r\n    }\r\n    \r\n    \r\n     \r\n    /**\r\n     * \r\n     * submitHKGProposal - submit proposal to request for \r\n     *                     partial HKG funds collected \r\n     * \r\n     *  @param requestValue uint: value in HKG to request. \r\n     *  @param url string: url with details on the proposition \r\n     */\r\n    function submitHKGProposal(uint requestValue, string url) onlyAfterEnd\r\n                                                              onlyExecutive returns (bytes32 resultId, bool resultSucces){\r\n        \r\n\r\n        // If there is no 2 months over since the last event.\r\n        // There is no posible to get any HKG. After 2 months\r\n        // all the HKG is available. \r\n        if (now < (eventInfo.getEventEnd() + 8 weeks)) {\r\n            throw;\r\n        }\r\n\r\n        // Possible to submit a proposal once 2 weeks \r\n        if (now < (timeOfLastProposal + 2 weeks)) throw;\r\n\r\n        uint percent = preferedQtySold / 100;\r\n        \r\n        // validate the amount is legit\r\n        // first 5 proposals should be less than 20% \r\n        if (counterProposals <= 5 && \r\n            requestValue     >  PROPOSAL_FUNDS_TH * percent) throw;\r\n                \r\n        // if remained value is less than requested \r\n        // gain all.\r\n        if (requestValue > getHKGOwned()) \r\n            requestValue = getHKGOwned();\r\n        \r\n        \r\n        // set id of the proposal\r\n        // submit proposal to the map\r\n        bytes32 id = sha3(msg.data, now);\r\n        uint timeEnds = now + PROPOSAL_LIFETIME; \r\n        \r\n        Proposal memory newProposal = Proposal(id, requestValue, url, timeEnds, 0, msg.sender, false, ProposalCurrency.HKG);\r\n        proposals[id] = newProposal;\r\n        listProposals.push(newProposal);\r\n        \r\n        ++counterProposals;\r\n        timeOfLastProposal = now;                \r\n                \r\n        ProposalRequestSubmitted(id, requestValue, timeEnds, url, msg.sender);\r\n        \r\n        return (id, true);        \r\n    }  \r\n    \r\n    \r\n    \r\n    /**\r\n     * objectProposal - object previously submitted proposal, \r\n     *                  the objection right is obtained by \r\n     *                  purchasing prefered tokens on time of \r\n     *                  the hackathon.\r\n     * \r\n     *  @param id bytes32 : the id of the proposla to redeem\r\n     */\r\n     function objectProposal(bytes32 id){\r\n         \r\n        Proposal memory proposal = proposals[id];\r\n         \r\n        // check proposal exist \r\n        if (proposals[id].id == 0) throw;\r\n\r\n        // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n         \r\n        // ensure objection time\r\n        if (now >= proposals[id].votindEndTS) throw;\r\n         \r\n        // ensure not voted  \r\n        if (proposals[id].voted[msg.sender]) throw;\r\n         \r\n         // submit votes\r\n         uint votes = votingRights[msg.sender];\r\n         proposals[id].votesObjecting += votes;\r\n         \r\n         // mark voted \r\n         proposals[id].voted[msg.sender] = true; \r\n         \r\n         uint idx = getIndexByProposalId(id);\r\n         listProposals[idx] = proposals[id];   \r\n\r\n         ObjectedVote(id, msg.sender, votes);         \r\n     }\r\n     \r\n     \r\n     function getIndexByProposalId(bytes32 id) returns (uint result){\r\n         \r\n         for (uint i = 0; i < listProposals.length; ++i){\r\n             if (id == listProposals[i].id) return i;\r\n         }\r\n     }\r\n    \r\n    \r\n   \r\n    /**\r\n     * redeemProposalFunds - redeem funds requested by prior \r\n     *                       submitted proposal     \r\n     * \r\n     * @param id bytes32: the id of the proposal to redeem\r\n     */\r\n    function redeemProposalFunds(bytes32 id) onlyExecutive {\r\n\r\n        if (proposals[id].id == 0) throw;\r\n        if (proposals[id].submitter != msg.sender) throw;\r\n\r\n        // ensure objection time\r\n        if (now < proposals[id].votindEndTS) throw;\r\n                           \r\n    \r\n            // check already redeemed\r\n        if (proposals[id].redeemed) throw;\r\n\r\n        // check votes objection => 55% of total votes\r\n        uint objectionThreshold = preferedQtySold / 100 * 55;\r\n        if (proposals[id].votesObjecting  > objectionThreshold) throw;\r\n    \r\n    \r\n        if (proposals[id].proposalCurrency == ProposalCurrency.HKG){\r\n            \r\n            // send hacker gold \r\n            hackerGold.transfer(proposals[id].submitter, proposals[id].value);      \r\n                        \r\n        } else {\r\n                        \r\n           // send ether              \r\n           bool success = proposals[id].submitter.send(proposals[id].value); \r\n\r\n           // rise event\r\n           EtherRedeemAccepted(proposals[id].submitter, proposals[id].value);                              \r\n        }\r\n        \r\n        // execute the proposal \r\n        proposals[id].redeemed = true; \r\n    }\r\n    \r\n    \r\n    /**\r\n     *  getAllTheFunds - to ensure there is no deadlock can \r\n     *                   can happen, and no case that voting \r\n     *                   structure will freeze the funds forever\r\n     *                   the startup will be able to get all the\r\n     *                   funds without a proposal required after\r\n     *                   6 months.\r\n     * \r\n     * \r\n     */             \r\n    function getAllTheFunds() onlyExecutive {\r\n        \r\n        // If there is a deadlock in voting participates\r\n        // the funds can be redeemed completelly in 6 months\r\n        if (now < (eventInfo.getEventEnd() + 24 weeks)) {\r\n            throw;\r\n        }  \r\n        \r\n        // all the Ether\r\n        bool success = msg.sender.send(this.balance);        \r\n        \r\n        // all the HKG\r\n        hackerGold.transfer(msg.sender, getHKGOwned());              \r\n    }\r\n    \r\n    \r\n    /**\r\n     * submitImpeachmentProposal - submit request to switch \r\n     *                             executive.\r\n     * \r\n     *  @param urlDetails  - details of the impeachment proposal \r\n     *  @param newExecutive - address of the new executive \r\n     * \r\n     */             \r\n     function submitImpeachmentProposal(string urlDetails, address newExecutive){\r\n         \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n         \r\n        // the submission of the first impeachment \r\n        // proposal is possible only after 3 months\r\n        // since the hackathon is over\r\n        if (now < (eventInfo.getEventEnd() + 12 weeks)) throw;\r\n        \r\n                \r\n        // check there is 1 months over since last one\r\n        if (lastImpeachmentProposal.votindEndTS != 0 && \r\n            lastImpeachmentProposal.votindEndTS +  2 weeks > now) throw;\r\n\r\n\r\n        // submit impeachment proposal\r\n        // add the votes of the submitter \r\n        // to the proposal right away\r\n        lastImpeachmentProposal = ImpeachmentProposal(urlDetails, newExecutive, now + 2 weeks, votingRights[msg.sender]);\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n         \r\n        // rise event\r\n        ImpeachmentProposed(msg.sender, urlDetails, now + 2 weeks, newExecutive);\r\n     }\r\n    \r\n    \r\n    /**\r\n     * supportImpeachment - vote for impeachment proposal \r\n     *                      that is currently in progress\r\n     *\r\n     */\r\n    function supportImpeachment(){\r\n\r\n        // ensure that support is for exist proposal \r\n        if (lastImpeachmentProposal.newExecutive == 0x0) throw;\r\n    \r\n        // to offer impeachment you should have \r\n        // voting rights\r\n        if (votingRights[msg.sender] == 0) throw;\r\n        \r\n        // check if not voted already \r\n        if (lastImpeachmentProposal.voted[msg.sender]) throw;\r\n        \r\n        // check if not finished the 2 weeks of voting \r\n        if (lastImpeachmentProposal.votindEndTS + 2 weeks <= now) throw;\r\n                \r\n        // support the impeachment\r\n        lastImpeachmentProposal.voted[msg.sender] = true;\r\n        lastImpeachmentProposal.votesSupporting += votingRights[msg.sender];\r\n\r\n        // rise impeachment suppporting event\r\n        ImpeachmentSupport(msg.sender, votingRights[msg.sender]);\r\n        \r\n        // if the vote is over 70% execute the switch \r\n        uint percent = preferedQtySold / 100; \r\n        \r\n        if (lastImpeachmentProposal.votesSupporting >= 70 * percent){\r\n            executive = lastImpeachmentProposal.newExecutive;\r\n            \r\n            // impeachment event\r\n            ImpeachmentAccepted(executive);\r\n        }\r\n        \r\n    } \r\n    \r\n      \r\n    \r\n    // **************************** //\r\n    // *     Constant Getters     * //\r\n    // **************************** //\r\n    \r\n    function votingRightsOf(address _owner) constant returns (uint256 result) {\r\n        result = votingRights[_owner];\r\n    }\r\n    \r\n    function getPreferedQtySold() constant returns (uint result){\r\n        return preferedQtySold;\r\n    }\r\n    \r\n    function setVirtualExchange(address virtualExchangeAddr){\r\n        if (virtualExchangeAddress != 0x0) throw;\r\n        virtualExchangeAddress = virtualExchangeAddr;\r\n    }\r\n\r\n    function getHKGOwned() constant returns (uint result){\r\n        return hackerGold.balanceOf(this);\r\n    }\r\n    \r\n    function getEtherValue() constant returns (uint result){\r\n        return this.balance;\r\n    }\r\n    \r\n    function getExecutive() constant returns (address result){\r\n        return executive;\r\n    }\r\n    \r\n    function getHKGPrice() constant returns (uint result){\r\n        return hkgPrice;\r\n    }\r\n\r\n    function getEtherPrice() constant returns (uint result){\r\n        return etherPrice;\r\n    }\r\n    \r\n    function getDSTName() constant returns(string result){\r\n        return name;\r\n    }    \r\n    \r\n    function getDSTNameBytes() constant returns(bytes32 result){\r\n        return convert(name);\r\n    }    \r\n\r\n    function getDSTSymbol() constant returns(string result){\r\n        return symbol;\r\n    }    \r\n    \r\n    function getDSTSymbolBytes() constant returns(bytes32 result){\r\n        return convert(symbol);\r\n    }    \r\n\r\n    function getAddress() constant returns (address result) {\r\n        return this;\r\n    }\r\n    \r\n    function getTotalSupply() constant returns (uint result) {\r\n        return totalSupplyVar;\r\n    } \r\n        \r\n    function getCollectedEther() constant returns (uint results) {        \r\n        return collectedEther;\r\n    }\r\n    \r\n    function getCounterProposals() constant returns (uint result){\r\n        return counterProposals;\r\n    }\r\n        \r\n    function getProposalIdByIndex(uint i) constant returns (bytes32 result){\r\n        return listProposals[i].id;\r\n    }    \r\n\r\n    function getProposalObjectionByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].votesObjecting;\r\n    }\r\n\r\n    function getProposalValueByIndex(uint i) constant returns (uint result){\r\n        return listProposals[i].value;\r\n    }                  \r\n    \r\n    function getCurrentImpeachmentUrlDetails() constant returns (string result){\r\n        return lastImpeachmentProposal.urlDetails;\r\n    }\r\n    \r\n    \r\n    function getCurrentImpeachmentVotesSupporting() constant returns (uint result){\r\n        return lastImpeachmentProposal.votesSupporting;\r\n    }\r\n    \r\n    function convert(string key) returns (bytes32 ret) {\r\n            if (bytes(key).length > 32) {\r\n                throw;\r\n            }      \r\n\r\n            assembly {\r\n                ret := mload(add(key, 32))\r\n            }\r\n    }    \r\n    \r\n    // Emergency Fix limited by time functions\r\n    function setVoteRight(address voter, uint ammount){\r\n        \r\n        // limited by [12 Jan 2017 00:00:00 GMT]\r\n        if (now > 1484179200) throw;\r\n\r\n        // limited by one account to fix \r\n        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\r\n\r\n        votingRights[voter] = ammount;\r\n    }\r\n    \r\n    // Emergency Fix limited by time functions\r\n    function setBalance(address owner, uint ammount){\r\n\r\n        // limited by [12 Jan 2017 00:00:00 GMT]\r\n        if (now > 1484179200) throw;\r\n        \r\n        // limited by one account to fix \r\n        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\r\n        \r\n        balances[owner] = ammount;\r\n    }\r\n    \r\n    // Emergency Fix limited by time functions\r\n    function setInternalInfo(address fixExecutive, uint fixTotalSupply, uint256 fixPreferedQtySold, \r\n            uint256 fixCollectedHKG, uint fixCollectedEther){\r\n\r\n        // limited by [12 Jan 2017 00:00:00 GMT]\r\n        if (now > 1484179200) throw;\r\n        \r\n        // limited by one account to fix \r\n        if (msg.sender != 0x342e62732b76875da9305083ea8ae63125a4e667) throw;\r\n        \r\n        executive = fixExecutive;\r\n        totalSupplyVar = fixTotalSupply;\r\n        preferedQtySold = fixPreferedQtySold;\r\n        collectedHKG = fixCollectedHKG;\r\n        collectedEther = fixCollectedEther;\r\n    }\r\n    \r\n    \r\n    // ********************* //\r\n    // *     Modifiers     * //\r\n    // ********************* //    \r\n \r\n    modifier onlyBeforeEnd() { if (now  >=  eventInfo.getEventEnd()) throw; _; }\r\n    modifier onlyAfterEnd()  { if (now  <   eventInfo.getEventEnd()) throw; _; }\r\n    \r\n    modifier onlyAfterTradingStart()  { if (now  < eventInfo.getTradingStart()) throw; _; }\r\n    \r\n    modifier onlyExecutive()     { if (msg.sender != executive) throw; _; }\r\n                                       \r\n    modifier onlyIfAbleToIssueTokens()  { if (!ableToIssueTokens) throw; _; } \r\n    \r\n\r\n    // ****************** //\r\n    // *     Events     * //\r\n    // ****************** //        \r\n\r\n    \r\n    event PriceHKGChange(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply);\r\n    event BuyForHKGTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneHKG, uint tokensAmount);\r\n    event BuyForEtherTransaction(address indexed buyer, uint indexed tokensSold, uint indexed totalSupply, uint qtyForOneEther, uint tokensAmount);\r\n\r\n    event DstTokensIssued(uint indexed qtyForOneHKG, uint indexed tokensSold, uint indexed totalSupply, uint qtyToEmit);\r\n    \r\n    event ProposalRequestSubmitted(bytes32 id, uint value, uint timeEnds, string url, address sender);\r\n    \r\n    event EtherRedeemAccepted(address sender, uint value);\r\n    \r\n    event ObjectedVote(bytes32 id, address voter, uint votes);\r\n    \r\n    event ImpeachmentProposed(address submitter, string urlDetails, uint votindEndTS, address newExecutive);\r\n    event ImpeachmentSupport(address supportter, uint votes);\r\n    \r\n    event ImpeachmentAccepted(address newExecutive);\r\n\r\n    event NewEtherPrice(uint newQtyForOneEther);\r\n    event DisableTokenIssuance();\r\n    \r\n    event BurnedAllRemainedTokens();\r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"supportImpeachment\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDSTName\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDSTSymbolBytes\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherValue\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qtyForOneEther\",\"type\":\"uint256\"}],\"name\":\"setEtherPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHKGPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getProposalObjectionByIndex\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getProposalValueByIndex\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCollectedEther\",\"outputs\":[{\"name\":\"results\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentImpeachmentVotesSupporting\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDSTNameBytes\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"redeemProposalFunds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableTokenIssuance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hkgValue\",\"type\":\"uint256\"}],\"name\":\"buyForHackerGold\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDSTSymbol\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qtyForOneEther\",\"type\":\"uint256\"},{\"name\":\"qtyToEmit\",\"type\":\"uint256\"}],\"name\":\"issueTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestValue\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"submitHKGProposal\",\"outputs\":[{\"name\":\"resultId\",\"type\":\"bytes32\"},{\"name\":\"resultSucces\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getAllTheFunds\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCounterProposals\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requestValue\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"submitEtherProposal\",\"outputs\":[{\"name\":\"resultId\",\"type\":\"bytes32\"},{\"name\":\"resultSucces\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExecutive\",\"outputs\":[{\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fixExecutive\",\"type\":\"address\"},{\"name\":\"fixTotalSupply\",\"type\":\"uint256\"},{\"name\":\"fixPreferedQtySold\",\"type\":\"uint256\"},{\"name\":\"fixCollectedHKG\",\"type\":\"uint256\"},{\"name\":\"fixCollectedEther\",\"type\":\"uint256\"}],\"name\":\"setInternalInfo\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"virtualExchangeAddr\",\"type\":\"address\"}],\"name\":\"setVirtualExchange\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qtyForOneHKG\",\"type\":\"uint256\"},{\"name\":\"qtyToEmit\",\"type\":\"uint256\"}],\"name\":\"issuePreferedTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"objectProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getIndexByProposalId\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnRemainToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentImpeachmentUrlDetails\",\"outputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPreferedQtySold\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"ret\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getProposalIdByIndex\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voter\",\"type\":\"address\"},{\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"setVoteRight\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"urlDetails\",\"type\":\"string\"},{\"name\":\"newExecutive\",\"type\":\"address\"}],\"name\":\"submitImpeachmentProposal\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qtyForOneHKG\",\"type\":\"uint256\"}],\"name\":\"setHKGPrice\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHKGOwned\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"votingRightsOf\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"setBalance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"eventInfoAddr\",\"type\":\"address\"},{\"name\":\"hackerGoldAddr\",\"type\":\"address\"},{\"name\":\"dstName\",\"type\":\"string\"},{\"name\":\"dstSymbol\",\"type\":\"string\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"qtyForOneHKG\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"PriceHKGChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"qtyForOneHKG\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"BuyForHKGTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"qtyForOneEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"BuyForEtherTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"qtyForOneHKG\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"qtyToEmit\",\"type\":\"uint256\"}],\"name\":\"DstTokensIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeEnds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"url\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ProposalRequestSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EtherRedeemAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"ObjectedVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"submitter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"urlDetails\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"votindEndTS\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newExecutive\",\"type\":\"address\"}],\"name\":\"ImpeachmentProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"supportter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"ImpeachmentSupport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newExecutive\",\"type\":\"address\"}],\"name\":\"ImpeachmentAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newQtyForOneEther\",\"type\":\"uint256\"}],\"name\":\"NewEtherPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DisableTokenIssuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BurnedAllRemainedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "DSTContract", "CompilerVersion": "v0.4.7+commit.822622cf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001c3c643f49be262c3040e917e7d2299b9bc081a100000000000000000000000014f37b574242d366558db61f3335289a5035c506000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000008657468657269736300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035253430000000000000000000000000000000000000000000000000000000000", "Library": "", "SwarmSource": "bzzr://9e2efb647affe4b121be69dfe47f519312f512075279019ffe2fb874a2ae9588"}]}