{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract SphereTokenFactory{\r\n\tfunction mint(address target, uint amount);\r\n}\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Owned {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    if (halted) throw;\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!halted) throw;\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\ncontract PricingMechanism is Haltable, SafeMath{\r\n    uint public decimals;\r\n    PriceTier[] public priceList;\r\n    uint8 public numTiers;\r\n    uint public currentTierIndex;\r\n    uint public totalDepositedEthers;\r\n    \r\n    struct  PriceTier {\r\n        uint costPerToken;\r\n        uint ethersDepositedInTier;\r\n        uint maxEthersInTier;\r\n    }\r\n    function setPricing() onlyOwner{\r\n        uint factor = 10 ** decimals;\r\n        priceList.push(PriceTier(uint(safeDiv(1 ether, 400 * factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint((1 ether - (10 wei * factor)) / (90 * factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint(1 ether / (80* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint((1 ether - (50 wei * factor)) / (70* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint((1 ether - (40 wei * factor)) / (60* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint(1 ether / (50* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint(1 ether / (40* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint((1 ether - (10 wei * factor))/ (30* factor)),0,5000 ether));\r\n        priceList.push(PriceTier(uint((1 ether - (10 wei * factor))/ (15* factor)),0,30000 ether));\r\n        numTiers = 9;\r\n    }\r\n    function allocateTokensInternally(uint value) internal constant returns(uint numTokens){\r\n        if (numTiers == 0) return 0;\r\n        numTokens = 0;\r\n        uint8 tierIndex = 0;\r\n        for (uint8 i = 0; i < numTiers; i++){\r\n            if (priceList[i].ethersDepositedInTier < priceList[i].maxEthersInTier){\r\n                uint ethersToDepositInTier = min256(priceList[i].maxEthersInTier - priceList[i].ethersDepositedInTier, value);\r\n                numTokens = safeAdd(numTokens, ethersToDepositInTier / priceList[i].costPerToken);\r\n                priceList[i].ethersDepositedInTier = safeAdd(ethersToDepositInTier, priceList[i].ethersDepositedInTier);\r\n                totalDepositedEthers = safeAdd(ethersToDepositInTier, totalDepositedEthers);\r\n                value = safeSub(value, ethersToDepositInTier);\r\n                if (priceList[i].ethersDepositedInTier > 0)\r\n                    tierIndex = i;\r\n            }\r\n        }\r\n        currentTierIndex = tierIndex;\r\n        return numTokens;\r\n    }\r\n    \r\n}\r\n\r\ncontract DAOController{\r\n    address public dao;\r\n    modifier onlyDAO{\r\n        if (msg.sender != dao) throw;\r\n        _;\r\n    }\r\n}\r\n\r\ncontract CrowdSale is PricingMechanism, DAOController{\r\n    SphereTokenFactory public tokenFactory;\r\n    uint public hardCapAmount;\r\n    bool public isStarted = false;\r\n    bool public isFinalized = false;\r\n    uint public duration = 30 days;\r\n    uint public startTime;\r\n    address public multiSig;\r\n    bool public finalizeSet = false;\r\n    \r\n    modifier onlyStarted{\r\n        if (!isStarted) throw;\r\n        _;\r\n    }\r\n    modifier notFinalized{\r\n        if (isFinalized) throw;\r\n        _;\r\n    }\r\n    modifier afterFinalizeSet{\r\n        if (!finalizeSet) throw;\r\n        _;\r\n    }\r\n    function CrowdSale(){\r\n        tokenFactory = SphereTokenFactory(0xf961eb0acf690bd8f92c5f9c486f3b30848d87aa);\r\n        decimals = 4;\r\n        setPricing();\r\n        hardCapAmount = 75000 ether;\r\n    }\r\n    function startCrowdsale() onlyOwner {\r\n        if (isStarted) throw;\r\n        isStarted = true;\r\n        startTime = now;\r\n    }\r\n    function setDAOAndMultiSig(address _dao, address _multiSig) onlyOwner{\r\n        dao = _dao;\r\n        multiSig = _multiSig;\r\n        finalizeSet = true;\r\n    }\r\n    function() payable stopInEmergency onlyStarted notFinalized{\r\n        if (totalDepositedEthers >= hardCapAmount) throw;\r\n        uint contribution = msg.value;\r\n        if (safeAdd(totalDepositedEthers, msg.value) > hardCapAmount){\r\n            contribution = safeSub(hardCapAmount, totalDepositedEthers);\r\n        }\r\n        uint excess = safeSub(msg.value, contribution);\r\n        uint numTokensToAllocate = allocateTokensInternally(contribution);\r\n        tokenFactory.mint(msg.sender, numTokensToAllocate);\r\n        if (excess > 0){\r\n            msg.sender.send(excess);\r\n        }\r\n    }\r\n    \r\n    function finalize() payable onlyOwner afterFinalizeSet{\r\n        if (hardCapAmount == totalDepositedEthers || (now - startTime) > duration){\r\n            dao.call.gas(150000).value(totalDepositedEthers * 3 / 10)();\r\n            multiSig.call.gas(150000).value(this.balance)();\r\n            isFinalized = true;\r\n        }\r\n    }\r\n    function emergencyCease() payable onlyStarted onlyInEmergency onlyOwner afterFinalizeSet{\r\n        isFinalized = true;\r\n        isStarted = false;\r\n        multiSig.call.gas(150000).value(this.balance)();\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceList\",\"outputs\":[{\"name\":\"costPerToken\",\"type\":\"uint256\"},{\"name\":\"ethersDepositedInTier\",\"type\":\"uint256\"},{\"name\":\"maxEthersInTier\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTierIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTiers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dao\",\"type\":\"address\"},{\"name\":\"_multiSig\",\"type\":\"address\"}],\"name\":\"setDAOAndMultiSig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDepositedEthers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startCrowdsale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalizeSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyCease\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setPricing\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]", "ContractName": "CrowdSale", "CompilerVersion": "v0.4.14+commit.c2215d46", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://1b3e3c87b2545220d44978855a538b38d0715cb0dcb5adb89385cb1f0d9c862a"}]}