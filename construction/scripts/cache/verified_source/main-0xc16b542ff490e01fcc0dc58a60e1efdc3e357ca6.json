{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\nlibrary itMaps {\r\n\r\n    /* itMapAddressUint\r\n         address =>  Uint\r\n    */\r\n    struct entryAddressUint {\r\n    // Equal to the index of the key of this item in keys, plus 1.\r\n    uint keyIndex;\r\n    uint value;\r\n    }\r\n\r\n    struct itMapAddressUint {\r\n    mapping(address => entryAddressUint) data;\r\n    address[] keys;\r\n    }\r\n\r\n    function insert(itMapAddressUint storage self, address key, uint value) internal returns (bool replaced) {\r\n        entryAddressUint storage e = self.data[key];\r\n        e.value = value;\r\n        if (e.keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            e.keyIndex = ++self.keys.length;\r\n            self.keys[e.keyIndex - 1] = key;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function remove(itMapAddressUint storage self, address key) internal returns (bool success) {\r\n        entryAddressUint storage e = self.data[key];\r\n        if (e.keyIndex == 0)\r\n        return false;\r\n\r\n        if (e.keyIndex <= self.keys.length) {\r\n            // Move an existing element into the vacated key slot.\r\n            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\r\n            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\r\n            self.keys.length -= 1;\r\n            delete self.data[key];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function destroy(itMapAddressUint storage self) internal  {\r\n        for (uint i; i<self.keys.length; i++) {\r\n            delete self.data[ self.keys[i]];\r\n        }\r\n        delete self.keys;\r\n        return ;\r\n    }\r\n\r\n    function contains(itMapAddressUint storage self, address key) internal constant returns (bool exists) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function size(itMapAddressUint storage self) internal constant returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n\r\n    function get(itMapAddressUint storage self, address key) internal constant returns (uint) {\r\n        return self.data[key].value;\r\n    }\r\n\r\n    function getKeyByIndex(itMapAddressUint storage self, uint idx) internal constant returns (address) {\r\n        return self.keys[idx];\r\n    }\r\n\r\n    function getValueByIndex(itMapAddressUint storage self, uint idx) internal constant returns (uint) {\r\n        return self.data[self.keys[idx]].value;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public constant returns (uint256 supply);\r\n    function balanceOf(address who) public constant returns (uint value);\r\n    function allowance(address owner, address spender) public constant returns (uint _allowance);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract IceRockMining is ERC20{\r\n    using itMaps for itMaps.itMapAddressUint;\r\n\r\n\r\n    uint256 initialSupply = 20000000;\r\n    string public constant name = \"ICE ROCK MINING\";\r\n    string public constant symbol = \"ROCK2\";\r\n    uint currentUSDExchangeRate = 1340;\r\n    uint bonus = 0;\r\n    uint priceUSD = 1;\r\n    address IceRockMiningAddress;\r\n\r\n    itMaps.itMapAddressUint balances;\r\n\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint256) approvedDividends;\r\n\r\n    event Burned(address indexed from, uint amount);\r\n    event DividendsTransfered(address to, uint amount);\r\n\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender == IceRockMiningAddress) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function totalSupply() public constant returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address tokenHolder) public view returns (uint256 balance) {\r\n        return balances.get(tokenHolder);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public constant returns (uint256) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n\r\n    function transfer(address to, uint value) public returns (bool success) {\r\n        if (balances.get(msg.sender) >= value && value > 0) {\r\n\r\n            balances.insert(msg.sender, balances.get(msg.sender)-value);\r\n\r\n            if (balances.contains(to)) {\r\n                balances.insert(to, balances.get(to)+value);\r\n            }\r\n            else {\r\n                balances.insert(to, value);\r\n            }\r\n\r\n            Transfer(msg.sender, to, value);\r\n\r\n            return true;\r\n\r\n        } else return false;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances.get(from) >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n\r\n            uint amountToInsert = value;\r\n\r\n            if (balances.contains(to))\r\n            amountToInsert = amountToInsert+balances.get(to);\r\n\r\n            balances.insert(to, amountToInsert);\r\n            balances.insert(from, balances.get(from) - value);\r\n            allowed[from][msg.sender] = allowed[from][msg.sender] - value;\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else\r\n        return false;\r\n    }\r\n\r\n    function approve(address spender, uint value) public returns (bool success) {\r\n        if ((value != 0) && (balances.get(msg.sender) >= value)){\r\n            allowed[msg.sender][spender] = value;\r\n            Approval(msg.sender, spender, value);\r\n            return true;\r\n        } else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function IceRockMining() public {\r\n        IceRockMiningAddress = msg.sender;\r\n        balances.insert(IceRockMiningAddress, initialSupply);\r\n    }\r\n\r\n    function setCurrentExchangeRate (uint rate) public onlyOwner{\r\n        currentUSDExchangeRate = rate;\r\n    }\r\n\r\n    function setBonus (uint value) public onlyOwner{\r\n        bonus = value;\r\n    }\r\n\r\n    function send(address addr, uint amount) public onlyOwner {\r\n        sendp(addr, amount);\r\n    }\r\n\r\n    function sendp(address addr, uint amount) internal {\r\n        require(addr != IceRockMiningAddress);\r\n        require(amount > 0);\r\n        require (balances.get(IceRockMiningAddress)>=amount);\r\n\r\n\r\n        if (balances.contains(addr)) {\r\n            balances.insert(addr, balances.get(addr)+amount);\r\n        }\r\n        else {\r\n            balances.insert(addr, amount);\r\n        }\r\n\r\n        balances.insert(IceRockMiningAddress, balances.get(IceRockMiningAddress)-amount);\r\n        Transfer(IceRockMiningAddress, addr, amount);\r\n    }\r\n\r\n    function () public payable{\r\n        uint amountInUSDollars = msg.value * currentUSDExchangeRate / 10**18;\r\n        uint valueToPass = amountInUSDollars / priceUSD;\r\n        valueToPass = (valueToPass * (100 + bonus))/100;\r\n\r\n        if (balances.get(IceRockMiningAddress) >= valueToPass) {\r\n            if (balances.contains(msg.sender)) {\r\n                balances.insert(msg.sender, balances.get(msg.sender)+valueToPass);\r\n            }\r\n            else {\r\n                balances.insert(msg.sender, valueToPass);\r\n            }\r\n            balances.insert(IceRockMiningAddress, balances.get(IceRockMiningAddress)-valueToPass);\r\n            Transfer(IceRockMiningAddress, msg.sender, valueToPass);\r\n        }\r\n    }\r\n\r\n    function approveDividends (uint totalDividendsAmount) public onlyOwner {\r\n        uint256 dividendsPerToken = totalDividendsAmount*10**18 / initialSupply;\r\n        for (uint256 i = 0; i<balances.size(); i += 1) {\r\n            address tokenHolder = balances.getKeyByIndex(i);\r\n            if (balances.get(tokenHolder)>0)\r\n            approvedDividends[tokenHolder] = balances.get(tokenHolder)*dividendsPerToken;\r\n        }\r\n    }\r\n\r\n    function burnUnsold() public onlyOwner returns (bool success) {\r\n        uint burningAmount = balances.get(IceRockMiningAddress);\r\n        initialSupply -= burningAmount;\r\n        balances.insert(IceRockMiningAddress, 0);\r\n        Burned(IceRockMiningAddress, burningAmount);\r\n        return true;\r\n    }\r\n\r\n    function approvedDividendsOf(address tokenHolder) public view returns (uint256) {\r\n        return approvedDividends[tokenHolder];\r\n    }\r\n\r\n    function transferAllDividends() public onlyOwner{\r\n        for (uint256 i = 0; i< balances.size(); i += 1) {\r\n            address tokenHolder = balances.getKeyByIndex(i);\r\n            if (approvedDividends[tokenHolder] > 0)\r\n            {\r\n                tokenHolder.transfer(approvedDividends[tokenHolder]);\r\n                DividendsTransfered (tokenHolder, approvedDividends[tokenHolder]);\r\n                approvedDividends[tokenHolder] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(uint amount) public onlyOwner{\r\n        IceRockMiningAddress.transfer(amount);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"approvedDividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferAllDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setCurrentExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalDividendsAmount\",\"type\":\"uint256\"}],\"name\":\"approveDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnUnsold\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"send\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendsTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "IceRockMining", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://74542cd91454a45bd8516bd955edac36b5cb8bd794e894a7ef1f218ad7c1d562"}]}