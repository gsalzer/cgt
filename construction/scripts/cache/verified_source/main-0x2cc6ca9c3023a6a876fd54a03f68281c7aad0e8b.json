{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.13;\r\n\r\ncontract ComplianceService {\r\n\tfunction validate(address _from, address _to, uint256 _amount) public returns (bool allowed) {\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract ERC20 {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _amount) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\tfunction totalSupply() public constant returns (uint);\r\n}\r\n\r\ncontract HardcodedWallets {\r\n\t// **** DATA\r\n\r\n\taddress public walletFounder1; // founder #1 wallet, CEO, compulsory\r\n\taddress public walletFounder2; // founder #2 wallet\r\n\taddress public walletFounder3; // founder #3 wallet\r\n\taddress public walletCommunityReserve;\t// Distribution wallet\r\n\taddress public walletCompanyReserve;\t// Distribution wallet\r\n\taddress public walletTeamAdvisors;\t\t// Distribution wallet\r\n\taddress public walletBountyProgram;\t\t// Distribution wallet\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\r\n\t/**\r\n\t * @notice Constructor, set up the compliance officer oracle wallet\r\n\t */\r\n\tconstructor() public {\r\n\t\t// set up the founders' oracle wallets\r\n\t\twalletFounder1             = 0x5E69332F57Ac45F5fCA43B6b007E8A7b138c2938; // founder #1 (CEO) wallet\r\n\t\twalletFounder2             = 0x852f9a94a29d68CB95Bf39065BED6121ABf87607; // founder #2 wallet\r\n\t\twalletFounder3             = 0x0a339965e52dF2c6253989F5E9173f1F11842D83; // founder #3 wallet\r\n\r\n\t\t// set up the wallets for distribution of the total supply of tokens\r\n\t\twalletCommunityReserve = 0xB79116a062939534042d932fe5DF035E68576547;\r\n\t\twalletCompanyReserve = 0xA6845689FE819f2f73a6b9C6B0D30aD6b4a006d8;\r\n\t\twalletTeamAdvisors = 0x0227038b2560dF1abf3F8C906016Af0040bc894a;\r\n\t\twalletBountyProgram = 0xdd401Df9a049F6788cA78b944c64D21760757D73;\r\n\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract System {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\taddress owner;\r\n\t\r\n\t// **** MODIFIERS\r\n\r\n\t// @notice To limit functions usage to contract owner\r\n\tmodifier onlyOwner() {\r\n\t\tif (msg.sender != owner) {\r\n\t\t\terror('System: onlyOwner function called by user that is not owner');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\t// **** FUNCTIONS\r\n\t\r\n\t// @notice Calls whenever an error occurs, logs it or reverts transaction\r\n\tfunction error(string _error) internal {\r\n\t\trevert(_error);\r\n\t\t// in case revert with error msg is not yet fully supported\r\n\t\t//\temit Error(_error);\r\n\t\t// throw;\r\n\t}\r\n\r\n\t// @notice For debugging purposes when using solidity online browser, remix and sandboxes\r\n\tfunction whoAmI() public constant returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\t\r\n\t// @notice Get the current timestamp from last mined block\r\n\tfunction timestamp() public constant returns (uint256) {\r\n\t\treturn block.timestamp;\r\n\t}\r\n\t\r\n\t// @notice Get the balance in weis of this contract\r\n\tfunction contractBalance() public constant returns (uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\t\r\n\t// @notice System constructor, defines owner\r\n\tconstructor() public {\r\n\t\t// This is the constructor, so owner should be equal to msg.sender, and this method should be called just once\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\t// make sure owner address is configured\r\n\t\tif(owner == 0x0) error('System constructor: Owner address is 0x0'); // Never should happen, but just in case...\r\n\t}\r\n\t\r\n\t// **** EVENTS\r\n\r\n\t// @notice A generic error log\r\n\tevent Error(string _error);\r\n\r\n\t// @notice For debug purposes\r\n\tevent DebugUint256(uint256 _data);\r\n\r\n}\r\n\r\ncontract Escrow is System, HardcodedWallets {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// **** DATA\r\n\tmapping (address => uint256) public deposited;\r\n\tuint256 nextStage;\r\n\r\n\t// Circular reference to ICO contract\r\n\taddress public addressSCICO;\r\n\r\n\t// Circular reference to Tokens contract\r\n\taddress public addressSCTokens;\r\n\tTokens public SCTokens;\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\r\n\t/**\r\n\t * @notice Constructor, set up the state\r\n\t */\r\n\tconstructor() public {\r\n\t\t// copy totalSupply from Tokens to save gas\r\n\t\tuint256 totalSupply = 1350000000 ether;\r\n\r\n\r\n\t\tdeposited[this] = totalSupply.mul(50).div(100);\r\n\t\tdeposited[walletCommunityReserve] = totalSupply.mul(20).div(100);\r\n\t\tdeposited[walletCompanyReserve] = totalSupply.mul(14).div(100);\r\n\t\tdeposited[walletTeamAdvisors] = totalSupply.mul(15).div(100);\r\n\t\tdeposited[walletBountyProgram] = totalSupply.mul(1).div(100);\r\n\t}\r\n\r\n\tfunction deposit(uint256 _amount) public returns (bool) {\r\n\t\t// only ICO could deposit\r\n\t\tif (msg.sender != addressSCICO) {\r\n\t\t\terror('Escrow: not allowed to deposit');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdeposited[this] = deposited[this].add(_amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraw funds from the tokens contract\r\n\t */\r\n\tfunction withdraw(address _address, uint256 _amount) public onlyOwner returns (bool) {\r\n\t\tif (deposited[_address]<_amount) {\r\n\t\t\terror('Escrow: not enough balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdeposited[_address] = deposited[_address].sub(_amount);\r\n\t\treturn SCTokens.transfer(_address, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraw funds from the tokens contract\r\n\t */\r\n\tfunction fundICO(uint256 _amount, uint8 _stage) public returns (bool) {\r\n\t\tif(nextStage !=_stage) {\r\n\t\t\terror('Escrow: ICO stage already funded');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (msg.sender != addressSCICO || tx.origin != owner) {\r\n\t\t\terror('Escrow: not allowed to fund the ICO');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (deposited[this]<_amount) {\r\n\t\t\terror('Escrow: not enough balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tbool success = SCTokens.transfer(addressSCICO, _amount);\r\n\t\tif(success) {\r\n\t\t\tdeposited[this] = deposited[this].sub(_amount);\r\n\t\t\tnextStage++;\r\n\t\t\temit FundICO(addressSCICO, _amount);\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\r\n\t/**\r\n \t* @notice The owner can specify which ICO contract is allowed to transfer tokens while timelock is on\r\n \t*/\r\n\tfunction setMyICOContract(address _SCICO) public onlyOwner {\r\n\t\taddressSCICO = _SCICO;\r\n\t}\r\n\r\n\t/**\r\n \t* @notice Set the tokens contract\r\n \t*/\r\n\tfunction setTokensContract(address _addressSCTokens) public onlyOwner {\r\n\t\taddressSCTokens = _addressSCTokens;\r\n\t\tSCTokens = Tokens(_addressSCTokens);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Returns balance of given address\r\n\t */\r\n\tfunction balanceOf(address _address) public constant returns (uint256 balance) {\r\n\t\treturn deposited[_address];\r\n\t}\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when an investor buys some tokens directly with Ethers\r\n\tevent FundICO(address indexed _addressICO, uint256 _amount);\r\n\r\n\r\n}\r\n\r\ncontract RefundVault is HardcodedWallets, System {\r\n\tusing SafeMath for uint256;\r\n\r\n\tenum State { Active, Refunding, Closed }\r\n\r\n\r\n\t// **** DATA\r\n\r\n\tmapping (address => uint256) public deposited;\r\n\tmapping (address => uint256) public tokensAcquired;\r\n\tState public state;\r\n\r\n\t// Circular reference to ICO contract\r\n\taddress public addressSCICO;\r\n\t\r\n\t\r\n\r\n\t// **** MODIFIERS\r\n\r\n\t// @notice To limit functions usage to contract owner\r\n\tmodifier onlyICOContract() {\r\n\t\tif (msg.sender != addressSCICO) {\r\n\t\t\terror('RefundVault: onlyICOContract function called by user that is not ICOContract');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\r\n\t/**\r\n\t * @notice Constructor, set up the state\r\n\t */\r\n\tconstructor() public {\r\n\t\tstate = State.Active;\r\n\t}\r\n\r\n\tfunction weisDeposited(address _investor) public constant returns (uint256) {\r\n\t\treturn deposited[_investor];\r\n\t}\r\n\r\n\tfunction getTokensAcquired(address _investor) public constant returns (uint256) {\r\n\t\treturn tokensAcquired[_investor];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Registers how many tokens have each investor and how many ethers they spent (When ICOing through PayIn this function is not called)\r\n\t */\r\n\tfunction deposit(address _investor, uint256 _tokenAmount) onlyICOContract public payable returns (bool) {\r\n\t\tif (state != State.Active) {\r\n\t\t\terror('deposit: state != State.Active');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdeposited[_investor] = deposited[_investor].add(msg.value);\r\n\t\ttokensAcquired[_investor] = tokensAcquired[_investor].add(_tokenAmount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice When ICO finalizes funds are transferred to founders' wallets\r\n\t */\r\n\tfunction close() onlyICOContract public returns (bool) {\r\n\t\tif (state != State.Active) {\r\n\t\t\terror('close: state != State.Active');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tstate = State.Closed;\r\n\r\n\t\twalletFounder1.transfer(address(this).balance.mul(33).div(100)); // Forwards 33% to 1st founder wallet\r\n\t\twalletFounder2.transfer(address(this).balance.mul(50).div(100)); // Forwards 33% to 2nd founder wallet\r\n\t\twalletFounder3.transfer(address(this).balance);                  // Forwards 34% to 3rd founder wallet\r\n\r\n\t\temit Closed(); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice When ICO finalizes owner toggles refunding\r\n\t */\r\n\tfunction enableRefunds() onlyICOContract public returns (bool) {\r\n\t\tif (state != State.Active) {\r\n\t\t\terror('enableRefunds: state != State.Active');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tstate = State.Refunding;\r\n\r\n\t\temit RefundsEnabled(); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice ICO Smart Contract can call this function for the investor to refund\r\n\t */\r\n\tfunction refund(address _investor) onlyICOContract public returns (bool) {\r\n\t\tif (state != State.Refunding) {\r\n\t\t\terror('refund: state != State.Refunding');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (deposited[_investor] == 0) {\r\n\t\t\terror('refund: no deposit to refund');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tuint256 depositedValue = deposited[_investor];\r\n\t\tdeposited[_investor] = 0;\r\n\t\ttokensAcquired[_investor] = 0; // tokens should have been returned previously to the ICO\r\n\t\t_investor.transfer(depositedValue);\r\n\r\n\t\temit Refunded(_investor, depositedValue); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice To allow ICO contracts to check whether RefundVault is ready to refund investors\r\n\t */\r\n\tfunction isRefunding() public constant returns (bool) {\r\n\t\treturn (state == State.Refunding);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The owner must specify which ICO contract is allowed call for refunds\r\n\t */\r\n\tfunction setMyICOContract(address _SCICO) public onlyOwner {\r\n\t\trequire(address(this).balance == 0);\r\n\t\taddressSCICO = _SCICO;\r\n\t}\r\n\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when ICO contract closes the vault and forwards funds to the founders' wallets\r\n\tevent Closed();\r\n\r\n\t// Triggered when ICO contract initiates refunding\r\n\tevent RefundsEnabled();\r\n\r\n\t// Triggered when an investor claims (through ICO contract) and gets its funds\r\n\tevent Refunded(address indexed beneficiary, uint256 weiAmount);\r\n}\r\n\r\ncontract Haltable is System {\r\n\tbool public halted;\r\n\t\r\n\t// **** MODIFIERS\r\n\r\n\tmodifier stopInEmergency {\r\n\t\tif (halted) {\r\n\t\t\terror('Haltable: stopInEmergency function called and contract is halted');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\tmodifier onlyInEmergency {\r\n\t\tif (!halted) {\r\n\t\t\terror('Haltable: onlyInEmergency function called and contract is not halted');\r\n\t\t} {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\t// **** FUNCTIONS\r\n\t\r\n\t// called by the owner on emergency, triggers stopped state\r\n\tfunction halt() external onlyOwner {\r\n\t\thalted = true;\r\n\t\temit Halt(true, msg.sender, timestamp()); // Event log\r\n\t}\r\n\r\n\t// called by the owner on end of emergency, returns to normal state\r\n\tfunction unhalt() external onlyOwner onlyInEmergency {\r\n\t\thalted = false;\r\n\t\temit Halt(false, msg.sender, timestamp()); // Event log\r\n\t}\r\n\t\r\n\t// **** EVENTS\r\n\t// @notice Triggered when owner halts contract\r\n\tevent Halt(bool _switch, address _halter, uint256 _timestamp);\r\n}\r\n\r\ncontract ICO is HardcodedWallets, Haltable {\r\n\t// **** DATA\r\n\r\n\t// Linked Contracts\r\n\tTokens public SCTokens;\t// The token being sold\r\n\tRefundVault public SCRefundVault;\t// The vault for softCap refund\r\n\tWhitelist public SCWhitelist;\t// The whitelist of allowed wallets to buy tokens on ICO\r\n\tEscrow public SCEscrow; // Escrow service\r\n\r\n\t// start and end timestamps where investments are allowed (both inclusive)\r\n\tuint256 public startTime;\r\n\tuint256 public endTime;\r\n\tbool public isFinalized = false;\r\n\r\n\tuint256 public weisPerBigToken; // how many weis a buyer pays to get a big token (10^18 tokens)\r\n\tuint256 public weisPerEther;\r\n\tuint256 public tokensPerEther; // amount of tokens with multiplier received on ICO when paying with 1 Ether, discounts included\r\n\tuint256 public bigTokensPerEther; // amount of tokens w/omultiplier received on ICO when paying with 1 Ether, discounts included\r\n\r\n\tuint256 public weisRaised; // amount of Weis raised\r\n\tuint256 public etherHardCap; // Max amount of Ethers to raise\r\n\tuint256 public tokensHardCap; // Max amount of Tokens for sale\r\n\tuint256 public weisHardCap; // Max amount of Weis raised\r\n\tuint256 public weisMinInvestment; // Min amount of Weis to perform a token sale\r\n\tuint256 public etherSoftCap; // Min amount of Ethers for sale to ICO become successful\r\n\tuint256 public tokensSoftCap; // Min amount of Tokens for sale to ICO become successful\r\n\tuint256 public weisSoftCap; // Min amount of Weis raised to ICO become successful\r\n\r\n\tuint256 public discount; // Applies to token price when investor buys tokens. It is a number between 0-100\r\n\tuint256 discountedPricePercentage;\r\n\tuint8 ICOStage;\r\n\r\n\r\n\r\n\t// **** MODIFIERS\r\n\r\n\t\r\n\t// **** FUNCTIONS\r\n\r\n\t// fallback function can be used to buy tokens\r\n\tfunction () payable public {\r\n\t\tbuyTokens();\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * @notice Token purchase function direclty through ICO Smart Contract. Beneficiary = msg.sender\r\n\t */\r\n\tfunction buyTokens() public stopInEmergency payable returns (bool) {\r\n\t\tif (msg.value == 0) {\r\n\t\t\terror('buyTokens: ZeroPurchase');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tuint256 tokenAmount = buyTokensLowLevel(msg.sender, msg.value);\r\n\r\n\t\t// Send the investor's ethers to the vault\r\n\t\tif (!SCRefundVault.deposit.value(msg.value)(msg.sender, tokenAmount)) {\r\n\t\t\trevert('buyTokens: unable to transfer collected funds from ICO contract to Refund Vault'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokens: unable to transfer collected funds from ICO contract to Refund Vault');\r\n\t\t\t// return false;\r\n\t\t}\r\n\r\n\t\temit BuyTokens(msg.sender, msg.value, tokenAmount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Token purchase function through Oracle PayIn by MarketPay.io API\r\n\t */\r\n\t/* // Deactivated to save ICO contract deployment gas cost\r\n\tfunction buyTokensOraclePayIn(address _beneficiary, uint256 _weisAmount) public onlyCustodyFiat stopInEmergency returns (bool) {\r\n\t\tuint256 tokenAmount = buyTokensLowLevel(_beneficiary, _weisAmount);\r\n\r\n\t\temit BuyTokensOraclePayIn(msg.sender, _beneficiary, _weisAmount, tokenAmount); // Event log\r\n\r\n\t\treturn true;\r\n\t}*/\r\n\r\n\t/**\r\n\t * @notice Low level token purchase function, w/o ether transfer from investor\r\n\t */\r\n\tfunction buyTokensLowLevel(address _beneficiary, uint256 _weisAmount) private stopInEmergency returns (uint256 tokenAmount) {\r\n\t\tif (_beneficiary == 0x0) {\r\n\t\t\trevert('buyTokensLowLevel: _beneficiary == 0x0'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: _beneficiary == 0x0');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\t\tif (timestamp() < startTime || timestamp() > endTime) {\r\n\t\t\trevert('buyTokensLowLevel: Not withinPeriod'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: Not withinPeriod');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\t\tif (!SCWhitelist.isInvestor(_beneficiary)) {\r\n\t\t\trevert('buyTokensLowLevel: Investor is not registered on the whitelist'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: Investor is not registered on the whitelist');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\t\tif (isFinalized) {\r\n\t\t\trevert('buyTokensLowLevel: ICO is already finalized'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: ICO is already finalized');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\t// Verify whether enough ether has been sent to buy the min amount of investment\r\n\t\tif (_weisAmount < weisMinInvestment) {\r\n\t\t\trevert('buyTokensLowLevel: Minimal investment not reached. Not enough ethers to perform the minimal purchase'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: Minimal investment not reached. Not enough ethers to perform the minimal purchase');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\t// Verify whether there are enough tokens to sell\r\n\t\tif (weisRaised.add(_weisAmount) > weisHardCap) {\r\n\t\t\trevert('buyTokensLowLevel: HardCap reached. Not enough tokens on ICO contract to perform this purchase'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: HardCap reached. Not enough tokens on ICO contract to perform this purchase');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\r\n\t\t// Calculate token amount to be sold\r\n\t\ttokenAmount = _weisAmount.mul(weisPerEther).div(weisPerBigToken);\r\n\r\n\t\t// Applying discount\r\n\t\ttokenAmount = tokenAmount.mul(100).div(discountedPricePercentage);\r\n\r\n\t\t// Update state\r\n\t\tweisRaised = weisRaised.add(_weisAmount);\r\n\r\n\t\t// Send the tokens to the investor\r\n\t\tif (!SCTokens.transfer(_beneficiary, tokenAmount)) {\r\n\t\t\trevert('buyTokensLowLevel: unable to transfer tokens from ICO contract to beneficiary'); // Revert needed to refund investor on error\r\n\t\t\t// error('buyTokensLowLevel: unable to transfer tokens from ICO contract to beneficiary');\r\n\t\t\t// return 0;\r\n\t\t}\r\n\t\temit BuyTokensLowLevel(msg.sender, _beneficiary, _weisAmount, tokenAmount); // Event log\r\n\r\n\t\treturn tokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @return true if ICO event has ended\r\n\t */\r\n\t/* // Deactivated to save ICO contract deployment gas cost\r\n\tfunction hasEnded() public constant returns (bool) {\r\n\t\treturn timestamp() > endTime;\r\n\t}*/\r\n\r\n\t/**\r\n\t * @notice Called by owner to alter the ICO deadline\r\n\t */\r\n\tfunction updateEndTime(uint256 _endTime) onlyOwner public returns (bool) {\r\n\t\tendTime = _endTime;\r\n\r\n\t\temit UpdateEndTime(_endTime); // Event log\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @notice Must be called by owner before or after ICO ends, to check whether soft cap is reached and transfer collected funds\r\n\t */\r\n\tfunction finalize(bool _forceRefund) onlyOwner public returns (bool) {\r\n\t\tif (isFinalized) {\r\n\t\t\terror('finalize: ICO is already finalized.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (weisRaised >= weisSoftCap && !_forceRefund) {\r\n\t\t\tif (!SCRefundVault.close()) {\r\n\t\t\t\terror('finalize: SCRefundVault.close() failed');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!SCRefundVault.enableRefunds()) {\r\n\t\t\t\terror('finalize: SCRefundVault.enableRefunds() failed');\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif(_forceRefund) {\r\n\t\t\t\temit ForceRefund(); // Event log\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Move remaining ICO tokens back to the Escrow\r\n\t\tuint256 balanceAmount = SCTokens.balanceOf(this);\r\n\t\tif (!SCTokens.transfer(address(SCEscrow), balanceAmount)) {\r\n\t\t\terror('finalize: unable to return remaining ICO tokens');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Adjust Escrow balance correctly\r\n\t\tif(!SCEscrow.deposit(balanceAmount)) {\r\n\t\t\terror('finalize: unable to return remaining ICO tokens');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tisFinalized = true;\r\n\r\n\t\temit Finalized(); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice If ICO is unsuccessful, investors can claim refunds here\r\n\t */\r\n\tfunction claimRefund() public stopInEmergency returns (bool) {\r\n\t\tif (!isFinalized) {\r\n\t\t\terror('claimRefund: ICO is not yet finalized.');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!SCRefundVault.isRefunding()) {\r\n\t\t\terror('claimRefund: RefundVault state != State.Refunding');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Before transfering the ETHs to the investor, get back the tokens bought on ICO\r\n\t\tuint256 tokenAmount = SCRefundVault.getTokensAcquired(msg.sender);\r\n\t\temit GetBackTokensOnRefund(msg.sender, this, tokenAmount); // Event Log\r\n\t\tif (!SCTokens.refundTokens(msg.sender, tokenAmount)) {\r\n\t\t\terror('claimRefund: unable to transfer investor tokens to ICO contract before refunding');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (!SCRefundVault.refund(msg.sender)) {\r\n\t\t\terror('claimRefund: SCRefundVault.refund() failed');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction fundICO() public onlyOwner {\r\n\t\tif (!SCEscrow.fundICO(tokensHardCap, ICOStage)) {\r\n\t\t\trevert('ICO funding failed');\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\r\n// **** EVENTS\r\n\r\n\t// Triggered when an investor buys some tokens directly with Ethers\r\n\tevent BuyTokens(address indexed _purchaser, uint256 _value, uint256 _amount);\r\n\r\n\t// Triggered when Owner says some investor has requested tokens on PayIn MarketPay.io API\r\n\tevent BuyTokensOraclePayIn(address indexed _purchaser, address indexed _beneficiary, uint256 _weisAmount, uint256 _tokenAmount);\r\n\r\n\t// Triggered when an investor buys some tokens directly with Ethers or through payin Oracle\r\n\tevent BuyTokensLowLevel(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);\r\n\r\n\t// Triggered when an SC owner request to end the ICO, transferring funds to founders wallet or ofeering them as a refund\r\n\tevent Finalized();\r\n\r\n\t// Triggered when an SC owner request to end the ICO and allow transfer of funds to founders wallets as a refund\r\n\tevent ForceRefund();\r\n\r\n\t// Triggered when RefundVault is created\r\n\t//event AddressSCRefundVault(address _scAddress);\r\n\r\n\t// Triggered when investor refund and their tokens got back to ICO contract\r\n\tevent GetBackTokensOnRefund(address _from, address _to, uint256 _amount);\r\n\r\n\t// Triggered when Owner updates ICO deadlines\r\n\tevent UpdateEndTime(uint256 _endTime);\r\n}\r\n\r\ncontract ICOPreSale is ICO {\r\n\t/**\r\n\t * @notice ICO constructor. Definition of ICO parameters and subcontracts autodeployment\r\n\t */\r\n\tconstructor(address _SCEscrow, address _SCTokens, address _SCWhitelist, address _SCRefundVault) public {\r\n\t\tif (_SCTokens == 0x0) {\r\n\t\t\trevert('Tokens Constructor: _SCTokens == 0x0');\r\n\t\t}\r\n\t\tif (_SCWhitelist == 0x0) {\r\n\t\t\trevert('Tokens Constructor: _SCWhitelist == 0x0');\r\n\t\t}\r\n\t\tif (_SCRefundVault == 0x0) {\r\n\t\t\trevert('Tokens Constructor: _SCRefundVault == 0x0');\r\n\t\t}\r\n\t\t\r\n\t\tSCTokens = Tokens(_SCTokens);\r\n\t\tSCWhitelist = Whitelist(_SCWhitelist);\r\n\t\tSCRefundVault = RefundVault(_SCRefundVault);\r\n\t\t\r\n\t\tweisPerEther = 1 ether; // 10e^18 multiplier\r\n\r\n\t\t// Deadline\r\n\t\tstartTime = timestamp();\r\n\t\tendTime = timestamp().add(24 days); // from 8th June to 2th July 2018\r\n\r\n\t\t// Token Price\r\n\t\tbigTokensPerEther = 7500; // tokens (w/o multiplier) got for 1 ether\r\n\t\ttokensPerEther = bigTokensPerEther.mul(weisPerEther); // tokens (with multiplier) got for 1 ether\r\n\r\n\t\tdiscount = 45; // pre-sale 45%\r\n\t\tdiscountedPricePercentage = 100;\r\n\t\tdiscountedPricePercentage = discountedPricePercentage.sub(discount);\r\n\r\n\t\tweisMinInvestment = weisPerEther.mul(1);\r\n\r\n\t\t// 2018-05-10: alvaro.ariet@lacomunity.com Los Hardcap que indicas no son los \u00faltimos comentados. Los correctos ser\u00edan:\r\n\t\t//    Pre-Sale:     8.470 ETH\r\n\t\t//    1st Tier:       8.400 ETH\r\n\t\t//    2nd Tier:     68.600 ETH\r\n\r\n\t\t// HardCap\r\n\t\t// etherHardCap = 8500; // As of 2018-05-09 => Hardcap pre sale: 8.500 ETH\r\n\t\t // As of 2018-05-10 => Pre-Sale:     8.470 ETH\r\n\t\tetherHardCap = 8067; // As of 2018-05-24 => Pre-Sale:     8067 ETH\r\n\t\ttokensHardCap = tokensPerEther.mul(etherHardCap).mul(100).div(discountedPricePercentage);\r\n\r\n\t\tweisPerBigToken = weisPerEther.div(bigTokensPerEther);\r\n\t\t// weisHardCap = weisPerBigToken.mul(tokensHardCap).div(weisPerEther);\r\n\t\tweisHardCap = weisPerEther.mul(etherHardCap);\r\n\r\n\t\t// SoftCap\r\n\t\tetherSoftCap = 750; // As of 2018-05-09 => Softcap pre sale: 750 ETH\r\n\t\tweisSoftCap = weisPerEther.mul(etherSoftCap);\r\n\r\n\t\tSCEscrow = Escrow(_SCEscrow);\r\n\r\n\t\tICOStage = 0;\r\n\t}\r\n\r\n}\r\n\r\ncontract Tokens is HardcodedWallets, ERC20, Haltable {\r\n\r\n\t// **** DATA\r\n\r\n\tmapping (address => uint256) balances;\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\tuint256 public _totalSupply; \r\n\r\n\t// Public variables of the token, all used for display\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tstring public standard = 'H0.1'; // HumanStandardToken is a specialisation of ERC20 defining these parameters\r\n\r\n\t// Timelock\r\n\tuint256 public timelockEndTime;\r\n\r\n\t// Circular reference to ICO contract\r\n\taddress public addressSCICO;\r\n\r\n\t// Circular reference to Escrow contract\r\n\taddress public addressSCEscrow;\r\n\r\n\t// Reference to ComplianceService contract\r\n\taddress public addressSCComplianceService;\r\n\tComplianceService public SCComplianceService;\r\n\r\n\t// **** MODIFIERS\r\n\r\n\t// @notice To limit token transfers while timelocked\r\n\tmodifier notTimeLocked() {\r\n\t\tif (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {\r\n\t\t\terror('notTimeLocked: Timelock still active. Function is yet unavailable.');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\t/**\r\n\t * @notice Constructor: set up token properties and owner token balance\r\n\t */\r\n\tconstructor(address _addressSCEscrow, address _addressSCComplianceService) public {\r\n\t\tname = \"TheRentalsToken\";\r\n\t\tsymbol = \"TRT\";\r\n\t\tdecimals = 18; // 18 decimal places, the same as ETH\r\n\r\n\t\t// initialSupply = 2000000000 ether; // 2018-04-21: ICO summary.docx: ...Dicho valor generar\u00eda un Total Supply de 2.000 millones de TRT.\r\n        _totalSupply = 1350000000 ether; // 2018-05-10: alvaro.ariet@lacomunity.com ...tenemos una emisi\u00f3n de 1.350 millones de Tokens\r\n\r\n\t\ttimelockEndTime = timestamp().add(45 days); // Default timelock\r\n\r\n\t\taddressSCEscrow = _addressSCEscrow;\r\n\t\taddressSCComplianceService = _addressSCComplianceService;\r\n\t\tSCComplianceService = ComplianceService(addressSCComplianceService);\r\n\r\n\t\t// Token distribution\r\n\t\tbalances[_addressSCEscrow] = _totalSupply;\r\n\t\temit Transfer(0x0, _addressSCEscrow, _totalSupply);\r\n\r\n\t}\r\n\r\n    /**\r\n     * @notice Get the token total supply\r\n     */\r\n    function totalSupply() public constant returns (uint) {\r\n\r\n        return _totalSupply  - balances[address(0)];\r\n\r\n    }\r\n\r\n\t/**\r\n\t * @notice Get the token balance of a wallet with address _owner\r\n\t */\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Send _amount amount of tokens to address _to\r\n\t */\r\n\tfunction transfer(address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n\t\tif (balances[msg.sender] < _amount) {\r\n\t\t\terror('transfer: the amount to transfer is higher than your token balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(!SCComplianceService.validate(msg.sender, _to, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_amount);\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\temit Transfer(msg.sender, _to, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Send _amount amount of tokens from address _from to address _to\r\n \t * @notice The transferFrom method is used for a withdraw workflow, allowing contracts to send \r\n \t * @notice tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge \r\n \t * @notice fees in sub-currencies; the command should fail unless the _from account has \r\n \t * @notice deliberately authorized the sender of the message via some mechanism\r\n \t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n\t\tif (balances[_from] < _amount) {\r\n\t\t\terror('transferFrom: the amount to transfer is higher than the token balance of the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (allowed[_from][msg.sender] < _amount) {\r\n\t\t\terror('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(!SCComplianceService.validate(_from, _to, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_amount);\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n\t\temit Transfer(_from, _to, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Allow _spender to withdraw from your account, multiple times, up to the _amount amount. \r\n \t * @notice If this function is called again it overwrites the current allowance with _amount.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _amount) public returns (bool success) {\r\n\t\tallowed[msg.sender][_spender] = _amount;\r\n\t\temit Approval(msg.sender, _spender, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n       * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n       *\r\n       * approve should be called when allowed[_spender] == 0. To increment\r\n       * allowed value is better to use this function to avoid 2 calls (and wait until\r\n       * the first transaction is mined)\r\n       * From MonolithDAO Token.sol\r\n       * @param _spender The address which will spend the funds.\r\n       * @param _addedValue The amount of tokens to increase the allowance by.\r\n       */\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice This is out of ERC20 standard but it is necessary to build market escrow contracts of assets\r\n\t * @notice Send _amount amount of tokens to from tx.origin to address _to\r\n\t */\r\n\tfunction refundTokens(address _from, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n        if (tx.origin != _from) {\r\n            error('refundTokens: tx.origin did not request the refund directly');\r\n            return false;\r\n        }\r\n\r\n        if (addressSCICO != msg.sender) {\r\n            error('refundTokens: caller is not the current ICO address');\r\n            return false;\r\n        }\r\n\r\n        if (balances[_from] < _amount) {\r\n            error('refundTokens: the amount to transfer is higher than your token balance');\r\n            return false;\r\n        }\r\n\r\n        if(!SCComplianceService.validate(_from, addressSCICO, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_amount);\r\n\t\tbalances[addressSCICO] = balances[addressSCICO].add(_amount);\r\n\t\temit Transfer(_from, addressSCICO, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The owner can specify which ICO contract is allowed to transfer tokens while timelock is on\r\n\t */\r\n\tfunction setMyICOContract(address _SCICO) public onlyOwner {\r\n\t\taddressSCICO = _SCICO;\r\n\t}\r\n\r\n\tfunction setComplianceService(address _addressSCComplianceService) public onlyOwner {\r\n\t\taddressSCComplianceService = _addressSCComplianceService;\r\n\t\tSCComplianceService = ComplianceService(addressSCComplianceService);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Called by owner to alter the token timelock\r\n\t */\r\n\tfunction updateTimeLock(uint256 _timelockEndTime) onlyOwner public returns (bool) {\r\n\t\ttimelockEndTime = _timelockEndTime;\r\n\r\n\t\temit UpdateTimeLock(_timelockEndTime); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when tokens are transferred\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n\t// Triggered when someone approves a spender to move its tokens\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n\r\n\t// Triggered when Owner updates token timelock\r\n\tevent UpdateTimeLock(uint256 _timelockEndTime);\r\n}\r\n\r\ncontract Whitelist is HardcodedWallets, System {\r\n\t// **** DATA\r\n\r\n\tmapping (address => bool) public walletsICO;\r\n\tmapping (address => bool) public managers;\r\n\r\n\t// Checks whether a given wallet is authorized to ICO investing\r\n\tfunction isInvestor(address _wallet) public constant returns (bool) {\r\n\t\treturn (walletsICO[_wallet]);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Registers an investor\r\n\t */\r\n\tfunction addInvestor(address _wallet) external isManager returns (bool) {\r\n\t\t// Checks whether this wallet has been previously added as an investor\r\n\t\tif (walletsICO[_wallet]) {\r\n\t\t\terror('addInvestor: this wallet has been previously granted as ICO investor');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\twalletsICO[_wallet] = true;\r\n\r\n\t\temit AddInvestor(_wallet, timestamp()); // Event log\r\n\t\treturn true;\r\n\t}\r\n\r\n\tmodifier isManager(){\r\n\t\tif (managers[msg.sender] || msg.sender == owner) {\r\n\t\t\t_;\r\n\t\t} else {\r\n\t\t\terror(\"isManager: called by user that is not owner or manager\");\r\n\t\t}\r\n\t}\r\n\r\n\t// adds an address that will have the right to add investors\r\n\tfunction addManager(address _managerAddr) external onlyOwner returns (bool) {\r\n\t\tif(managers[_managerAddr]){\r\n\t\t\terror(\"addManager: manager account already exists.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tmanagers[_managerAddr] = true;\r\n\r\n\t\temit AddManager(_managerAddr, timestamp());\r\n\t}\r\n\r\n\t// removes a manager address\r\n\tfunction delManager(address _managerAddr) external onlyOwner returns (bool) {\r\n\t\tif(!managers[_managerAddr]){\r\n\t\t\terror(\"delManager: manager account not found.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tdelete managers[_managerAddr];\r\n\r\n\t\temit DelManager(_managerAddr, timestamp());\r\n\t}\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when a wallet is granted to become an ICO investor\r\n\tevent AddInvestor(address indexed _wallet, uint256 _timestamp);\r\n\t// Triggered when a manager is added\r\n\tevent AddManager(address indexed _managerAddr, uint256 _timestamp);\r\n\t// Triggered when a manager is removed\r\n\tevent DelManager(address indexed _managerAddr, uint256 _timestamp);\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletCommunityReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisPerBigToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletTeamAdvisors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisMinInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"updateEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"discount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_forceRefund\",\"type\":\"bool\"}],\"name\":\"finalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletCompanyReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bigTokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCRefundVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weisRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoAmI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoftCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletBountyProgram\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_SCEscrow\",\"type\":\"address\"},{\"name\":\"_SCTokens\",\"type\":\"address\"},{\"name\":\"_SCWhitelist\",\"type\":\"address\"},{\"name\":\"_SCRefundVault\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BuyTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_weisAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"BuyTokensOraclePayIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BuyTokensLowLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ForceRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"GetBackTokensOnRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"UpdateEndTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_switch\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_halter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Halt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_error\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_data\",\"type\":\"uint256\"}],\"name\":\"DebugUint256\",\"type\":\"event\"}]", "ContractName": "ICOPreSale", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000591621e47e0f929f8dbece49ea23e42537944b740000000000000000000000003bb3354f82654dd609300e92c92cf2c7c1bf3171000000000000000000000000983d1874f6518c6d87b050b29fc47aeccae65d47000000000000000000000000e0678f1a95cd11af3f33e816f3efbbfc0140789e", "Library": "", "SwarmSource": "bzzr://e6ba9122799a535516e7eb197e079c2a554d4722124bc05e9d30f88c540941fe"}]}