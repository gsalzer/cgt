{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n *\r\n * LEPRECHAUN - ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n * Telegram bot - t.me/LeprechaunContractBot\r\n *\r\n *  - GAIN 2% PER 24 HOURS\r\n *  - Life-long payments\r\n *  - Contribution allocation schemes:\r\n *    -- 85% payments\r\n *    -- 15% marketing\r\n *\r\n * HOW TO USE:\r\n *  1. Send of ether to make an investment\r\n *  2a. Claim your profit by sending 0 ether transaction (every hour, every day, every week)\r\n *  OR\r\n *  2b. Send more ether to reinvest AND get your profit at the same time\r\n *\r\n * PARTNER PROGRAM:\r\n * At the moment of making the first deposit, the referral indicates in the DATA field the ETH address of the referrer's wallet,\r\n * and the referrer then receives 5% of the every attachments of the referral,\r\n * and the referral also immediately gets back 10% of his deposit\r\n *\r\n * NOTES:\r\n * All ETHs that you've sent will be added to your deposit.\r\n * In order to get an extra profit from your deposit, it is enough to send just 1 wei.\r\n * It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you\r\n * have private keys.\r\n *\r\n * RECOMMENDED GAS LIMIT: 300000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n *\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n\r\n        if (_a == 0) { return 0; }\r\n\r\n        c = _a * _b;\r\n        assert(c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return _a / _b;\r\n    }\r\n\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n        c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Storage  {\r\n\r\n    using SafeMath for uint;\r\n\r\n    uint public constant perDay = 2;\r\n    uint public constant fee = 15;\r\n    uint public constant bonusReferral = 10;\r\n    uint public constant bonusReferrer = 5;\r\n\r\n    uint public constant minimalDepositForBonusReferrer = 0.001 ether;\r\n\r\n    uint public countInvestors = 0;\r\n    uint public totalInvest = 0;\r\n    uint public totalPaid = 0;\r\n\r\n    struct User\r\n    {\r\n        uint balance;\r\n        uint paid;\r\n        uint timestamp;\r\n        uint countReferrals;\r\n        uint earnOnReferrals;\r\n        address referrer;\r\n    }\r\n\r\n    mapping (address => User) internal user;\r\n\r\n    function getAvailableBalance(address addr) internal view returns(uint) {\r\n        uint diffTime = user[addr].timestamp > 0 ? now.sub(user[addr].timestamp) : 0;\r\n        return user[addr].balance.mul(perDay).mul(diffTime).div(100).div(24 hours);\r\n    }\r\n\r\n    function getUser(address addr) public view returns(uint, uint, uint, uint, uint, address) {\r\n\r\n        return (\r\n            user[addr].balance,\r\n            user[addr].paid,\r\n            getAvailableBalance(addr),\r\n            user[addr].countReferrals,\r\n            user[addr].earnOnReferrals,\r\n            user[addr].referrer\r\n        );\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract Leprechaun is Storage {\r\n\r\n    address public owner = msg.sender;\r\n\r\n    modifier withDeposit() { if (msg.value > 0) { _; } }\r\n\r\n    function() public payable {\r\n\r\n        if (msg.sender == owner) { return; }\r\n\r\n        register();\r\n        sendFee();\r\n        sendReferrer();\r\n        sendPayment();\r\n        updateInvestBalance();\r\n    }\r\n\r\n\r\n    function register() internal withDeposit {\r\n\r\n        if (user[msg.sender].balance == 0) {\r\n\r\n            user[msg.sender].timestamp = now;\r\n            countInvestors++;\r\n\r\n            address referrer = bytesToAddress(msg.data);\r\n\r\n            if (user[referrer].balance > 0 && referrer != msg.sender) {\r\n                user[msg.sender].referrer = referrer;\r\n                user[referrer].countReferrals++;\r\n                transfer(msg.sender, msg.value.mul(bonusReferral).div(100));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function sendFee() internal withDeposit {\r\n        transfer(owner, msg.value.mul(fee).div(100));\r\n    }\r\n\r\n    function sendReferrer() internal withDeposit {\r\n\r\n        if (msg.value >= minimalDepositForBonusReferrer) {\r\n            address referrer = user[msg.sender].referrer;\r\n            if (user[referrer].balance > 0) {\r\n                uint amountReferrer = msg.value.mul(bonusReferrer).div(100);\r\n                user[referrer].earnOnReferrals = user[referrer].earnOnReferrals.add(amountReferrer);\r\n                transfer(referrer, amountReferrer);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function sendPayment() internal {\r\n\r\n        if (user[msg.sender].balance > 0) {\r\n            transfer(msg.sender, getAvailableBalance(msg.sender));\r\n            user[msg.sender].timestamp = now;\r\n        }\r\n\r\n    }\r\n\r\n    function updateInvestBalance() internal withDeposit {\r\n        user[msg.sender].balance = user[msg.sender].balance.add(msg.value);\r\n        totalInvest = totalInvest.add(msg.value);\r\n    }\r\n\r\n    function transfer(address receiver, uint amount) internal {\r\n\r\n        if (amount > 0) {\r\n\r\n            if (receiver != owner) { totalPaid = totalPaid.add(amount); }\r\n\r\n            user[receiver].paid = user[receiver].paid.add(amount);\r\n\r\n            if (amount > address(this).balance) {\r\n                selfdestruct(receiver);\r\n            } else {\r\n                receiver.transfer(amount);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function bytesToAddress(bytes source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"countInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"perDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusReferral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalDepositForBonusReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Leprechaun", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://92cbda6f00998e878dc00f1ba2d0300ba06a8d54d8fdba30bc6411f489fe936a"}]}