{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.6;\r\n\r\ncontract RegistrationDeposits { function register(address _registrant) payable {} }\r\n\r\ncontract ProofOfIndividuality { function submitVerifiedUsers(address[] _verifiedUsers) {} }\r\n\r\ncontract HangoutFactory { function newHangoutContract(address[] _hangoutGroup, address _registrationContract, uint _hangoutBegins, bytes32 _hangoutAddress) returns (address) {} }\r\n\r\ncontract Registration {\r\n    RegistrationDeposits public depositContract;\r\n    ProofOfIndividuality public POI;\r\n    HangoutFactory public hangoutFactory;\r\n    \r\n    uint public numUsers;\r\n    \r\n    mapping(address => bytes32) public userHash;\r\n    mapping(bytes32 => address) public userAddress;\r\n    mapping(address => uint) public userGroup;\r\n    mapping(uint => address[]) public hangoutGroups;\r\n    mapping(uint => address) public hangoutContract;\r\n    mapping(address => bool) isHangoutContract;\r\n    mapping(uint => bytes32) public hangoutAddress;\r\n\r\n\r\n    bytes32 maxHash = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    uint public groupSize;\r\n    bytes32 entropy;\r\n    \r\n    uint public depositSize;\r\n\r\n    event Registered(address userAddress, bytes32 userHash);\r\n    event Commitment(bytes32 userHash, uint group);\r\n\r\n    uint public registrationPhase;\r\n    uint public commitmentPhase;\r\n    uint public hangoutPhase;\r\n\r\n    function numGroups() constant returns(uint){ return numUsers / groupSize;}\r\n\r\n    function Registration(address _proofOfIndividuality, uint _groupSize, uint _depositSize, uint _registrationPhase, uint _commitmentPhase, uint _hangoutPhase, address _hangoutFactory){\r\n        groupSize = _groupSize;\r\n        depositSize = _depositSize;\r\n        entropy = sha3(block.blockhash(block.number));\r\n        registrationPhase = _registrationPhase;\r\n        commitmentPhase = _commitmentPhase;\r\n        hangoutPhase = _hangoutPhase;\r\n        hangoutFactory = HangoutFactory(_hangoutFactory);\r\n        POI = ProofOfIndividuality(_proofOfIndividuality);\r\n    }\r\n    function setDepositContract(address _depositContract) {\r\n        depositContract = RegistrationDeposits(_depositContract);\r\n    }\r\n\r\n    function register() payable returns(bool success){\r\n        if (now > registrationPhase // registation period over\r\n        || (userHash[msg.sender] != bytes32(0)) // already registered\r\n        || msg.value < depositSize) throw; \r\n        depositContract.register.value(msg.value)(msg.sender);\r\n        // generate a hash for the given user, using previous entropy, \r\n        // senders address and current blocknumber.\r\n        bytes32 h = sha3(entropy, msg.sender, block.blockhash(block.number));\r\n        entropy = h;\r\n        userHash[msg.sender] = h;\r\n        userAddress[h] = msg.sender;\r\n        numUsers++;\r\n        Registered(msg.sender, h);\r\n        return true;\r\n    }\r\n\r\n    function commit() {\r\n        if ((now < registrationPhase) // registation period not yet over\r\n        || (now > commitmentPhase) // commitment period over\r\n        || (userGroup[msg.sender] != 0)) throw; // group already assigned\r\n        \r\n        uint groupNumber = uint(userHash[msg.sender]) / (uint(maxHash) / numGroups()) + 1;\r\n    \r\n        if(hangoutGroups[groupNumber].length >= groupSize) {\r\n            for(uint i = 0; i < numGroups(); i++) {\r\n                if(groupNumber - i >= 1) {\r\n                    if(hangoutGroups[groupNumber - i].length < groupSize) { groupNumber -= i; break; }\r\n                }\r\n                if(groupNumber + i <= numGroups()) {\r\n                    if(hangoutGroups[groupNumber + i].length < groupSize) { groupNumber += i; break; }\r\n                }\r\n            }\r\n        }\r\n        userGroup[msg.sender] = groupNumber;\r\n        hangoutGroups[groupNumber].push(msg.sender);\r\n    }\r\n    \r\n    function deployHangout() public {\r\n        if ((now < commitmentPhase) // commitment period not yet over\r\n        || (now > hangoutPhase) // hangout period over\r\n        || (hangoutAddress[userGroup[msg.sender]] != 0)) throw; // hangout contract already deployed\r\n        \r\n        if(hangoutAddress[groupNumber] != 0) throw;\r\n        uint groupNumber = userGroup[msg.sender];\r\n        address newHangoutContract = hangoutFactory.newHangoutContract(hangoutGroups[groupNumber], this, (hangoutPhase - 15 minutes), hangoutAddress[groupNumber]);\r\n        hangoutContract[groupNumber] = newHangoutContract;\r\n        isHangoutContract[newHangoutContract] = true;\r\n        hangoutAddress[groupNumber] = sha3(newHangoutContract);\r\n    }\r\n    \r\n    function submitVerifiedUsers(address[] _verifiedUsers) {\r\n        if(isHangoutContract[msg.sender] != true) throw;\r\n        POI.submitVerifiedUsers(_verifiedUsers);\r\n        isHangoutContract[msg.sender] = false;\r\n    }\r\n\r\n}\r\n\r\ncontract RegistrationFactory {\r\n    function newRegistrationContract(address _proofOfIndividuality, uint _groupSize, uint _depositSize, uint _registrationPhase, uint _commitmentPhase, uint _hangoutPhase, address _hangoutFactory) returns (address) {\r\n      return new Registration(_proofOfIndividuality, _groupSize, _depositSize, _registrationPhase, _commitmentPhase, _hangoutPhase, _hangoutFactory);   \r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_proofOfIndividuality\",\"type\":\"address\"},{\"name\":\"_groupSize\",\"type\":\"uint256\"},{\"name\":\"_depositSize\",\"type\":\"uint256\"},{\"name\":\"_registrationPhase\",\"type\":\"uint256\"},{\"name\":\"_commitmentPhase\",\"type\":\"uint256\"},{\"name\":\"_hangoutPhase\",\"type\":\"uint256\"},{\"name\":\"_hangoutFactory\",\"type\":\"address\"}],\"name\":\"newRegistrationContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"}]", "ContractName": "RegistrationFactory", "CompilerVersion": "v0.4.6+commit.2dabbdf0", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}