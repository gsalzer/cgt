{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *  MultiSig.sol v1.1.0\r\n * \r\n *  Bilal Arif - https://twitter.com/furusiyya_\r\n *  Draglet GbmH\r\n */\r\n\r\npragma solidity 0.4.19;\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) pure internal returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) pure internal returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) pure internal returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private rentrancy_lock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!rentrancy_lock);\r\n    rentrancy_lock = true;\r\n    _;\r\n    rentrancy_lock = false;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * MultiSig is designed to hold funds of the ico. Account is controlled by four administratos. To trigger a payout\r\n * three out of four administrators will must agree on same amount of ethers to be transferred. During the signing\r\n * process if one administrator sends different targetted address or amount of ethers, process will abort and they\r\n * need to start again.\r\n * Administrator can be replaced but three out of four must agree upon replacement of fourth administrator. Three\r\n * admins will send address of fourth administrator along with address of new one administrator. If a single one\r\n * sends different address the updating process will abort and they need to start again. \r\n */\r\n\r\ncontract MultiSig is ReentrancyGuard{\r\n  \r\n  using SafeMath for uint256;\r\n  \r\n  // Maintain state funds transfer signing process\r\n  struct Transaction{\r\n    address[3] signer;\r\n    uint confirmations;\r\n    uint256 eth;\r\n  }\r\n  \r\n  // count and record signers with ethers they agree to transfer\r\n  Transaction private  pending;\r\n    \r\n  // the number of administrator that must confirm the same operation before it is run.\r\n  uint256 constant public required = 3;\r\n\r\n  mapping(address => bool) private administrators;\r\n \r\n  // Funds has arrived into the contract (record how much).\r\n  event Deposit(address _from, uint256 value);\r\n  \r\n  // Funds transfer to other contract\r\n  event Transfer(address indexed fristSigner, address indexed secondSigner, address indexed thirdSigner, address to,uint256 eth,bool success);\r\n  \r\n  // Administrator successfully signs a fund transfer\r\n  event TransferConfirmed(address signer,uint256 amount,uint256 remainingConfirmations);\r\n  \r\n  // Administrator successfully signs a key update transaction\r\n  event UpdateConfirmed(address indexed signer,address indexed newAddress,uint256 remainingConfirmations);\r\n  \r\n  \r\n  // Administrator violated consensus\r\n  event Violated(string action, address sender); \r\n  \r\n  // Administrator key updated (administrator replaced)\r\n  event KeyReplaced(address oldKey,address newKey);\r\n\r\n  event EventTransferWasReset();\r\n  event EventUpdateWasReset();\r\n  \r\n  \r\n  function MultiSig() public {\r\n\r\n    administrators[0x8E0c5A1b55d4E71B7891010EF504b11f19F4c466] = true;\r\n    administrators[0x5e77156CD35574A1dAC125992B73b3C5a973a4eb] = true;\r\n    administrators[0x604EdF8FE01db0AdafED4701F5De42b15067d23c] = true;\r\n    administrators[0xed4C73Ad76D90715d648797Acd29A8529ED511A0] = true;\r\n\r\n  }\r\n  \r\n  /**\r\n   * @dev  To trigger payout three out of four administrators call this\r\n   * function, funds will be transferred right after verification of\r\n   * third signer call.\r\n   * @param recipient The address of recipient\r\n   * @param amount Amount of wei to be transferred\r\n   */\r\n  function transfer(address recipient, uint256 amount) external onlyAdmin nonReentrant {\r\n    \r\n    // input validations\r\n    require( recipient != 0x00 );\r\n    require( amount > 0 );\r\n    require( this.balance >= amount);\r\n\r\n    uint remaining;\r\n    \r\n    // Start of signing process, first signer will finalize inputs for remaining two\r\n    if(pending.confirmations == 0){\r\n        \r\n        pending.signer[pending.confirmations] = msg.sender;\r\n        pending.eth = amount;\r\n        pending.confirmations = pending.confirmations.add(1);\r\n        remaining = required.sub(pending.confirmations);\r\n        TransferConfirmed(msg.sender,amount,remaining);\r\n        return;\r\n    \r\n    }\r\n    \r\n    // Compare amount of wei with previous confirmtaion\r\n    if(pending.eth != amount){\r\n        transferViolated(\"Incorrect amount of wei passed\");\r\n        return;\r\n    }\r\n    \r\n    // make sure signer is not trying to spam\r\n    if(msg.sender == pending.signer[0]){\r\n        transferViolated(\"Signer is spamming\");\r\n        return;\r\n    }\r\n    \r\n    pending.signer[pending.confirmations] = msg.sender;\r\n    pending.confirmations = pending.confirmations.add(1);\r\n    remaining = required.sub(pending.confirmations);\r\n    \r\n    // make sure signer is not trying to spam\r\n    if( remaining == 0){\r\n        if(msg.sender == pending.signer[1]){\r\n            transferViolated(\"One of signers is spamming\");\r\n            return;\r\n        }\r\n    }\r\n    \r\n    TransferConfirmed(msg.sender,amount,remaining);\r\n    \r\n    // If three confirmation are done, trigger payout\r\n    if (pending.confirmations == 3){\r\n        if(recipient.send(amount)){\r\n            Transfer(pending.signer[0],pending.signer[1], pending.signer[2], recipient,amount,true);\r\n        }else{\r\n            Transfer(pending.signer[0],pending.signer[1], pending.signer[2], recipient,amount,false);\r\n        }\r\n        ResetTransferState();\r\n    } \r\n  }\r\n  \r\n  function transferViolated(string error) private {\r\n    Violated(error, msg.sender);\r\n    ResetTransferState();\r\n  }\r\n  \r\n  function ResetTransferState() internal\r\n  {\r\n      delete pending;\r\n      EventTransferWasReset();\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Reset values of pending (Transaction object)\r\n   */\r\n  function abortTransaction() external onlyAdmin{\r\n       ResetTransferState();\r\n  }\r\n  \r\n  /** \r\n   * @dev Fallback function, receives value and emits a deposit event. \r\n   */\r\n  function() payable public {\r\n    // just being sent some cash?\r\n    if (msg.value > 0)\r\n      Deposit(msg.sender, msg.value);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if given address is an administrator.\r\n   * @param _addr address The address which you want to check.\r\n   * @return True if the address is an administrator and fase otherwise.\r\n   */\r\n  function isAdministrator(address _addr) public constant returns (bool) {\r\n    return administrators[_addr];\r\n  }\r\n  \r\n  // Maintian state of administrator key update process\r\n  struct KeyUpdate{\r\n    address[3] signer;\r\n    uint confirmations;\r\n    address oldAddress;\r\n    address newAddress;\r\n  }\r\n  \r\n  KeyUpdate private updating;\r\n  \r\n  /**\r\n   * @dev Three admnistrator can replace key of fourth administrator. \r\n   * @param _oldAddress Address of adminisrator needs to be replaced\r\n   * @param _newAddress Address of new administrator\r\n   */\r\n  function updateAdministratorKey(address _oldAddress, address _newAddress) external onlyAdmin {\r\n    \r\n    // input verifications\r\n    require(isAdministrator(_oldAddress));\r\n    require( _newAddress != 0x00 );\r\n    require(!isAdministrator(_newAddress));\r\n    require( msg.sender != _oldAddress );\r\n    \r\n    // count confirmation \r\n    uint256 remaining;\r\n    \r\n    // start of updating process, first signer will finalize address to be replaced\r\n    // and new address to be registered, remaining two must confirm\r\n    if( updating.confirmations == 0){\r\n        \r\n        updating.signer[updating.confirmations] = msg.sender;\r\n        updating.oldAddress = _oldAddress;\r\n        updating.newAddress = _newAddress;\r\n        updating.confirmations = updating.confirmations.add(1);\r\n        remaining = required.sub(updating.confirmations);\r\n        UpdateConfirmed(msg.sender,_newAddress,remaining);\r\n        return;\r\n        \r\n    }\r\n    \r\n    // violated consensus\r\n    if(updating.oldAddress != _oldAddress){\r\n        Violated(\"Old addresses do not match\",msg.sender);\r\n        ResetUpdateState();\r\n        return;\r\n    }\r\n    \r\n    if(updating.newAddress != _newAddress){\r\n        Violated(\"New addresses do not match\",msg.sender);\r\n        ResetUpdateState();\r\n        return; \r\n    }\r\n    \r\n    // make sure admin is not trying to spam\r\n    if(msg.sender == updating.signer[0]){\r\n        Violated(\"Signer is spamming\",msg.sender);\r\n        ResetUpdateState();\r\n        return;\r\n    }\r\n        \r\n    updating.signer[updating.confirmations] = msg.sender;\r\n    updating.confirmations = updating.confirmations.add(1);\r\n    remaining = required.sub(updating.confirmations);\r\n\r\n    if( remaining == 0){\r\n        if(msg.sender == updating.signer[1]){\r\n            Violated(\"One of signers is spamming\",msg.sender);\r\n            ResetUpdateState();\r\n            return;\r\n        }\r\n    }\r\n\r\n    UpdateConfirmed(msg.sender,_newAddress,remaining);\r\n    \r\n    // if three confirmation are done, register new admin and remove old one\r\n    if( updating.confirmations == 3 ){\r\n        KeyReplaced(_oldAddress, _newAddress);\r\n        ResetUpdateState();\r\n        delete administrators[_oldAddress];\r\n        administrators[_newAddress] = true;\r\n        return;\r\n    }\r\n  }\r\n  \r\n  function ResetUpdateState() internal\r\n  {\r\n      delete updating;\r\n      EventUpdateWasReset();\r\n  }\r\n\r\n  /**\r\n   * @dev Reset values of updating (KeyUpdate object)\r\n   */\r\n  function abortUpdate() external onlyAdmin{\r\n      ResetUpdateState();\r\n  }\r\n  \r\n  /**\r\n   * @dev modifier allow only if function is called by administrator\r\n   */\r\n  modifier onlyAdmin(){\r\n      if( !administrators[msg.sender] ){\r\n          revert();\r\n      }\r\n      _;\r\n  }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAdministrator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abortUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abortTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldAddress\",\"type\":\"address\"},{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateAdministratorKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"required\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fristSigner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"secondSigner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"thirdSigner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remainingConfirmations\",\"type\":\"uint256\"}],\"name\":\"TransferConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"remainingConfirmations\",\"type\":\"uint256\"}],\"name\":\"UpdateConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Violated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldKey\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newKey\",\"type\":\"address\"}],\"name\":\"KeyReplaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EventTransferWasReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EventUpdateWasReset\",\"type\":\"event\"}]", "ContractName": "MultiSig", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://5f876fb492705062557aab12473cf18528bb53ea60674a9c74b4a72876f82ac7"}]}