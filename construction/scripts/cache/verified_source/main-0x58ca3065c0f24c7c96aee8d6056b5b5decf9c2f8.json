{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^ 0.4 .11;\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns(uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns(uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns(uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function safeAdd(uint a, uint b) internal returns(uint) {\r\n        uint c = a + b;\r\n        assert(c >= a && c >= b);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n    uint public totalSupply;\r\n\r\n    function balanceOf(address who) constant returns(uint);\r\n\r\n    function allowance(address owner, address spender) constant returns(uint);\r\n\r\n    function transfer(address to, uint value) returns(bool ok);\r\n\r\n    function transferFrom(address from, address to, uint value) returns(bool ok);\r\n\r\n    function approve(address spender, uint value) returns(bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        if (newOwner != address(0)) owner = newOwner;\r\n    }\r\n\r\n    function kill() {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender == owner)\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public stopped;\r\n\r\n    modifier stopInEmergency {\r\n        if (stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!stopped) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Called by the owner in emergency, triggers stopped state\r\n    function emergencyStop() external onlyOwner {\r\n        stopped = true;\r\n    }\r\n\r\n    // Called by the owner to end of emergency, returns to normal state\r\n    function release() external onlyOwner onlyInEmergency {\r\n        stopped = false;\r\n    }\r\n}\r\n\r\n\r\n\r\n// Base contract supporting async send for pull payments.\r\n// Inherit from this contract and use asyncSend instead of send.\r\ncontract PullPayment {\r\n    mapping(address => uint) public payments;\r\n\r\n    event RefundETH(address to, uint value);\r\n\r\n    // Store sent amount as credit to be pulled, called by payer\r\n    function asyncSend(address dest, uint amount) internal {\r\n        payments[dest] += amount;\r\n    }\r\n    \r\n    // Withdraw accumulated balance, called by payee\r\n    function withdrawPayments() internal returns (bool) {\r\n        address payee = msg.sender;\r\n        uint payment = payments[payee];\r\n\r\n        if (payment == 0) {\r\n            revert();\r\n        }\r\n\r\n        if (this.balance < payment) {\r\n            revert();\r\n        }\r\n\r\n        payments[payee] = 0;\r\n\r\n        if (!payee.send(payment)) {\r\n            revert();\r\n        }\r\n        RefundETH(payee, payment);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// Crowdsale Smart Contract\r\n// This smart contract collects ETH and in return sends GXC tokens to the Backers\r\ncontract Crowdsale is SafeMath, Pausable, PullPayment {\r\n\r\n    struct Backer {\r\n        uint weiReceived; // amount of ETH contributed\r\n        uint GXCSent; // amount of tokens  sent        \r\n    }\r\n\r\n    GXC public gxc; // DMINI contract reference   \r\n    address public multisigETH; // Multisig contract that will receive the ETH    \r\n    address public team; // Address at which the team GXC will be sent   \r\n    uint public ETHReceived; // Number of ETH received\r\n    uint public GXCSentToETH; // Number of GXC sent to ETH contributors\r\n    uint public startBlock; // Crowdsale start block\r\n    uint public endBlock; // Crowdsale end block\r\n    uint public maxCap; // Maximum number of GXC to sell\r\n    uint public minCap; // Minimum number of ETH to raise\r\n    uint public minInvestETH; // Minimum amount to invest\r\n    bool public crowdsaleClosed; // Is crowdsale still on going\r\n    uint public tokenPriceWei;\r\n    uint GXCReservedForPresale ;  \r\n    \r\n\r\n    \r\n    uint multiplier = 10000000000; // to provide 10 decimal values\r\n    // Looping through Backer\r\n    mapping(address => Backer) public backers; //backer list\r\n    address[] public backersIndex ;   // to be able to itarate through backers when distributing the tokens. \r\n\r\n\r\n    // @notice to verify if action is not performed out of the campaing range\r\n    modifier respectTimeFrame() {\r\n        if ((block.number < startBlock) || (block.number > endBlock)) revert();\r\n        _;\r\n    }\r\n\r\n    modifier minCapNotReached() {\r\n        if (GXCSentToETH >= minCap) revert();\r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event ReceivedETH(address backer, uint amount, uint tokenAmount);\r\n\r\n    // Crowdsale  {constructor}\r\n    // @notice fired when contract is crated. Initilizes all constnat variables.\r\n    function Crowdsale() {\r\n    \r\n        multisigETH = 0x62739Ec09cdD8FAe2f7b976f8C11DbE338DF8750; \r\n        team = 0x62739Ec09cdD8FAe2f7b976f8C11DbE338DF8750;                    \r\n        GXCSentToETH = 487000 * multiplier;               \r\n        minInvestETH = 100000000000000000 ; // 0.1 eth\r\n        startBlock = 0; // ICO start block\r\n        endBlock = 0; // ICO end block            \r\n        maxCap = 8250000 * multiplier;\r\n        // Price is 0.001 eth                         \r\n        tokenPriceWei = 3004447000000000;\r\n                        \r\n        minCap = 500000 * multiplier;\r\n    }\r\n\r\n    // @notice Specify address of token contract\r\n    // @param _GXCAddress {address} address of GXC token contrac\r\n    // @return res {bool}\r\n    function updateTokenAddress(GXC _GXCAddress) public onlyOwner() returns(bool res) {\r\n        gxc = _GXCAddress;  \r\n        return true;    \r\n    }\r\n\r\n    // @notice modify this address should this be needed. \r\n    function updateTeamAddress(address _teamAddress) public onlyOwner returns(bool){\r\n        team = _teamAddress;\r\n        return true; \r\n    }\r\n\r\n    // @notice return number of contributors\r\n    // @return  {uint} number of contributors\r\n    function numberOfBackers()constant returns (uint){\r\n        return backersIndex.length;\r\n    }\r\n\r\n    // {fallback function}\r\n    // @notice It will call internal function which handels allocation of Ether and calculates GXC tokens.\r\n    function () payable {         \r\n        handleETH(msg.sender);\r\n    }\r\n\r\n    // @notice It will be called by owner to start the sale   \r\n    function start(uint _block) onlyOwner() {\r\n        startBlock = block.number;\r\n        endBlock = startBlock + _block; //TODO: Replace _block with 40320 for 7 days\r\n        // 1 week in blocks = 40320 (4 * 60 * 24 * 7)\r\n        // enable this for live assuming each bloc takes 15 sec .\r\n        crowdsaleClosed = false;\r\n    }\r\n\r\n    // @notice It will be called by fallback function whenever ether is sent to it\r\n    // @param  _backer {address} address of beneficiary\r\n    // @return res {bool} true if transaction was successful\r\n    function handleETH(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\r\n\r\n        if (msg.value < minInvestETH) revert(); // stop when required minimum is not sent\r\n\r\n        uint GXCToSend = (msg.value * multiplier)/ tokenPriceWei ; // calculate number of tokens\r\n\r\n        // Ensure that max cap hasn't been reached\r\n        if (safeAdd(GXCSentToETH, GXCToSend) > maxCap) revert();\r\n\r\n        Backer storage backer = backers[_backer];\r\n\r\n         if ( backer.weiReceived  == 0)\r\n             backersIndex.push(_backer);\r\n\r\n        if (!gxc.transfer(_backer, GXCToSend)) revert(); // Transfer GXC tokens\r\n        backer.GXCSent = safeAdd(backer.GXCSent, GXCToSend);\r\n        backer.weiReceived = safeAdd(backer.weiReceived, msg.value);\r\n        ETHReceived = safeAdd(ETHReceived, msg.value); // Update the total Ether recived\r\n        GXCSentToETH = safeAdd(GXCSentToETH, GXCToSend);\r\n        ReceivedETH(_backer, msg.value, GXCToSend); // Register event\r\n        return true;\r\n    }\r\n\r\n\r\n    // @notice This function will finalize the sale.\r\n    // It will only execute if predetermined sale time passed or all tokens are sold.\r\n    function finalize() onlyOwner() {\r\n\r\n        if (crowdsaleClosed) revert();\r\n        \r\n        uint daysToRefund = 4*60*24*10;  //10 days        \r\n\r\n        if (block.number < endBlock && GXCSentToETH < maxCap -100 ) revert();  // -100 is used to allow closing of the campaing when contribution is near \r\n                                                                                 // finished as exact amount of maxCap might be not feasible e.g. you can't easily buy few tokens. \r\n                                                                                 // when min contribution is 0.1 Eth.  \r\n\r\n        if (GXCSentToETH < minCap && block.number < safeAdd(endBlock , daysToRefund)) revert();   \r\n\r\n       \r\n        if (GXCSentToETH > minCap) {\r\n            if (!multisigETH.send(this.balance)) revert();  // transfer balance to multisig wallet\r\n            if (!gxc.transfer(team,  gxc.balanceOf(this))) revert(); // transfer tokens to admin account or multisig wallet                                \r\n            gxc.unlock();    // release lock from transfering tokens. \r\n        }\r\n        else{\r\n            if (!gxc.burn(this, gxc.balanceOf(this))) revert();  // burn all the tokens remaining in the contract                       \r\n        }\r\n\r\n        crowdsaleClosed = true;\r\n        \r\n    }\r\n\r\n \r\n\r\n  \r\n    // @notice Failsafe drain\r\n    function drain() onlyOwner(){\r\n        if (!owner.send(this.balance)) revert();\r\n    }\r\n\r\n    // @notice Failsafe transfer tokens for the team to given account \r\n    function transferDevTokens(address _devAddress) onlyOwner returns(bool){\r\n        if (!gxc.transfer(_devAddress,  gxc.balanceOf(this))) \r\n            revert(); \r\n        return true;\r\n\r\n    }    \r\n\r\n\r\n    // @notice Prepare refund of the backer if minimum is not reached\r\n    // burn the tokens\r\n    function prepareRefund()  minCapNotReached internal returns (bool){\r\n        uint value = backers[msg.sender].GXCSent;\r\n\r\n        if (value == 0) revert();           \r\n        if (!gxc.burn(msg.sender, value)) revert();\r\n        uint ETHToSend = backers[msg.sender].weiReceived;\r\n        backers[msg.sender].weiReceived = 0;\r\n        backers[msg.sender].GXCSent = 0;\r\n        if (ETHToSend > 0) {\r\n            asyncSend(msg.sender, ETHToSend);\r\n            return true;\r\n        }else\r\n            return false;\r\n        \r\n    }\r\n\r\n    // @notice refund the backer\r\n    function refund() public returns (bool){\r\n\r\n        if (!prepareRefund()) revert();\r\n        if (!withdrawPayments()) revert();\r\n        return true;\r\n\r\n    }\r\n\r\n \r\n}\r\n\r\n// The GXC token\r\ncontract GXC is ERC20, SafeMath, Ownable {\r\n    // Public variables of the token\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals; // How many decimals to show.\r\n    string public version = 'v0.1';\r\n    uint public initialSupply;\r\n    uint public totalSupply;\r\n    bool public locked;\r\n    address public crowdSaleAddress;\r\n    uint multiplier = 10000000000;        \r\n    \r\n    uint256 public totalMigrated;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    \r\n\r\n    // Lock transfer during the ICO\r\n    modifier onlyUnlocked() {\r\n        if (msg.sender != crowdSaleAddress && locked && msg.sender != owner) revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        if ( msg.sender != crowdSaleAddress && msg.sender != owner) revert();\r\n        _;\r\n    }\r\n\r\n    // The GXC Token constructor\r\n    function GXC(address _crowdSaleAddress) {        \r\n        locked = true;  // Lock the transfer of tokens during the crowdsale\r\n        initialSupply = 10000000 * multiplier;\r\n        totalSupply = initialSupply;\r\n        name = 'GXC'; // Set the name for display purposes\r\n        symbol = 'GXC'; // Set the symbol for display purposes\r\n        decimals = 10; // Amount of decimals for display purposes\r\n        crowdSaleAddress = _crowdSaleAddress;               \r\n        balances[crowdSaleAddress] = totalSupply;       \r\n    }\r\n\r\n\r\n    function restCrowdSaleAddress(address _newCrowdSaleAddress) onlyAuthorized() {\r\n            crowdSaleAddress = _newCrowdSaleAddress;\r\n    }\r\n\r\n    \r\n\r\n    function unlock() onlyAuthorized {\r\n        locked = false;\r\n    }\r\n\r\n      function lock() onlyAuthorized {\r\n        locked = true;\r\n    }\r\n\r\n    function burn( address _member, uint256 _value) onlyAuthorized returns(bool) {\r\n        balances[_member] = safeSub(balances[_member], _value);\r\n        totalSupply = safeSub(totalSupply, _value);\r\n        Transfer(_member, 0x0, _value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) onlyUnlocked returns(bool) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /* A contract attempts to get the coins */\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyUnlocked returns(bool success) {\r\n        if (balances[_from] < _value) revert(); // Check if the sender has enough\r\n        if (_value > allowed[_from][msg.sender]) revert(); // Check allowance\r\n        balances[_from] = safeSub(balances[_from], _value); // Subtract from the sender\r\n        balances[_to] = safeAdd(balances[_to], _value); // Add the same to the recipient\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns(uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function allowance(address _owner, address _spender) constant returns(uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"crowdSaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCrowdSaleAddress\",\"type\":\"address\"}],\"name\":\"restCrowdSaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_crowdSaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "GXC", "CompilerVersion": "v0.4.16+commit.d7661dd9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000066345ae2b6fc2ce02684eee1aa1453257f77e635", "Library": "", "SwarmSource": "bzzr://5b08799c52d674bdc57dba5e1ef63eb79531b38a1fa3b9c72c9735c23d87effb"}]}