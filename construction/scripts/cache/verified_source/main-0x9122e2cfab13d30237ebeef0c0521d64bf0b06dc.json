{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n    cEthereumlotteryNet\r\n    Coded by: iFA\r\n    http://c.ethereumlottery.net\r\n*/\r\n\r\ncontract cEthereumlotteryNet {\r\n        address owner;\r\n        address drawerAddress;\r\n        bool contractEnabled = true;\r\n        uint public constant ticketPrice = 10 finney;\r\n        uint constant defaultJackpot = 100 ether;\r\n        uint constant feep = 23;\r\n        uint constant hit3p = 35;\r\n        uint constant hit4p = 25;\r\n        uint constant hit5p = 40;\r\n        uint8 constant maxNumber = 30;\r\n        uint constant drawCheckStep = 80;\r\n        uint feeValue;\r\n\r\n        struct hits_s {\r\n                uint prize;\r\n                uint count;\r\n        }\r\n\r\n        enum drawStatus_ {\r\n                Wait,\r\n                InProcess,\r\n                Done,\r\n                Failed\r\n        }\r\n\r\n        struct tickets_s {\r\n                uint hits;\r\n                bytes5 numbers;\r\n        }\r\n\r\n        struct games_s {\r\n                uint start;\r\n                uint end;\r\n                uint jackpot;\r\n                bytes32 secret_Key_Hash;\r\n                string secret_Key;\r\n                uint8[5] winningNumbers;\r\n                mapping(uint => hits_s) hits;\r\n                uint prizePot;\r\n                drawStatus_ drawStatus;\r\n                bytes32 winHash;\r\n                mapping(uint => tickets_s) tickets;\r\n                uint ticketsCount;\r\n                uint checkedTickets;\r\n                bytes32 nextHashOfSecretKey;\r\n        }\r\n\r\n        mapping(uint => games_s) games;\r\n\r\n        uint public CurrentGameId = 0;\r\n\r\n        struct player_s {\r\n                bool paid;\r\n                uint[] tickets;\r\n        }\r\n\r\n        mapping(address => mapping(uint => player_s)) players;\r\n        uint playersSize;\r\n\r\n        function ContractStatus() constant returns(bool Enabled) {\r\n                Enabled = contractEnabled;\r\n        }\r\n\r\n        function GameDetails(uint GameId) constant returns(\r\n                uint Jackpot, uint TicketsCount, uint StartBlock, uint EndBlock) {\r\n                Jackpot = games[GameId].jackpot;\r\n                TicketsCount = games[GameId].ticketsCount;\r\n                StartBlock = games[GameId].start;\r\n                EndBlock = games[GameId].end;\r\n        }\r\n\r\n        function DrawDetails(uint GameId) constant returns(\r\n                bytes32 SecretKeyHash, string SecretKey, string DrawStatus, bytes32 WinHash,\r\n                uint8[5] WinningNumbers, uint Hit3Count, uint Hit4Count, uint Hit5Count,\r\n                uint Hit3Prize, uint Hit4Prize, uint Hit5Prize) {\r\n                DrawStatus = WritedrawStatus(games[GameId].drawStatus);\r\n                SecretKeyHash = games[GameId].secret_Key_Hash;\r\n                if (games[GameId].drawStatus != drawStatus_.Wait) {\r\n                        SecretKey = games[GameId].secret_Key;\r\n                        WinningNumbers = games[GameId].winningNumbers;\r\n                        Hit3Count = games[GameId].hits[3].count;\r\n                        Hit4Count = games[GameId].hits[4].count;\r\n                        Hit5Count = games[GameId].hits[5].count;\r\n                        Hit3Prize = games[GameId].hits[3].prize;\r\n                        Hit4Prize = games[GameId].hits[4].prize;\r\n                        Hit5Prize = games[GameId].hits[5].prize;\r\n                        WinHash = games[GameId].winHash;\r\n                } else {\r\n                        SecretKey = \"\";\r\n                        WinningNumbers = [0, 0, 0, 0, 0];\r\n                        Hit3Count = 0;\r\n                        Hit4Count = 0;\r\n                        Hit5Count = 0;\r\n                        Hit3Prize = 0;\r\n                        Hit4Prize = 0;\r\n                        Hit5Prize = 0;\r\n                        WinHash = 0;\r\n                }\r\n        }\r\n\r\n        function CheckTickets(address Address, uint GameId, uint TicketNumber) constant returns(uint8[5] Numbers, uint Hits, bool Paid) {\r\n                if (players[Address][GameId].tickets[TicketNumber] > 0) {\r\n                        Numbers[0] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256 / 256);\r\n                        Numbers[1] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256);\r\n                        Numbers[2] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256);\r\n                        Numbers[3] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256);\r\n                        Numbers[4] = uint8(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers);\r\n                        Numbers = sortWinningNumbers(Numbers);\r\n                        Hits = games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].hits;\r\n                        Paid = players[Address][GameId].paid;\r\n                }\r\n        }\r\n        string constant public Information = \"http://c.ethereumlottery.net\";\r\n\r\n        function UserCheckBalance(address addr) constant returns(uint Balance) {\r\n                for (uint a = 0; a < CurrentGameId; a++) {\r\n                        if (players[addr][a].paid == false) {\r\n                                if (games[a].drawStatus == drawStatus_.Done) {\r\n                                        for (uint b = 0; b < players[addr][a].tickets.length; b++) {\r\n                                                if (games[a].tickets[players[addr][a].tickets[b]].hits == 3) {\r\n                                                        Balance += games[a].hits[3].prize;\r\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 4) {\r\n                                                        Balance += games[a].hits[4].prize;\r\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 5) {\r\n                                                        Balance += games[a].hits[5].prize;\r\n                                                }\r\n                                        }\r\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\r\n                                        Balance += ticketPrice * players[addr][a].tickets.length;\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n\r\n        function cEthereumlotteryNet(bytes32 SecretKeyHash) {\r\n                owner = msg.sender;\r\n                CreateNewDraw(defaultJackpot, SecretKeyHash);\r\n                drawerAddress = owner;\r\n        }\r\n\r\n        function UserGetPrize() external {\r\n                uint Balance;\r\n                uint GameBalance;\r\n                for (uint a = 0; a < CurrentGameId; a++) {\r\n                        if (players[msg.sender][a].paid == false) {\r\n                                if (games[a].drawStatus == drawStatus_.Done) {\r\n                                        for (uint b = 0; b < players[msg.sender][a].tickets.length; b++) {\r\n                                                if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 3) {\r\n                                                        GameBalance += games[a].hits[3].prize;\r\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 4) {\r\n                                                        GameBalance += games[a].hits[4].prize;\r\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 5) {\r\n                                                        GameBalance += games[a].hits[5].prize;\r\n                                                }\r\n                                        }\r\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\r\n                                        GameBalance += ticketPrice * players[msg.sender][a].tickets.length;\r\n                                }\r\n                                players[msg.sender][a].paid = true;\r\n                                games[a].prizePot -= GameBalance;\r\n                                Balance += GameBalance;\r\n                                GameBalance = 0;\r\n                        }\r\n                }\r\n                if (Balance > 0) {\r\n                        if (msg.sender.send(Balance) == false) {\r\n                                throw;\r\n                        }\r\n                } else {\r\n                        throw;\r\n                }\r\n        }\r\n\r\n        function UserAddTicket(bytes5[] tickets) OnlyEnabled OnlyDrawWait external {\r\n                uint ticketsCount = tickets.length;\r\n                if (ticketsCount > 70) {\r\n                        throw;\r\n                }\r\n                if (msg.value < ticketsCount * ticketPrice) {\r\n                        throw;\r\n                }\r\n                if (msg.value > (ticketsCount * ticketPrice)) {\r\n                        if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) {\r\n                                throw;\r\n                        }\r\n                }\r\n                for (uint a = 0; a < ticketsCount; a++) {\r\n                        if (!CheckNumbers(ConvertNumbers(tickets[a]))) {\r\n                                throw;\r\n                        }\r\n                        games[CurrentGameId].ticketsCount += 1;\r\n                        games[CurrentGameId].tickets[games[CurrentGameId].ticketsCount].numbers = tickets[a];\r\n                        players[msg.sender][CurrentGameId].tickets.length += 1;\r\n                        players[msg.sender][CurrentGameId].tickets[players[msg.sender][CurrentGameId].tickets.length - 1] = games[CurrentGameId].ticketsCount;\r\n                }\r\n        }\r\n\r\n        function() {\r\n                throw;\r\n        }\r\n\r\n        function AdminDrawProcess() OnlyDrawer OnlyDrawProcess {\r\n                uint StepCount = drawCheckStep;\r\n                if (games[CurrentGameId].checkedTickets < games[CurrentGameId].ticketsCount) {\r\n                        for (uint a = games[CurrentGameId].checkedTickets; a <= games[CurrentGameId].ticketsCount; a++) {\r\n                                if (StepCount == 0) {\r\n                                        break;\r\n                                }\r\n                                for (uint b = 0; b < 5; b++) {\r\n                                        for (uint c = 0; c < 5; c++) {\r\n                                                if (uint8(uint40(games[CurrentGameId].tickets[a].numbers) / (256 ** b)) == games[CurrentGameId].winningNumbers[c]) {\r\n                                                        games[CurrentGameId].tickets[a].hits += 1;\r\n                                                }\r\n                                        }\r\n                                }\r\n                                games[CurrentGameId].checkedTickets += 1;\r\n                                StepCount -= 1;\r\n                        }\r\n                }\r\n                if (games[CurrentGameId].checkedTickets >= games[CurrentGameId].ticketsCount) {\r\n                        //kesz\r\n                        for (a = 0; a < games[CurrentGameId].ticketsCount; a++) {\r\n                                if (games[CurrentGameId].tickets[a].hits == 3) {\r\n                                        games[CurrentGameId].hits[3].count += 1;\r\n                                } else if (games[CurrentGameId].tickets[a].hits == 4) {\r\n                                        games[CurrentGameId].hits[4].count += 1;\r\n                                } else if (games[CurrentGameId].tickets[a].hits == 5) {\r\n                                        games[CurrentGameId].hits[5].count += 1;\r\n                                }\r\n                        }\r\n                        if (games[CurrentGameId].hits[3].count > 0) {\r\n                                games[CurrentGameId].hits[3].prize = games[CurrentGameId].prizePot * hit3p / 100 / games[CurrentGameId].hits[3].count;\r\n                        }\r\n                        if (games[CurrentGameId].hits[4].count > 0) {\r\n                                games[CurrentGameId].hits[4].prize = games[CurrentGameId].prizePot * hit4p / 100 / games[CurrentGameId].hits[4].count;\r\n                        }\r\n                        if (games[CurrentGameId].hits[5].count > 0) {\r\n                                games[CurrentGameId].hits[5].prize = games[CurrentGameId].jackpot / games[CurrentGameId].hits[5].count;\r\n                        }\r\n                        uint NextJackpot;\r\n                        if (games[CurrentGameId].hits[5].count == 0) {\r\n                                NextJackpot = games[CurrentGameId].prizePot * hit5p / 100 + games[CurrentGameId].jackpot;\r\n                        } else {\r\n                                NextJackpot = defaultJackpot;\r\n                        }\r\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\r\n                        CreateNewDraw(NextJackpot, games[CurrentGameId].nextHashOfSecretKey);\r\n                }\r\n        }\r\n\r\n        function AdminDrawError() external OnlyDrawer OnlyDrawProcess {\r\n                games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\r\n                games[CurrentGameId].drawStatus = drawStatus_.Failed;\r\n                CreateNewDraw(games[CurrentGameId].jackpot, games[CurrentGameId].nextHashOfSecretKey);\r\n        }\r\n\r\n        function AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) external OnlyDrawer OnlyDrawWait returns(uint ret) {\r\n                games[CurrentGameId].end = block.number;\r\n                if (sha3(secret_Key) != games[CurrentGameId].secret_Key_Hash) {\r\n                        games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\r\n                        games[CurrentGameId].drawStatus = drawStatus_.Failed;\r\n                        games[CurrentGameId].secret_Key = secret_Key;\r\n                        CreateNewDraw(games[CurrentGameId].jackpot, New_secret_Key_Hash);\r\n                        return;\r\n                }\r\n                games[CurrentGameId].drawStatus = drawStatus_.InProcess;\r\n                games[CurrentGameId].nextHashOfSecretKey = New_secret_Key_Hash;\r\n                games[CurrentGameId].secret_Key = secret_Key;\r\n                games[CurrentGameId].winHash = sha3(games[CurrentGameId].secret_Key, games[CurrentGameId].secret_Key_Hash, games[CurrentGameId].ticketsCount, now);\r\n                games[CurrentGameId].winningNumbers = sortWinningNumbers(GetNumbersFromHash(games[CurrentGameId].winHash));\r\n                if (games[CurrentGameId].ticketsCount > 1) {\r\n                        feeValue += ticketPrice * games[CurrentGameId].ticketsCount * feep / 100;\r\n                        games[CurrentGameId].prizePot = ticketPrice * games[CurrentGameId].ticketsCount - feeValue;\r\n                        AdminDrawProcess();\r\n                } else {\r\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\r\n                }\r\n        }\r\n\r\n        function AdminSetDrawer(address NewDrawer) external OnlyOwner {\r\n                drawerAddress = NewDrawer;\r\n        }\r\n\r\n        function AdminCloseContract() OnlyOwner external {\r\n                if (!contractEnabled) {\r\n                        if (games[CurrentGameId].ticketsCount == 0) {\r\n                                uint contractbalance = this.balance;\r\n                                for (uint a = 0; a < CurrentGameId; a++) {\r\n                                        contractbalance -= games[a].prizePot;\r\n                                }\r\n                                contractbalance += games[a].jackpot - defaultJackpot;\r\n                                if (owner.send(contractbalance) == false) {\r\n                                        throw;\r\n                                }\r\n                                feeValue = 0;\r\n                        } else {\r\n                                throw;\r\n                        }\r\n                } else {\r\n                        contractEnabled = false;\r\n                }\r\n        }\r\n\r\n        function AdminAddFunds() OnlyOwner {\r\n                return;\r\n        }\r\n\r\n        function AdminGetFee() OnlyOwner {\r\n                if (owner.send(feeValue) == false) {\r\n                        throw;\r\n                }\r\n                feeValue = 0;\r\n        }\r\n\r\n        modifier OnlyDrawer() {\r\n                if ((drawerAddress != msg.sender) && (owner != msg.sender)) {\r\n                        throw;\r\n                }\r\n                _\r\n        }\r\n\r\n        modifier OnlyOwner() {\r\n                if (owner != msg.sender) {\r\n                        throw;\r\n                }\r\n                _\r\n        }\r\n\r\n        modifier OnlyEnabled() {\r\n                if (!contractEnabled) {\r\n                        throw;\r\n                }\r\n                _\r\n        }\r\n\r\n        modifier OnlyDrawWait() {\r\n                if (games[CurrentGameId].drawStatus != drawStatus_.Wait) {\r\n                        throw;\r\n                }\r\n                _\r\n        }\r\n\r\n        modifier OnlyDrawProcess() {\r\n                if (games[CurrentGameId].drawStatus != drawStatus_.InProcess) {\r\n                        throw;\r\n                }\r\n                _\r\n        }\r\n\r\n        function CreateNewDraw(uint Jackpot, bytes32 SecretKeyHash) internal {\r\n                CurrentGameId += 1;\r\n                games[CurrentGameId].start = block.number;\r\n                games[CurrentGameId].jackpot = Jackpot;\r\n                games[CurrentGameId].secret_Key_Hash = SecretKeyHash;\r\n                games[CurrentGameId].drawStatus = drawStatus_.Wait;\r\n        }\r\n\r\n        function ConvertNumbers(bytes5 input) internal returns(uint8[5] output) {\r\n                output[0] = uint8(uint40(input) / 256 / 256 / 256 / 256);\r\n                output[1] = uint8(uint40(input) / 256 / 256 / 256);\r\n                output[2] = uint8(uint40(input) / 256 / 256);\r\n                output[3] = uint8(uint40(input) / 256);\r\n                output[4] = uint8(input);\r\n        }\r\n\r\n        function CheckNumbers(uint8[5] tickets) internal returns(bool ok) {\r\n                for (uint8 a = 0; a < 5; a++) {\r\n                        if ((tickets[a] < 1) || (tickets[a] > maxNumber)) {\r\n                                return false;\r\n                        }\r\n                        for (uint8 b = 0; b < 5; b++) {\r\n                                if ((tickets[a] == tickets[b]) && (a != b)) {\r\n                                        return false;\r\n                                }\r\n                        }\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function GetNumbersFromHash(bytes32 hash) internal returns(uint8[5] tickets) {\r\n                bool ok = true;\r\n                uint8 num = 0;\r\n                uint hashpos = 0;\r\n                uint8 a;\r\n                for (a = 0; a < 5; a++) {\r\n                        while (true) {\r\n                                ok = true;\r\n                                if (hashpos == 32) {\r\n                                        hashpos = 0;\r\n                                        hash = sha3(hash);\r\n                                }\r\n                                num = GetPart(hash, hashpos);\r\n                                num = num % maxNumber + 1;\r\n                                hashpos += 1;\r\n                                for (uint8 b = 0; b < 5; b++) {\r\n                                        if (tickets[b] == num) {\r\n                                                ok = false;\r\n                                                break;\r\n                                        }\r\n                                }\r\n                                if (ok == true) {\r\n                                        tickets[a] = num;\r\n                                        break;\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n\r\n        function GetPart(bytes32 a, uint i) internal returns(uint8) {\r\n                return uint8(byte(bytes32(uint(a) * 2 ** (8 * i))));\r\n        }\r\n\r\n        function WritedrawStatus(drawStatus_ input) internal returns(string drawStatus) {\r\n                if (input == drawStatus_.Wait) {\r\n                        drawStatus = \"Wait\";\r\n                } else if (input == drawStatus_.InProcess) {\r\n                        drawStatus = \"In Process\";\r\n                } else if (input == drawStatus_.Done) {\r\n                        drawStatus = \"Done\";\r\n                } else if (input == drawStatus_.Failed) {\r\n                        drawStatus = \"Failed\";\r\n                }\r\n        }\r\n\r\n        function sortWinningNumbers(uint8[5] numbers) internal returns(uint8[5] sortednumbers) {\r\n                sortednumbers = numbers;\r\n                for (uint8 i = 0; i < 5; i++) {\r\n                        for (uint8 j = i + 1; j < 5; j++) {\r\n                                if (sortednumbers[i] > sortednumbers[j]) {\r\n                                        uint8 t = sortednumbers[i];\r\n                                        sortednumbers[i] = sortednumbers[j];\r\n                                        sortednumbers[j] = t;\r\n                                }\r\n                        }\r\n                }\r\n        }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"}],\"name\":\"DrawDetails\",\"outputs\":[{\"name\":\"SecretKeyHash\",\"type\":\"bytes32\"},{\"name\":\"SecretKey\",\"type\":\"string\"},{\"name\":\"DrawStatus\",\"type\":\"string\"},{\"name\":\"WinHash\",\"type\":\"bytes32\"},{\"name\":\"WinningNumbers\",\"type\":\"uint8[5]\"},{\"name\":\"Hit3Count\",\"type\":\"uint256\"},{\"name\":\"Hit4Count\",\"type\":\"uint256\"},{\"name\":\"Hit5Count\",\"type\":\"uint256\"},{\"name\":\"Hit3Prize\",\"type\":\"uint256\"},{\"name\":\"Hit4Prize\",\"type\":\"uint256\"},{\"name\":\"Hit5Prize\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"AdminCloseContract\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"GameId\",\"type\":\"uint256\"}],\"name\":\"GameDetails\",\"outputs\":[{\"name\":\"Jackpot\",\"type\":\"uint256\"},{\"name\":\"TicketsCount\",\"type\":\"uint256\"},{\"name\":\"StartBlock\",\"type\":\"uint256\"},{\"name\":\"EndBlock\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Information\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"NewDrawer\",\"type\":\"address\"}],\"name\":\"AdminSetDrawer\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"AdminDrawProcess\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"AdminAddFunds\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tickets\",\"type\":\"bytes5[]\"}],\"name\":\"UserAddTicket\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"UserGetPrize\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"UserCheckBalance\",\"outputs\":[{\"name\":\"Balance\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Address\",\"type\":\"address\"},{\"name\":\"GameId\",\"type\":\"uint256\"},{\"name\":\"TicketNumber\",\"type\":\"uint256\"}],\"name\":\"CheckTickets\",\"outputs\":[{\"name\":\"Numbers\",\"type\":\"uint8[5]\"},{\"name\":\"Hits\",\"type\":\"uint256\"},{\"name\":\"Paid\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"secret_Key\",\"type\":\"string\"},{\"name\":\"New_secret_Key_Hash\",\"type\":\"bytes32\"}],\"name\":\"AdminStartDraw\",\"outputs\":[{\"name\":\"ret\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"AdminGetFee\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"AdminDrawError\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ContractStatus\",\"outputs\":[{\"name\":\"Enabled\",\"type\":\"bool\"}],\"type\":\"function\"},{\"inputs\":[{\"name\":\"SecretKeyHash\",\"type\":\"bytes32\"}],\"type\":\"constructor\"}]", "ContractName": "cEthereumlotteryNet", "CompilerVersion": "v0.3.1-nightly.2016.3.31+commit.c67926c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "ffb06f0fbc9d9b79909b5f0e93db3c811b41565a373fa6003913516f518e60c5", "Library": "", "SwarmSource": ""}]}