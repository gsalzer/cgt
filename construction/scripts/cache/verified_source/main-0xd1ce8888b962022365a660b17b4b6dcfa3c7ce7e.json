{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.25;\r\n\r\n\r\n// * DICE.SX: dice.sx (DSX) - Fair Game, Real Gain.\r\n// * \r\n// *\r\n// * 100% Fair Ethereum Games.\r\n// * No cheat. No signup required. No bullshit.\r\n// *\r\n// * All code and calculations are executed by smart contract.\r\n// * That means 100% transparency, everything is calculated by this contact (including random hash generation).\r\n// *\r\n// * Contract address: 0xd1ce8888b962022365a660b17b4b6dcfa3c7ce7e\r\n// *\r\n// *\r\n// * Website: https://dice.sx\r\n//\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Jackpot.sol\r\n\r\ncontract Jackpot is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Range {\r\n        uint256 end;\r\n        address player;\r\n    }\r\n\r\n    uint256 constant public NO_WINNER = uint256(-1);\r\n    uint256 constant public BLOCK_STEP = 100; // Every 100 blocks\r\n    uint256 constant public PROBABILITY = 500; // 1/500 prob, each 9 days\r\n\r\n    uint256 public winnerOffset = NO_WINNER;\r\n    uint256 public totalLength;\r\n    mapping (uint256 => Range) public ranges;\r\n    mapping (address => uint256) public playerLengths;\r\n\r\n    function () public payable onlyOwner {\r\n    }\r\n\r\n    function addRange(address player, uint256 length) public onlyOwner returns(uint256 begin, uint256 end) {\r\n        begin = totalLength;\r\n        end = begin.add(length);\r\n\r\n        playerLengths[player] += length;\r\n        ranges[begin] = Range({\r\n            end: end,\r\n            player: player\r\n        });\r\n\r\n        totalLength = end;\r\n    }\r\n\r\n    function candidateBlockNumber() public view returns(uint256) {\r\n        return block.number.sub(1).div(BLOCK_STEP).mul(BLOCK_STEP);\r\n    }\r\n\r\n    function candidateBlockNumberHash() public view returns(uint256) {\r\n        return uint256(blockhash(candidateBlockNumber()));\r\n    }\r\n\r\n    function candidateNextBlockNumberHash() public view returns(uint256) {\r\n        return uint256(blockhash(candidateBlockNumber() + 1));\r\n    }\r\n\r\n    function shouldSelectWinner() public view returns(bool) {\r\n        return totalLength > 0 &&\r\n            block.number > candidateBlockNumber() + 1 &&\r\n            (candidateBlockNumberHash() ^ uint256(this)) % PROBABILITY == 0;\r\n    }\r\n\r\n    function selectWinner() public onlyOwner returns(uint256) {\r\n        require(winnerOffset == NO_WINNER, \"Winner was selected\");\r\n        require(shouldSelectWinner(), \"Winner could not be selected now\");\r\n\r\n        winnerOffset = (candidateNextBlockNumberHash() / PROBABILITY) % totalLength;\r\n        return winnerOffset;\r\n    }\r\n\r\n    function payJackpot(uint256 begin) public onlyOwner {\r\n        Range storage range = ranges[begin];\r\n        require(winnerOffset != NO_WINNER, \"Winner was not selected\");\r\n        require(begin <= winnerOffset && winnerOffset < range.end, \"Not winning range\");\r\n\r\n        selfdestruct(range.player);\r\n    }\r\n}\r\n\r\n// File: contracts/SX.sol\r\n\r\ncontract SX is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string constant public name = \"DICE.SX\";\r\n    string constant public symbol = \"DSX\";\r\n\r\n    uint256 public adminFeePercent = 1;   // 1%\r\n    uint256 public jackpotFeePercent = 1; // 1%\r\n    uint256 public maxRewardPercent = 10; // 10%\r\n    uint256 public minReward = 0.01 ether;\r\n    uint256 public maxReward = 3 ether;\r\n    \r\n    struct Game {\r\n        address player;\r\n        uint256 blockNumber;\r\n        uint256 value;\r\n        uint256 combinations;\r\n        uint256 answer;\r\n        uint256 salt;\r\n    }\r\n\r\n    Game[] public games;\r\n    uint256 public gamesFinished;\r\n    uint256 public totalWeisInGame;\r\n    \r\n    Jackpot public nextJackpot;\r\n    Jackpot[] public prevJackpots;\r\n\r\n    event GameStarted(\r\n        address indexed player,\r\n        uint256 indexed blockNumber,\r\n        uint256 indexed index,\r\n        uint256 combinations,\r\n        uint256 answer,\r\n        uint256 value\r\n    );\r\n    event GameFinished(\r\n        address indexed player,\r\n        uint256 indexed blockNumber,\r\n        uint256 value,\r\n        uint256 combinations,\r\n        uint256 answer,\r\n        uint256 result\r\n    );\r\n\r\n    event JackpotRangeAdded(\r\n        uint256 indexed jackpotIndex,\r\n        address indexed player,\r\n        uint256 indexed begin,\r\n        uint256 end\r\n    );\r\n    event JackpotWinnerSelected(\r\n        uint256 indexed jackpotIndex,\r\n        uint256 offset\r\n    );\r\n    event JackpotRewardPayed(\r\n        uint256 indexed jackpotIndex,\r\n        address indexed player,\r\n        uint256 begin,\r\n        uint256 end,\r\n        uint256 winnerOffset,\r\n        uint256 value\r\n    );\r\n\r\n    constructor() public {\r\n        nextJackpot = new Jackpot();\r\n    }\r\n\r\n    function () public payable {\r\n        // Coin flip\r\n        uint256 prevBlockHash = uint256(blockhash(block.number - 1));\r\n        play(2, 1 << (prevBlockHash % 2));\r\n    }\r\n\r\n    function gamesLength() public view returns(uint256) {\r\n        return games.length;\r\n    }\r\n\r\n    function prevJackpotsLength() public view returns(uint256) {\r\n        return prevJackpots.length;\r\n    }\r\n\r\n    function updateState() public {\r\n        finishAllGames();\r\n\r\n        if (nextJackpot.shouldSelectWinner()) {\r\n            nextJackpot.selectWinner();\r\n            emit JackpotWinnerSelected(prevJackpots.length, nextJackpot.winnerOffset());\r\n\r\n            prevJackpots.push(nextJackpot);\r\n            nextJackpot = new Jackpot();\r\n        }\r\n    }\r\n\r\n    function playAndFinishJackpot(\r\n        uint256 combinations,\r\n        uint256 answer,\r\n        uint256 jackpotIndex,\r\n        uint256 begin\r\n    ) \r\n        public\r\n        payable\r\n    {\r\n        finishJackpot(jackpotIndex, begin);\r\n        play(combinations, answer);\r\n    }\r\n\r\n    function play(uint256 combinations, uint256 answer) public payable {\r\n        uint256 answerSize = _countBits(answer);\r\n        uint256 possibleReward = msg.value.mul(combinations).div(answerSize);\r\n        require(minReward <= possibleReward && possibleReward <= maxReward, \"Possible reward value out of range\");\r\n        require(possibleReward <= address(this).balance.mul(maxRewardPercent).div(100), \"Possible reward value out of range\");\r\n        require(answer > 0 && answer < (1 << combinations) - 1, \"Answer should not contain all bits set\");\r\n        require(2 <= combinations && combinations <= 100, \"Combinations value is invalid\");\r\n\r\n        // Update\r\n        updateState();\r\n\r\n        // Play game\r\n        uint256 blockNumber = block.number + 1;\r\n        emit GameStarted(\r\n            msg.sender,\r\n            blockNumber,\r\n            games.length,\r\n            combinations,\r\n            answer,\r\n            msg.value\r\n        );\r\n        games.push(Game({\r\n            player: msg.sender,\r\n            blockNumber: blockNumber,\r\n            value: msg.value,\r\n            combinations: combinations,\r\n            answer: answer,\r\n            salt: nextJackpot.totalLength()\r\n        }));\r\n\r\n        (uint256 begin, uint256 end) = nextJackpot.addRange(msg.sender, msg.value);\r\n        emit JackpotRangeAdded(\r\n            prevJackpots.length,\r\n            msg.sender,\r\n            begin,\r\n            end\r\n        );\r\n\r\n        totalWeisInGame = totalWeisInGame.add(possibleReward);\r\n        require(totalWeisInGame <= address(this).balance, \"Not enough balance\");\r\n    }\r\n\r\n    function finishAllGames() public returns(uint256 count) {\r\n        while (finishNextGame()) {\r\n            count += 1;\r\n        }\r\n    }\r\n\r\n    function finishNextGame() public returns(bool) {\r\n        if (gamesFinished >= games.length) {\r\n            return false;\r\n        }\r\n\r\n        Game storage game = games[gamesFinished];\r\n        if (game.blockNumber >= block.number) {\r\n            return false;\r\n        }\r\n\r\n        uint256 hash = uint256(blockhash(game.blockNumber));\r\n        bool lose = (hash == 0);\r\n        hash = uint256(keccak256(abi.encodePacked(hash, game.salt)));\r\n\r\n        uint256 answerSize = _countBits(game.answer);\r\n        uint256 reward = game.value.mul(game.combinations).div(answerSize);\r\n        \r\n        uint256 result = 1 << (hash % game.combinations);\r\n        if (!lose && (result & game.answer) != 0) {\r\n            uint256 adminFee = reward.mul(adminFeePercent).div(100);\r\n            uint256 jackpotFee = reward.mul(jackpotFeePercent).div(100);\r\n\r\n            owner().send(adminFee);                                 // solium-disable-line security/no-send\r\n            address(nextJackpot).send(jackpotFee);                  // solium-disable-line security/no-send\r\n            game.player.send(reward.sub(adminFee).sub(jackpotFee)); // solium-disable-line security/no-send\r\n        }\r\n\r\n        emit GameFinished(\r\n            game.player,\r\n            game.blockNumber,\r\n            game.value,\r\n            game.combinations,\r\n            game.answer,\r\n            result\r\n        );\r\n        delete games[gamesFinished];\r\n        totalWeisInGame = totalWeisInGame.sub(reward);\r\n        gamesFinished += 1;\r\n        return true;\r\n    }\r\n\r\n    function finishJackpot(uint256 jackpotIndex, uint256 begin) public {\r\n        if (jackpotIndex >= prevJackpots.length) {\r\n            return;\r\n        }\r\n\r\n        Jackpot jackpot = prevJackpots[jackpotIndex];\r\n        if (address(jackpot).balance == 0) {\r\n            return;\r\n        }\r\n\r\n        (uint256 end, address player) = jackpot.ranges(begin);\r\n        uint256 winnerOffset = jackpot.winnerOffset();\r\n        uint256 value = address(jackpot).balance;\r\n        jackpot.payJackpot(begin);\r\n        delete prevJackpots[jackpotIndex];\r\n        emit JackpotRewardPayed(\r\n            jackpotIndex,\r\n            player,\r\n            begin,\r\n            end,\r\n            winnerOffset,\r\n            value\r\n        );\r\n    }\r\n\r\n    // Admin methods\r\n\r\n    function setAdminFeePercent(uint256 feePercent) public onlyOwner {\r\n        require(feePercent <= 2, \"Should be <= 2%\");\r\n        adminFeePercent = feePercent;\r\n    }\r\n\r\n    function setJackpotFeePercent(uint256 feePercent) public onlyOwner {\r\n        require(feePercent <= 3, \"Should be <= 3%\");\r\n        jackpotFeePercent = feePercent;\r\n    }\r\n\r\n    function setMaxRewardPercent(uint256 value) public onlyOwner {\r\n        require(value <= 100, \"Should not exceed 100%\");\r\n        maxRewardPercent = value;\r\n    }\r\n\r\n    function setMinReward(uint256 value) public onlyOwner {\r\n        minReward = value;\r\n    }\r\n\r\n    function setMaxReward(uint256 value) public onlyOwner {\r\n        maxReward = value;\r\n    }\r\n\r\n    function putToBank() public payable onlyOwner {\r\n    }\r\n\r\n    function getFromBank(uint256 value) public onlyOwner {\r\n        msg.sender.transfer(value);\r\n        require(totalWeisInGame <= address(this).balance, \"Not enough balance\");\r\n    }\r\n\r\n    function _countBits(uint256 arg) internal pure returns(uint256 count) {\r\n        uint256 value = arg;\r\n        while (value != 0) {\r\n            value &= value - 1; // clear the least significant bit set\r\n            count++;\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"nextJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamesFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"combinations\",\"type\":\"uint256\"},{\"name\":\"answer\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRewardPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prevJackpots\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"jackpotIndex\",\"type\":\"uint256\"},{\"name\":\"begin\",\"type\":\"uint256\"}],\"name\":\"finishJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"getFromBank\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeisInGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishNextGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"combinations\",\"type\":\"uint256\"},{\"name\":\"answer\",\"type\":\"uint256\"}],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"combinations\",\"type\":\"uint256\"},{\"name\":\"answer\",\"type\":\"uint256\"},{\"name\":\"jackpotIndex\",\"type\":\"uint256\"},{\"name\":\"begin\",\"type\":\"uint256\"}],\"name\":\"playAndFinishJackpot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prevJackpotsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxRewardPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feePercent\",\"type\":\"uint256\"}],\"name\":\"setJackpotFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMinReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"feePercent\",\"type\":\"uint256\"}],\"name\":\"setAdminFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishAllGames\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"putToBank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"combinations\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"answer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"combinations\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"answer\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"GameFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"jackpotIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"begin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"JackpotRangeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"jackpotIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"JackpotWinnerSelected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"jackpotIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"begin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerOffset\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"JackpotRewardPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "SX", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://86be07d26ed53ab36c247e3d39d8beabc7a29b6624014da1833c33318c609d54"}]}