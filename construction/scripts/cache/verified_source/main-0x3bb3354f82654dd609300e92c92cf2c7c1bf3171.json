{"status": "1", "message": "OK", "result": [{"SourceCode": "// MarketPay-System-1.2.sol\r\n\r\n/*\r\nMarketPay Solidity Libraries\r\ndeveloped by:\r\n\tMarketPay.io , 2018\r\n\thttps://marketpay.io/\r\n\thttps://goo.gl/kdECQu\r\n\r\nv1.2 \r\n\t+ Haltable by SC owner\r\n\t+ Constructors upgraded to new syntax\r\n\t\r\nv1.1 \r\n\t+ Upgraded to Solidity 0.4.22\r\n\t\r\nv1.0\r\n\t+ System functions\r\n\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n/**\r\n * @title System\r\n * @dev Abstract contract that includes some useful generic functions.\r\n * @author https://marketpay.io/ & https://goo.gl/kdECQu\r\n */\r\ncontract System {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\taddress owner;\r\n\t\r\n\t// **** MODIFIERS\r\n\r\n\t// @notice To limit functions usage to contract owner\r\n\tmodifier onlyOwner() {\r\n\t\tif (msg.sender != owner) {\r\n\t\t\terror('System: onlyOwner function called by user that is not owner');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\t// **** FUNCTIONS\r\n\t\r\n\t// @notice Calls whenever an error occurs, logs it or reverts transaction\r\n\tfunction error(string _error) internal {\r\n\t\trevert(_error);\r\n\t\t// in case revert with error msg is not yet fully supported\r\n\t\t//\temit Error(_error);\r\n\t\t// throw;\r\n\t}\r\n\r\n\t// @notice For debugging purposes when using solidity online browser, remix and sandboxes\r\n\tfunction whoAmI() public constant returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\t\r\n\t// @notice Get the current timestamp from last mined block\r\n\tfunction timestamp() public constant returns (uint256) {\r\n\t\treturn block.timestamp;\r\n\t}\r\n\t\r\n\t// @notice Get the balance in weis of this contract\r\n\tfunction contractBalance() public constant returns (uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\t\r\n\t// @notice System constructor, defines owner\r\n\tconstructor() public {\r\n\t\t// This is the constructor, so owner should be equal to msg.sender, and this method should be called just once\r\n\t\towner = msg.sender;\r\n\t\t\r\n\t\t// make sure owner address is configured\r\n\t\tif(owner == 0x0) error('System constructor: Owner address is 0x0'); // Never should happen, but just in case...\r\n\t}\r\n\t\r\n\t// **** EVENTS\r\n\r\n\t// @notice A generic error log\r\n\tevent Error(string _error);\r\n\r\n\t// @notice For debug purposes\r\n\tevent DebugUint256(uint256 _data);\r\n\r\n}\r\n\r\n/**\r\n * @title Haltable\r\n * @dev Abstract contract that allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Haltable is System {\r\n\tbool public halted;\r\n\t\r\n\t// **** MODIFIERS\r\n\r\n\tmodifier stopInEmergency {\r\n\t\tif (halted) {\r\n\t\t\terror('Haltable: stopInEmergency function called and contract is halted');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\tmodifier onlyInEmergency {\r\n\t\tif (!halted) {\r\n\t\t\terror('Haltable: onlyInEmergency function called and contract is not halted');\r\n\t\t} {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\t// **** FUNCTIONS\r\n\t\r\n\t// called by the owner on emergency, triggers stopped state\r\n\tfunction halt() external onlyOwner {\r\n\t\thalted = true;\r\n\t\temit Halt(true, msg.sender, timestamp()); // Event log\r\n\t}\r\n\r\n\t// called by the owner on end of emergency, returns to normal state\r\n\tfunction unhalt() external onlyOwner onlyInEmergency {\r\n\t\thalted = false;\r\n\t\temit Halt(false, msg.sender, timestamp()); // Event log\r\n\t}\r\n\t\r\n\t// **** EVENTS\r\n\t// @notice Triggered when owner halts contract\r\n\tevent Halt(bool _switch, address _halter, uint256 _timestamp);\r\n}\r\n\r\n/**\r\n * @title Hardcoded Wallets\r\n * @notice This contract is used to define oracle wallets\r\n * @author https://marketpay.io/ & https://goo.gl/kdECQu\r\n */\r\ncontract HardcodedWallets {\r\n\t// **** DATA\r\n\r\n\taddress public walletFounder1; // founder #1 wallet, CEO, compulsory\r\n\taddress public walletFounder2; // founder #2 wallet\r\n\taddress public walletFounder3; // founder #3 wallet\r\n\taddress public walletCommunityReserve;\t// Distribution wallet\r\n\taddress public walletCompanyReserve;\t// Distribution wallet\r\n\taddress public walletTeamAdvisors;\t\t// Distribution wallet\r\n\taddress public walletBountyProgram;\t\t// Distribution wallet\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\r\n\t/**\r\n\t * @notice Constructor, set up the compliance officer oracle wallet\r\n\t */\r\n\tconstructor() public {\r\n\t\t// set up the founders' oracle wallets\r\n\t\twalletFounder1             = 0x5E69332F57Ac45F5fCA43B6b007E8A7b138c2938; // founder #1 (CEO) wallet\r\n\t\twalletFounder2             = 0x852f9a94a29d68CB95Bf39065BED6121ABf87607; // founder #2 wallet\r\n\t\twalletFounder3             = 0x0a339965e52dF2c6253989F5E9173f1F11842D83; // founder #3 wallet\r\n\r\n\t\t// set up the wallets for distribution of the total supply of tokens\r\n\t\twalletCommunityReserve = 0xB79116a062939534042d932fe5DF035E68576547;\r\n\t\twalletCompanyReserve = 0xA6845689FE819f2f73a6b9C6B0D30aD6b4a006d8;\r\n\t\twalletTeamAdvisors = 0x0227038b2560dF1abf3F8C906016Af0040bc894a;\r\n\t\twalletBountyProgram = 0xdd401Df9a049F6788cA78b944c64D21760757D73;\r\n\r\n\t}\r\n}\r\n\r\n// Minimal interface of ERC20 token contract, just to cast the contract address and make it callable from the ICO and other contracts\r\ncontract ERC20 {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _amount) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\tfunction totalSupply() public constant returns (uint);\r\n}\r\n\r\n/**\r\n * @title Escrow\r\n * @author https://marketpay.io/ & https://goo.gl/kdECQu\r\n */\r\ncontract Escrow is System, HardcodedWallets {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// **** DATA\r\n\tmapping (address => uint256) public deposited;\r\n\tuint256 nextStage;\r\n\r\n\t// Circular reference to ICO contract\r\n\taddress public addressSCICO;\r\n\r\n\t// Circular reference to Tokens contract\r\n\taddress public addressSCTokens;\r\n\tTokens public SCTokens;\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\r\n\t/**\r\n\t * @notice Constructor, set up the state\r\n\t */\r\n\tconstructor() public {\r\n\t\t// copy totalSupply from Tokens to save gas\r\n\t\tuint256 totalSupply = 1350000000 ether;\r\n\r\n\r\n\t\tdeposited[this] = totalSupply.mul(50).div(100);\r\n\t\tdeposited[walletCommunityReserve] = totalSupply.mul(20).div(100);\r\n\t\tdeposited[walletCompanyReserve] = totalSupply.mul(14).div(100);\r\n\t\tdeposited[walletTeamAdvisors] = totalSupply.mul(15).div(100);\r\n\t\tdeposited[walletBountyProgram] = totalSupply.mul(1).div(100);\r\n\t}\r\n\r\n\tfunction deposit(uint256 _amount) public returns (bool) {\r\n\t\t// only ICO could deposit\r\n\t\tif (msg.sender != addressSCICO) {\r\n\t\t\terror('Escrow: not allowed to deposit');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdeposited[this] = deposited[this].add(_amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraw funds from the tokens contract\r\n\t */\r\n\tfunction withdraw(address _address, uint256 _amount) public onlyOwner returns (bool) {\r\n\t\tif (deposited[_address]<_amount) {\r\n\t\t\terror('Escrow: not enough balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdeposited[_address] = deposited[_address].sub(_amount);\r\n\t\treturn SCTokens.transfer(_address, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Withdraw funds from the tokens contract\r\n\t */\r\n\tfunction fundICO(uint256 _amount, uint8 _stage) public returns (bool) {\r\n\t\tif(nextStage !=_stage) {\r\n\t\t\terror('Escrow: ICO stage already funded');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (msg.sender != addressSCICO || tx.origin != owner) {\r\n\t\t\terror('Escrow: not allowed to fund the ICO');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (deposited[this]<_amount) {\r\n\t\t\terror('Escrow: not enough balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tbool success = SCTokens.transfer(addressSCICO, _amount);\r\n\t\tif(success) {\r\n\t\t\tdeposited[this] = deposited[this].sub(_amount);\r\n\t\t\tnextStage++;\r\n\t\t\temit FundICO(addressSCICO, _amount);\r\n\t\t}\r\n\t\treturn success;\r\n\t}\r\n\r\n\t/**\r\n \t* @notice The owner can specify which ICO contract is allowed to transfer tokens while timelock is on\r\n \t*/\r\n\tfunction setMyICOContract(address _SCICO) public onlyOwner {\r\n\t\taddressSCICO = _SCICO;\r\n\t}\r\n\r\n\t/**\r\n \t* @notice Set the tokens contract\r\n \t*/\r\n\tfunction setTokensContract(address _addressSCTokens) public onlyOwner {\r\n\t\taddressSCTokens = _addressSCTokens;\r\n\t\tSCTokens = Tokens(_addressSCTokens);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Returns balance of given address\r\n\t */\r\n\tfunction balanceOf(address _address) public constant returns (uint256 balance) {\r\n\t\treturn deposited[_address];\r\n\t}\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when an investor buys some tokens directly with Ethers\r\n\tevent FundICO(address indexed _addressICO, uint256 _amount);\r\n\r\n\r\n}\r\n\r\ncontract ComplianceService {\r\n\tfunction validate(address _from, address _to, uint256 _amount) public returns (bool allowed) {\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Tokens\r\n * @notice ERC20 implementation of TRT tokens\r\n * @author https://marketpay.io/ & https://goo.gl/kdECQu\r\n */\r\ncontract Tokens is HardcodedWallets, ERC20, Haltable {\r\n\r\n\t// **** DATA\r\n\r\n\tmapping (address => uint256) balances;\r\n\tmapping (address => mapping (address => uint256)) allowed;\r\n\tuint256 public _totalSupply; \r\n\r\n\t// Public variables of the token, all used for display\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals;\r\n\tstring public standard = 'H0.1'; // HumanStandardToken is a specialisation of ERC20 defining these parameters\r\n\r\n\t// Timelock\r\n\tuint256 public timelockEndTime;\r\n\r\n\t// Circular reference to ICO contract\r\n\taddress public addressSCICO;\r\n\r\n\t// Circular reference to Escrow contract\r\n\taddress public addressSCEscrow;\r\n\r\n\t// Reference to ComplianceService contract\r\n\taddress public addressSCComplianceService;\r\n\tComplianceService public SCComplianceService;\r\n\r\n\t// **** MODIFIERS\r\n\r\n\t// @notice To limit token transfers while timelocked\r\n\tmodifier notTimeLocked() {\r\n\t\tif (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {\r\n\t\t\terror('notTimeLocked: Timelock still active. Function is yet unavailable.');\r\n\t\t} else {\r\n\t\t\t_;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// **** FUNCTIONS\r\n\t/**\r\n\t * @notice Constructor: set up token properties and owner token balance\r\n\t */\r\n\tconstructor(address _addressSCEscrow, address _addressSCComplianceService) public {\r\n\t\tname = \"TheRentalsToken\";\r\n\t\tsymbol = \"TRT\";\r\n\t\tdecimals = 18; // 18 decimal places, the same as ETH\r\n\r\n\t\t// initialSupply = 2000000000 ether; // 2018-04-21: ICO summary.docx: ...Dicho valor generar\u00eda un Total Supply de 2.000 millones de TRT.\r\n        _totalSupply = 1350000000 ether; // 2018-05-10: alvaro.ariet@lacomunity.com ...tenemos una emisi\u00f3n de 1.350 millones de Tokens\r\n\r\n\t\ttimelockEndTime = timestamp().add(45 days); // Default timelock\r\n\r\n\t\taddressSCEscrow = _addressSCEscrow;\r\n\t\taddressSCComplianceService = _addressSCComplianceService;\r\n\t\tSCComplianceService = ComplianceService(addressSCComplianceService);\r\n\r\n\t\t// Token distribution\r\n\t\tbalances[_addressSCEscrow] = _totalSupply;\r\n\t\temit Transfer(0x0, _addressSCEscrow, _totalSupply);\r\n\r\n\t}\r\n\r\n    /**\r\n     * @notice Get the token total supply\r\n     */\r\n    function totalSupply() public constant returns (uint) {\r\n\r\n        return _totalSupply  - balances[address(0)];\r\n\r\n    }\r\n\r\n\t/**\r\n\t * @notice Get the token balance of a wallet with address _owner\r\n\t */\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Send _amount amount of tokens to address _to\r\n\t */\r\n\tfunction transfer(address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n\t\tif (balances[msg.sender] < _amount) {\r\n\t\t\terror('transfer: the amount to transfer is higher than your token balance');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(!SCComplianceService.validate(msg.sender, _to, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_amount);\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\temit Transfer(msg.sender, _to, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Send _amount amount of tokens from address _from to address _to\r\n \t * @notice The transferFrom method is used for a withdraw workflow, allowing contracts to send \r\n \t * @notice tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge \r\n \t * @notice fees in sub-currencies; the command should fail unless the _from account has \r\n \t * @notice deliberately authorized the sender of the message via some mechanism\r\n \t */\r\n\tfunction transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n\t\tif (balances[_from] < _amount) {\r\n\t\t\terror('transferFrom: the amount to transfer is higher than the token balance of the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (allowed[_from][msg.sender] < _amount) {\r\n\t\t\terror('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(!SCComplianceService.validate(_from, _to, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_amount);\r\n\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n\t\temit Transfer(_from, _to, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Allow _spender to withdraw from your account, multiple times, up to the _amount amount. \r\n \t * @notice If this function is called again it overwrites the current allowance with _amount.\r\n\t */\r\n\tfunction approve(address _spender, uint256 _amount) public returns (bool success) {\r\n\t\tallowed[msg.sender][_spender] = _amount;\r\n\t\temit Approval(msg.sender, _spender, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner\r\n\t */\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n       * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n       *\r\n       * approve should be called when allowed[_spender] == 0. To increment\r\n       * allowed value is better to use this function to avoid 2 calls (and wait until\r\n       * the first transaction is mined)\r\n       * From MonolithDAO Token.sol\r\n       * @param _spender The address which will spend the funds.\r\n       * @param _addedValue The amount of tokens to increase the allowance by.\r\n       */\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t\tuint oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @notice This is out of ERC20 standard but it is necessary to build market escrow contracts of assets\r\n\t * @notice Send _amount amount of tokens to from tx.origin to address _to\r\n\t */\r\n\tfunction refundTokens(address _from, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\r\n        if (tx.origin != _from) {\r\n            error('refundTokens: tx.origin did not request the refund directly');\r\n            return false;\r\n        }\r\n\r\n        if (addressSCICO != msg.sender) {\r\n            error('refundTokens: caller is not the current ICO address');\r\n            return false;\r\n        }\r\n\r\n        if (balances[_from] < _amount) {\r\n            error('refundTokens: the amount to transfer is higher than your token balance');\r\n            return false;\r\n        }\r\n\r\n        if(!SCComplianceService.validate(_from, addressSCICO, _amount)) {\r\n\t\t\terror('transfer: not allowed by the compliance service');\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tbalances[_from] = balances[_from].sub(_amount);\r\n\t\tbalances[addressSCICO] = balances[addressSCICO].add(_amount);\r\n\t\temit Transfer(_from, addressSCICO, _amount); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice The owner can specify which ICO contract is allowed to transfer tokens while timelock is on\r\n\t */\r\n\tfunction setMyICOContract(address _SCICO) public onlyOwner {\r\n\t\taddressSCICO = _SCICO;\r\n\t}\r\n\r\n\tfunction setComplianceService(address _addressSCComplianceService) public onlyOwner {\r\n\t\taddressSCComplianceService = _addressSCComplianceService;\r\n\t\tSCComplianceService = ComplianceService(addressSCComplianceService);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Called by owner to alter the token timelock\r\n\t */\r\n\tfunction updateTimeLock(uint256 _timelockEndTime) onlyOwner public returns (bool) {\r\n\t\ttimelockEndTime = _timelockEndTime;\r\n\r\n\t\temit UpdateTimeLock(_timelockEndTime); // Event log\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t// **** EVENTS\r\n\r\n\t// Triggered when tokens are transferred\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n\r\n\t// Triggered when someone approves a spender to move its tokens\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n\r\n\t// Triggered when Owner updates token timelock\r\n\tevent UpdateTimeLock(uint256 _timelockEndTime);\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressSCComplianceService\",\"type\":\"address\"}],\"name\":\"setComplianceService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timelockEndTime\",\"type\":\"uint256\"}],\"name\":\"updateTimeLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletCommunityReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"refundTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletTeamAdvisors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletFounder3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SCComplianceService\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressSCComplianceService\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletCompanyReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressSCEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_SCICO\",\"type\":\"address\"}],\"name\":\"setMyICOContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unhalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whoAmI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressSCICO\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"walletBountyProgram\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressSCEscrow\",\"type\":\"address\"},{\"name\":\"_addressSCComplianceService\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timelockEndTime\",\"type\":\"uint256\"}],\"name\":\"UpdateTimeLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_switch\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_halter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"Halt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_error\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_data\",\"type\":\"uint256\"}],\"name\":\"DebugUint256\",\"type\":\"event\"}]", "ContractName": "Tokens", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000591621e47e0f929f8dbece49ea23e42537944b74000000000000000000000000ff77264bb6899aaeae39bb41d710cdef189e2f3c", "Library": "", "SwarmSource": "bzzr://55910d8903a3de8261e87c734713894bd04f692216e1bf629419e83ab92935cf"}]}