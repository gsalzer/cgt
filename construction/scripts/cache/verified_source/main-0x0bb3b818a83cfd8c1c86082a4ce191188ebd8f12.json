{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.13;\r\n\r\n//inspired by multiple tokensale contracts\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    require(assertion);\r\n  }\r\n}\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract Controller {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}\r\n\r\n// inspired by Zeppelin's Vested Token deriving MiniMeToken\r\n\r\n// @dev MiniMeIrrevocableVestedToken is a derived version of MiniMeToken adding the\r\n// ability to createTokenGrants which are basically a transfer that limits the\r\n// receiver of the tokens.\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController{ require(msg.sender==controller); _; }\r\n\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ApproveAndCallReceiver {\r\n    function receiveApproval(address _from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() constant returns (uint);\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract MiniMeToken is ERC20, Controlled {\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = 'MMT_0.1'; //An arbitrary versioning scheme\r\n\r\n\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // `parentToken` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    //  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n    /// @notice Constructor to create a MiniMeToken\r\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    ///  will create the Clone token contracts, the token factory needs to be\r\n    ///  deployed first\r\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param _parentSnapShotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token, set to 0 if it\r\n    ///  is a new token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        require (transfersEnabled);\r\n    ////if (!transfersEnabled) throw;\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            require (transfersEnabled);\r\n\r\n            ////if (!transfersEnabled) throw;\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            assert (allowed[_from][msg.sender]>=_amount);\r\n\r\n            ////if (allowed[_from][msg.sender] < _amount) throw;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           require((_to!=0)&&(_to!=address(this)));\r\n\r\n           //// if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           assert(previousBalanceFrom >= _amount);\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               assert(Controller(controller).onTransfer(_from,_to,_amount));\r\n\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           \r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           assert(previousBalanceTo+_amount>=previousBalanceTo); \r\n           \r\n           //// if (previousBalanceTo + _amount < previousBalanceTo) throw; // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        // To change the approve amount you first have to reduce the addresses\u00b4\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\r\n        require((_amount==0)||(allowed[msg.sender][_spender]==0));\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            assert(Controller(controller).onApprove(msg.sender,_spender,_amount));\r\n\r\n            //  if (!Controller(controller).onApprove(msg.sender, _spender, _amount))\r\n            //        throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        approve(_spender, _amount);\r\n\r\n        // This portion is copied from ConsenSys's Standard Token Contract. It\r\n        //  calls the receiveApproval function that is part of the contract that\r\n        //  is being approved (`_spender`). The function should look like:\r\n        //  `receiveApproval(address _from, uint256 _amount, address\r\n        //  _tokenContract, bytes _extraData)` It is assumed that the call\r\n        //  *should* succeed, otherwise the plain vanilla approve would be used\r\n        ApproveAndCallReceiver(_spender).receiveApproval(\r\n           msg.sender,\r\n           _amount,\r\n           this,\r\n           _extraData\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n    function min(uint a, uint b) internal returns (uint) {\r\n      return a < b ? a : b;\r\n    }\r\n\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is higher than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) returns(address) {\r\n        if (_snapshotBlock > block.number) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        assert(curTotalSupply+_amount>=curTotalSupply);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        assert(previousBalanceTo+_amount>=previousBalanceTo);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        assert(curTotalSupply >= _amount);\r\n        \r\n        //// if (curTotalSupply < _amount) throw;\r\n\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        assert(previousBalanceFrom >=_amount);\r\n\r\n        //// if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        require(isContract(controller));\r\n        assert(Controller(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n\r\n\r\n////////////////\r\n// MiniMeTokenFactory\r\n////////////////\r\n\r\n/// @dev This contract is used to generate clone contracts from a contract.\r\n///  In solidity this is the way to create a contract from a contract of the\r\n///  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    /// @notice Update the DApp by creating a new token with new functionalities\r\n    ///  the msg.sender becomes the controller of this clone token\r\n    /// @param _parentToken Address of the token being cloned\r\n    /// @param _snapshotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    /// @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\ncontract MiniMeIrrevocableVestedToken is MiniMeToken, SafeMath {\r\n\r\n  uint256 MAX_GRANTS_PER_ADDRESS = 20;\r\n\r\n  // Keep the struct at 3 sstores ( total value  20+32+24 =76 bytes)\r\n  struct TokenGrant {\r\n    address granter;  // 20 bytes\r\n    uint256 value;    // 32 bytes\r\n    uint64 cliff;\r\n    uint64 vesting;\r\n    uint64 start;     // 3*8 =24 bytes\r\n  }\r\n\r\n  event NewTokenGrant(address indexed from, address indexed to, uint256 value, uint64 start, uint64 cliff, uint64 vesting);\r\n\r\n  mapping (address => TokenGrant[]) public grants;\r\n\r\n  mapping (address => bool) canCreateGrants;\r\n  address vestingWhitelister;\r\n\r\n  modifier canTransfer(address _sender, uint _value) {\r\n    require(_value<=spendableBalanceOf(_sender));\r\n    _;\r\n  }\r\n\r\n  modifier onlyVestingWhitelister {\r\n    require(msg.sender==vestingWhitelister);\r\n    _;\r\n  }\r\n\r\n  function MiniMeIrrevocableVestedToken (\r\n      address _tokenFactory,\r\n      address _parentToken,\r\n      uint _parentSnapShotBlock,\r\n      string _tokenName,\r\n      uint8 _decimalUnits,\r\n      string _tokenSymbol,\r\n      bool _transfersEnabled\r\n  ) MiniMeToken(_tokenFactory, _parentToken, _parentSnapShotBlock, _tokenName, _decimalUnits, _tokenSymbol, _transfersEnabled) {\r\n    vestingWhitelister = msg.sender;\r\n    doSetCanCreateGrants(vestingWhitelister, true);\r\n  }\r\n\r\n  // @dev Checks modifier and allows transfer if tokens are not locked.\r\n  function transfer(address _to, uint _value)\r\n           canTransfer(msg.sender, _value)\r\n           public\r\n           returns (bool success) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value)\r\n           canTransfer(_from, _value)\r\n           public\r\n           returns (bool success) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function spendableBalanceOf(address _holder) constant public returns (uint) {\r\n    return transferableTokens(_holder, uint64(now));\r\n  }\r\n\r\n  // main func for token grant\r\n\r\n  function grantVestedTokens(\r\n    address _to,\r\n    uint256 _value,\r\n    uint64 _start,\r\n    uint64 _cliff,\r\n    uint64 _vesting) public {\r\n\r\n    // Check start, cliff and vesting are properly order to ensure correct functionality of the formula.\r\n\r\n    require(_cliff >= _start && _vesting >= _cliff);\r\n    \r\n    require(tokenGrantsCount(_to)<=MAX_GRANTS_PER_ADDRESS); //// To prevent a user being spammed and have his balance locked (out of gas attack when calculating vesting).\r\n\r\n    assert(canCreateGrants[msg.sender]);\r\n\r\n\r\n    TokenGrant memory grant = TokenGrant(msg.sender, _value, _cliff, _vesting, _start);\r\n    grants[_to].push(grant);\r\n\r\n    assert(transfer(_to,_value));\r\n\r\n    NewTokenGrant(msg.sender, _to, _value, _cliff, _vesting, _start);\r\n  }\r\n\r\n  function setCanCreateGrants(address _addr, bool _allowed)\r\n           onlyVestingWhitelister public {\r\n    doSetCanCreateGrants(_addr, _allowed);\r\n  }\r\n\r\n  function doSetCanCreateGrants(address _addr, bool _allowed)\r\n           internal {\r\n    canCreateGrants[_addr] = _allowed;\r\n  }\r\n\r\n  function changeVestingWhitelister(address _newWhitelister) onlyVestingWhitelister public {\r\n    doSetCanCreateGrants(vestingWhitelister, false);\r\n    vestingWhitelister = _newWhitelister;\r\n    doSetCanCreateGrants(vestingWhitelister, true);\r\n  }\r\n\r\n  function tokenGrantsCount(address _holder) constant public returns (uint index) {\r\n    return grants[_holder].length;\r\n  }\r\n\r\n  function tokenGrant(address _holder, uint _grantId) constant public returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting) {\r\n    TokenGrant storage grant = grants[_holder][_grantId];\r\n\r\n    granter = grant.granter;\r\n    value = grant.value;\r\n    start = grant.start;\r\n    cliff = grant.cliff;\r\n    vesting = grant.vesting;\r\n\r\n    vested = vestedTokens(grant, uint64(now));\r\n  }\r\n\r\n  function vestedTokens(TokenGrant grant, uint64 time) internal constant returns (uint256) {\r\n    return calculateVestedTokens(\r\n      grant.value,\r\n      uint256(time),\r\n      uint256(grant.start),\r\n      uint256(grant.cliff),\r\n      uint256(grant.vesting)\r\n    );\r\n  }\r\n\r\n  //  transferableTokens\r\n  //   |                         _/--------   NonVestedTokens\r\n  //   |                       _/\r\n  //   |                     _/\r\n  //   |                   _/\r\n  //   |                 _/\r\n  //   |                /\r\n  //   |              .|\r\n  //   |            .  |\r\n  //   |          .    |\r\n  //   |        .      |\r\n  //   |      .        |\r\n  //   |    .          |\r\n  //   +===+===========+---------+----------> time\r\n  //      Start       Cliff    Vesting\r\n\r\n  function calculateVestedTokens(\r\n    uint256 tokens,\r\n    uint256 time,\r\n    uint256 start,\r\n    uint256 cliff,\r\n    uint256 vesting) internal constant returns (uint256)\r\n    {\r\n\r\n    // Shortcuts for before cliff and after vesting cases.\r\n    if (time < cliff) return 0;\r\n    if (time >= vesting) return tokens;\r\n\r\n    // Interpolate all vested tokens.\r\n    // As before cliff the shortcut returns 0, we can use just this function to\r\n    // calculate it.\r\n\r\n    // vestedTokens = tokens * (time - start) / (vesting - start)\r\n    uint256 vestedTokens = safeDiv(\r\n                                  safeMul(\r\n                                    tokens,\r\n                                    safeSub(time, start)\r\n                                    ),\r\n                                  safeSub(vesting, start)\r\n                                  );\r\n\r\n    return vestedTokens;\r\n  }\r\n\r\n  function nonVestedTokens(TokenGrant grant, uint64 time) internal constant returns (uint256) {\r\n    return safeSub(grant.value, vestedTokens(grant, time));\r\n  }\r\n\r\n  // @dev The date in which all tokens are transferable for the holder\r\n  // Useful for displaying purposes (not used in any logic calculations)\r\n  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {\r\n    date = uint64(now);\r\n    uint256 grantIndex = tokenGrantsCount(holder);\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      date = max64(grants[holder][i].vesting, date);\r\n    }\r\n    return date;\r\n  }\r\n\r\n  // @dev How many tokens can a holder transfer at a point in time\r\n  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n    uint256 grantIndex = tokenGrantsCount(holder);\r\n\r\n    if (grantIndex == 0) return balanceOf(holder); // shortcut for holder without grants\r\n\r\n    // Iterate through all the grants the holder has, and add all non-vested tokens\r\n    uint256 nonVested = 0;\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      nonVested = safeAdd(nonVested, nonVestedTokens(grants[holder][i], time));\r\n    }\r\n\r\n    // Balance - totalNonVested is the amount of tokens a holder can transfer at any given time\r\n    return safeSub(balanceOf(holder), nonVested);\r\n  }\r\n}\r\n\r\n\r\ncontract GNR is MiniMeIrrevocableVestedToken {\r\n  // @dev GNR constructor just parametrizes the MiniMeIrrevocableVestedToken constructor\r\n  function GNR(\r\n    address _tokenFactory\r\n  ) MiniMeIrrevocableVestedToken(\r\n    _tokenFactory,\r\n    0x0,                    // no parent token\r\n    0,                      // no snapshot block number from parent\r\n    \"Genaro Network Token\", // Token name\r\n    9,                     // Decimals\r\n    \"GNR\",                  // Symbol\r\n    true                    // Enable transfers\r\n    ) {}\r\n}\r\n\r\n/*\r\n\r\n@notice The GRPlaceholder contract will take control over the GNR after the sale\r\n        is finalized and before the Genaro Network is deployed.\r\n\r\n        The contract allows for GNR transfers and transferFrom and implements the\r\n        logic for transfering control of the token to the network when the sale\r\n        asks it to do so.\r\n*/\r\n\r\ncontract GRPlaceholder is Controller {\r\n  address public sale;\r\n  GNR public token;\r\n\r\n  function GRPlaceholder(address _sale, address _gnr) {\r\n    sale = _sale;\r\n    token = GNR(_gnr);\r\n  }\r\n\r\n  function changeController(address network) public {\r\n    require(msg.sender == sale);\r\n    token.changeController(network);\r\n    suicide(network);\r\n  }\r\n\r\n  // In between the sale and the network. Default settings for allowing token transfers.\r\n  function proxyPayment(address) payable public returns (bool) {\r\n    return false;\r\n  }\r\n\r\n  function onTransfer(address, address, uint) public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function onApprove(address, address, uint) public returns (bool) {\r\n    return true;\r\n  }\r\n}\r\n\r\n// @dev Contract to hold sale raised funds during the sale period.\r\n// Prevents attack in which the Genaro Multisig sends raised ether\r\n// to the sale contract to mint tokens to itself, and getting the\r\n// funds back immediately.\r\n\r\ncontract AbstractSale {\r\n  function saleFinalized() constant returns (bool);\r\n}\r\n\r\ncontract SaleWallet {\r\n  // Public variables\r\n  address public multisig;\r\n  uint public finalBlock;\r\n  AbstractSale public tokenSale;\r\n\r\n  // @dev Constructor initializes public variables\r\n  // @param _multisig The address of the multisig that will receive the funds\r\n  // @param _finalBlock Block after which the multisig can request the funds\r\n  function SaleWallet(address _multisig, uint _finalBlock, address _tokenSale) {\r\n    multisig = _multisig;\r\n    finalBlock = _finalBlock;\r\n    tokenSale = AbstractSale(_tokenSale);\r\n  }\r\n\r\n  // @dev Receive all sent funds without any further logic\r\n  function () public payable {}\r\n\r\n  // @dev Withdraw function sends all the funds to the wallet if conditions are correct\r\n  function withdraw() public {\r\n    require(msg.sender == multisig);  // Only the multisig can request it\r\n    if (block.number > finalBlock) return doWithdraw();      // Allow after the final block\r\n    if (tokenSale.saleFinalized()) return doWithdraw();      // Allow when sale is finalized\r\n  }\r\n\r\n  function doWithdraw() internal {\r\n    require(multisig.send(this.balance));\r\n  }\r\n}\r\n\r\n\r\ncontract GenaroTokenSale is Controlled, Controller, SafeMath {\r\n    uint public initialBlock;             // Block number in which the sale starts. Inclusive. sale will be opened at initial block.\r\n    uint public finalBlock;               // Block number in which the sale end. Exclusive, sale will be closed at ends block.\r\n    uint public price;                    // Number of wei-GNR tokens for 1 wei, at the start of the sale (9 decimals) \r\n\r\n    address public genaroDevMultisig;     // The address to hold the funds donated\r\n    bytes32 public capCommitment;\r\n\r\n    uint public totalCollected = 0;               // In wei\r\n    bool public saleStopped = false;              // Has Genaro Dev stopped the sale?\r\n    bool public saleFinalized = false;            // Has Genaro Dev finalized the sale?\r\n\r\n    mapping (address => bool) public activated;   // Address confirmates that wants to activate the sale\r\n\r\n    mapping (address => bool) public whitelist;   // Address consists of whitelist payer\r\n\r\n    GNR public token;                             // The token\r\n    GRPlaceholder public networkPlaceholder;      // The network placeholder\r\n    SaleWallet public saleWallet;                 // Wallet that receives all sale funds\r\n\r\n    uint constant public dust = 1 ether;         // Minimum investment\r\n    uint constant public maxPerPersion = 100 ether;   // Maximum investment per person\r\n\r\n    uint public hardCap = 2888 ether;          // Hard cap for Genaro \r\n\r\n    event NewPresaleAllocation(address indexed holder, uint256 gnrAmount);\r\n    event NewBuyer(address indexed holder, uint256 gnrAmount, uint256 etherAmount);\r\n    event CapRevealed(uint value, uint secret, address revealer);\r\n\r\n/// @dev There are several checks to make sure the parameters are acceptable\r\n/// @param _initialBlock The Block number in which the sale starts\r\n/// @param _finalBlock The Block number in which the sale ends\r\n/// @param _genaroDevMultisig The address that will store the donated funds and manager\r\n/// for the sale\r\n/// @param _price The price for the genaro sale. Price in wei-GNR per wei.\r\n\r\n  function GenaroTokenSale (\r\n      uint _initialBlock,\r\n      uint _finalBlock,\r\n      address _genaroDevMultisig,\r\n      uint256 _price,\r\n      bytes32 _capCommitment\r\n  )\r\n  {\r\n      require(_genaroDevMultisig !=0);\r\n      require(_initialBlock >= getBlockNumber());\r\n      require(_initialBlock < _finalBlock);\r\n\r\n      require(uint(_capCommitment)!=0);\r\n      \r\n\r\n      // Save constructor arguments as global variables\r\n      initialBlock = _initialBlock;\r\n      finalBlock = _finalBlock;\r\n      genaroDevMultisig = _genaroDevMultisig;\r\n      price = _price;\r\n      capCommitment = _capCommitment;\r\n  }\r\n\r\n  // @notice Deploy GNR is called only once to setup all the needed contracts.\r\n  // @param _token: Address of an instance of the GNR token\r\n  // @param _networkPlaceholder: Address of an instance of GNRPlaceholder\r\n  // @param _saleWallet: Address of the wallet receiving the funds of the sale\r\n\r\n  function setGNR(address _token, address _networkPlaceholder, address _saleWallet)\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    require(_token != 0);\r\n    require(_networkPlaceholder != 0);\r\n    require(_saleWallet != 0);\r\n\r\n    // Assert that the function hasn't been called before, as activate will happen at the end\r\n    assert(!activated[this]);\r\n\r\n    token = GNR(_token);\r\n    networkPlaceholder = GRPlaceholder(_networkPlaceholder);\r\n    saleWallet = SaleWallet(_saleWallet);\r\n    \r\n    assert(token.controller() == address(this)); // sale is controller\r\n    assert(networkPlaceholder.sale() ==address(this)); // placeholder has reference to Sale\r\n    assert(networkPlaceholder.token() == address(token)); // placeholder has reference to GNR\r\n    assert(saleWallet.finalBlock() == finalBlock); // final blocks must match\r\n    assert(saleWallet.multisig() == genaroDevMultisig);  // receiving wallet must match\r\n    assert(saleWallet.tokenSale() == address(this));  // watched token sale must be self\r\n\r\n    // Contract activates sale as all requirements are ready\r\n    doActivateSale(this);\r\n  }\r\n\r\n  // @notice Certain addresses need to call the activate function prior to the sale opening block.\r\n  // This proves that they have checked the sale contract is legit, as well as proving\r\n  // the capability for those addresses to interact with the contract.\r\n  function activateSale()\r\n           public {\r\n    doActivateSale(msg.sender);\r\n  }\r\n\r\n  function doActivateSale(address _entity)\r\n    non_zero_address(token)               // cannot activate before setting token\r\n    only_before_sale\r\n    private {\r\n    activated[_entity] = true;\r\n  }\r\n\r\n  // @notice Whether the needed accounts have activated the sale.\r\n  // @return Is sale activated\r\n  function isActivated() constant public returns (bool) {\r\n    return activated[this] && activated[genaroDevMultisig];\r\n  }\r\n\r\n  // @notice Get the price for a GNR token at any given block number\r\n  // @param _blockNumber the block for which the price is requested\r\n  // @return Number of wei-GNR for 1 wei\r\n  // If sale isn't ongoing for that block, returns 0.\r\n\r\n  function getPrice(address _owner, uint _blockNumber) constant public returns (uint256) {\r\n    if (_blockNumber < initialBlock || _blockNumber >= finalBlock) return 0;\r\n\r\n    return (price);\r\n  }\r\n\r\n  // @notice Genaro Dev needs to make initial token allocations for presale partners\r\n  // This allocation has to be made before the sale is activated. Activating the sale means no more\r\n  // arbitrary allocations are possible and expresses conformity.\r\n  // @param _receiver: The receiver of the tokens\r\n  // @param _amount: Amount of tokens allocated for receiver.\r\n\r\n  function allocatePresaleTokens(address _receiver, uint _amount, uint64 cliffDate, uint64 vestingDate)\r\n           only_before_sale_activation\r\n           only_before_sale\r\n           non_zero_address(_receiver)\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    require(_amount<=6.3*(10 ** 15)); // presale 63 million GNR. No presale partner will have more than this allocated. Prevent overflows.\r\n\r\n    assert(token.generateTokens(address(this),_amount));\r\n    \r\n    // vested token be sent in appropiate vesting date\r\n    token.grantVestedTokens(_receiver, _amount, uint64(now), cliffDate, vestingDate);\r\n\r\n    NewPresaleAllocation(_receiver, _amount);\r\n  }\r\n\r\n/// @dev The fallback function is called when ether is sent to the contract, it\r\n/// simply calls `doPayment()` with the address that sent the ether as the\r\n/// `_owner`. Payable is a required solidity modifier for functions to receive\r\n/// ether, without this modifier functions will throw if ether is sent to them\r\n\r\n  function () public payable {\r\n    return doPayment(msg.sender);\r\n  }\r\n\r\n/////////////////\r\n// Whitelist  controll\r\n/////////////////\r\n\r\n  function addToWhiteList(address _owner) \r\n           only(controller)\r\n           public{\r\n              whitelist[_owner]=true;\r\n           }\r\n\r\n  function removeFromWhiteList(address _owner)\r\n           only(controller)\r\n           public{\r\n              whitelist[_owner]=false;\r\n           }\r\n\r\n  // @return true if investor is whitelisted\r\n  function isWhitelisted(address _owner) public constant returns (bool) {\r\n    return whitelist[_owner];\r\n  }           \r\n\r\n/////////////////\r\n// Controller interface\r\n/////////////////\r\n\r\n/// @notice `proxyPayment()` allows the caller to send ether to the Token directly and\r\n/// have the tokens created in an address of their choosing\r\n/// @param _owner The address that will hold the newly created tokens\r\n\r\n  function proxyPayment(address _owner) payable public returns (bool) {\r\n    doPayment(_owner);\r\n    return true;\r\n  }\r\n\r\n/// @notice Notifies the controller about a transfer, for this sale all\r\n///  transfers are allowed by default and no extra notifications are needed\r\n/// @param _from The origin of the transfer\r\n/// @param _to The destination of the transfer\r\n/// @param _amount The amount of the transfer\r\n/// @return False if the controller does not authorize the transfer\r\n  function onTransfer(address _from, address _to, uint _amount) public returns (bool) {\r\n    // Until the sale is finalized, only allows transfers originated by the sale contract.\r\n    // When finalizeSale is called, this function will stop being called and will always be true.\r\n    return _from == address(this);\r\n  }\r\n\r\n/// @notice Notifies the controller about an approval, for this sale all\r\n///  approvals are allowed by default and no extra notifications are needed\r\n/// @param _owner The address that calls `approve()`\r\n/// @param _spender The spender in the `approve()` call\r\n/// @param _amount The amount in the `approve()` call\r\n/// @return False if the controller does not authorize the approval\r\n  function onApprove(address _owner, address _spender, uint _amount) public returns (bool) {\r\n    // No approve/transferFrom during the sale\r\n    return false;\r\n  }\r\n\r\n/// @dev `doPayment()` is an internal function that sends the ether that this\r\n///  contract receives to the genaroDevMultisig and creates tokens in the address of the\r\n/// @param _owner The address that will hold the newly created tokens\r\n\r\n  function doPayment(address _owner)\r\n           only_during_sale_period\r\n           only_sale_not_stopped\r\n           only_sale_activated\r\n           non_zero_address(_owner)\r\n           minimum_value(dust)\r\n           maximum_value(maxPerPersion)\r\n           internal {\r\n\r\n    assert(totalCollected+msg.value <= hardCap); //if past hard cap, throw\r\n\r\n    uint256 boughtTokens = safeDiv(safeMul(msg.value, getPrice(_owner,getBlockNumber())),10**9); // Calculate how many tokens bought\r\n\r\n    assert(saleWallet.send(msg.value));  //Send fund to multisig\r\n    assert(token.generateTokens(_owner,boughtTokens));// Allocate tokens. This will fail after sale is finalized in case it is hidden cap finalized.\r\n    \r\n    totalCollected = safeAdd(totalCollected, msg.value); // Save total collected amount\r\n\r\n    NewBuyer(_owner, boughtTokens, msg.value);\r\n  }\r\n\r\n  // @notice Function to stop sale for an emergency.\r\n  // @dev Only Genaro Dev can do it after it has been activated.\r\n  function emergencyStopSale()\r\n           only_sale_activated\r\n           only_sale_not_stopped\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    saleStopped = true;\r\n  }\r\n\r\n  // @notice Function to restart stopped sale.\r\n  // @dev Only Genaro Dev can do it after it has been disabled and sale is ongoing.\r\n  function restartSale()\r\n           only_during_sale_period\r\n           only_sale_stopped\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    saleStopped = false;\r\n  }\r\n\r\n  function revealCap(uint256 _cap, uint256 _cap_secure)\r\n           only_during_sale_period\r\n           only_sale_activated\r\n           verify_cap(_cap, _cap_secure)\r\n           public {\r\n\r\n    require(_cap <= hardCap);\r\n\r\n    hardCap = _cap;\r\n    CapRevealed(_cap, _cap_secure, msg.sender);\r\n\r\n    if (totalCollected + dust >= hardCap) {\r\n      doFinalizeSale();\r\n    }\r\n  }\r\n\r\n  // @notice Finalizes sale generating the tokens for Genaro Dev.\r\n  // @dev Transfers the token controller power to the GRPlaceholder.\r\n  function finalizeSale()\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    require(getBlockNumber() >= finalBlock  ||  totalCollected >= hardCap);\r\n    doFinalizeSale();\r\n  }\r\n\r\n  function doFinalizeSale()\r\n           internal {\r\n    // Doesn't check if saleStopped is false, because sale could end in a emergency stop.\r\n    // This function cannot be successfully called twice, because it will top being the controller,\r\n    // and the generateTokens call will fail if called again.\r\n\r\n    //token.changeController(networkPlaceholder); // Sale loses token controller power in favor of network placeholder\r\n\r\n    token.changeController(genaroDevMultisig);\r\n    saleFinalized = true;  // Set stop is true which will enable network deployment\r\n    saleStopped = true;\r\n  }\r\n\r\n  // @notice Deploy Genaro Network contract.\r\n  // @param networkAddress: The address the network was deployed at.\r\n  function deployNetwork(address networkAddress)\r\n           only_finalized_sale\r\n           non_zero_address(networkAddress)\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    networkPlaceholder.changeController(networkAddress);\r\n  }\r\n\r\n  function setGenaroDevMultisig(address _newMultisig)\r\n           non_zero_address(_newMultisig)\r\n           only(genaroDevMultisig)\r\n           public {\r\n\r\n    genaroDevMultisig = _newMultisig;\r\n  }\r\n\r\n  function getBlockNumber() constant internal returns (uint) {\r\n    return block.number;\r\n  }\r\n\r\n  function computeCap(uint256 _cap, uint256 _cap_secure) constant public returns (bytes32) {\r\n    return sha3(_cap, _cap_secure);\r\n  }\r\n\r\n  function isValidCap(uint256 _cap, uint256 _cap_secure) constant public returns (bool) {\r\n    return computeCap(_cap, _cap_secure) == capCommitment;\r\n  }\r\n\r\n  modifier only(address x) {\r\n    require(msg.sender == x);\r\n    _;\r\n  }\r\n\r\n  modifier verify_cap(uint256 _cap, uint256 _cap_secure) {\r\n    require(isValidCap(_cap,_cap_secure));\r\n    _;\r\n  }\r\n\r\n  modifier only_before_sale {\r\n    require(getBlockNumber() < initialBlock);\r\n    _;\r\n  }\r\n\r\n  modifier only_during_sale_period {\r\n    require(getBlockNumber() >= initialBlock);\r\n    require(getBlockNumber() < finalBlock);\r\n    _;\r\n  }\r\n\r\n  modifier only_after_sale {\r\n    require(getBlockNumber() >= finalBlock);\r\n    _;\r\n  }\r\n\r\n  modifier only_sale_stopped {\r\n    require(saleStopped);\r\n    _;\r\n  }\r\n\r\n  modifier only_sale_not_stopped {\r\n    require(!saleStopped);\r\n    _;\r\n  }\r\n\r\n  modifier only_before_sale_activation {\r\n    require(!isActivated());\r\n    _;\r\n  }\r\n\r\n  modifier only_sale_activated {\r\n    require(isActivated());\r\n    _;\r\n  }\r\n\r\n  modifier only_finalized_sale {\r\n    require(getBlockNumber() >= finalBlock);\r\n    require(saleFinalized);\r\n    _;\r\n  }\r\n\r\n  modifier non_zero_address(address x) {\r\n    require(x != 0);\r\n    _;\r\n  }\r\n\r\n  modifier maximum_value(uint256 x) {\r\n    require(msg.value <= x);\r\n    _;\r\n  }\r\n\r\n  modifier minimum_value(uint256 x) {\r\n    require(msg.value >= x);\r\n    _;\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"removeFromWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genaroDevMultisig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMultisig\",\"type\":\"address\"}],\"name\":\"setGenaroDevMultisig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capCommitment\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyStopSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_networkPlaceholder\",\"type\":\"address\"},{\"name\":\"_saleWallet\",\"type\":\"address\"}],\"name\":\"setGNR\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPerPersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"restartSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_cap_secure\",\"type\":\"uint256\"}],\"name\":\"isValidCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"networkAddress\",\"type\":\"address\"}],\"name\":\"deployNetwork\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"cliffDate\",\"type\":\"uint64\"},{\"name\":\"vestingDate\",\"type\":\"uint64\"}],\"name\":\"allocatePresaleTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_cap_secure\",\"type\":\"uint256\"}],\"name\":\"computeCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateSale\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkPlaceholder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_cap_secure\",\"type\":\"uint256\"}],\"name\":\"revealCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"proxyPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dust\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialBlock\",\"type\":\"uint256\"},{\"name\":\"_finalBlock\",\"type\":\"uint256\"},{\"name\":\"_genaroDevMultisig\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_capCommitment\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gnrAmount\",\"type\":\"uint256\"}],\"name\":\"NewPresaleAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gnrAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"NewBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"secret\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"revealer\",\"type\":\"address\"}],\"name\":\"CapRevealed\",\"type\":\"event\"}]", "ContractName": "GenaroTokenSale", "CompilerVersion": "v0.4.13+commit.fb4cb1a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000003f9c6000000000000000000000000000000000000000000000000000000000004064e700000000000000000000000000bb97921b83dc5408105269558de38c911307fb0000000000000000000000000000000000000000000000000000000000001e009f1c7e5452f0a10a2e2cde94d82e8d9e3204c4d012b7396127fc304d6dcac414", "Library": "", "SwarmSource": "bzzr://e29a1190ddeb39f89f84b275ba938defb31099739569e9f97cc11d2270ccd6e5"}]}