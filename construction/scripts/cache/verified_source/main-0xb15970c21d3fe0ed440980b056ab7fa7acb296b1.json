{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.16;\r\n\r\ninterface Game {\r\n    event GameStarted(uint betAmount);\r\n    event NewPlayerAdded(uint numPlayers, uint prizeAmount);\r\n    event GameFinished(address winner);\r\n\r\n    function () public payable;                                   //Participate in game. Proxy for play method\r\n    function getPrizeAmount() public constant returns (uint);     //Get potential or actual prize amount\r\n    function getNumWinners() public constant returns(uint, uint);\r\n    function getPlayers() public constant returns(address[]);           //Get full list of players\r\n    function getWinners() public view returns(address[] memory players,\r\n                                                uint[] memory prizes);  //Get winners. Accessable only when finished\r\n    function getStat() public constant returns(uint, uint, uint);       //Short stat on game\r\n\r\n    function calcaultePrizes() public returns (uint[]);\r\n\r\n    function finish() public;                        //Closes game chooses winner\r\n\r\n    function revoke() public;                        //Stop game and return money to players\r\n    // function move(address nextGame);              //Move players bets to another game\r\n}\r\n\r\nlibrary TicketLib {\r\n    struct Ticket {\r\n        uint40 block_number;\r\n        uint32 block_time;\r\n        uint prize;\r\n    }\r\n}\r\n\r\ncontract UnilotPrizeCalculator {\r\n    //Calculation constants\r\n    uint64  constant accuracy                   = 1000000000000000000;\r\n    uint8  constant MAX_X_FOR_Y                = 195;  // 19.5\r\n\r\n    uint8  constant minPrizeCoeficent          = 1;\r\n    uint8  constant percentOfWinners           = 5;    // 5%\r\n    uint8  constant percentOfFixedPrizeWinners = 20;   // 20%\r\n    uint8  constant gameCommision              = 20;   // 20%\r\n    uint8  constant bonusGameCommision         = 5;    // 5%\r\n    uint8  constant tokenHolerGameCommision    = 5;    // 5%\r\n    // End Calculation constants\r\n\r\n    event Debug(uint);\r\n\r\n    function getPrizeAmount(uint totalAmount)\r\n        public\r\n        pure\r\n        returns (uint result)\r\n    {\r\n        uint totalCommision = gameCommision\r\n                            + bonusGameCommision\r\n                            + tokenHolerGameCommision;\r\n\r\n        //Calculation is odd on purpose.  It is a sort of ceiling effect to\r\n        // maximize amount of prize\r\n        result = ( totalAmount - ( ( totalAmount * totalCommision) / 100) );\r\n\r\n        return result;\r\n    }\r\n\r\n    function getNumWinners(uint numPlayers)\r\n        public\r\n        pure\r\n        returns (uint16 numWinners, uint16 numFixedAmountWinners)\r\n    {\r\n        // Calculation is odd on purpose. It is a sort of ceiling effect to\r\n        // maximize number of winners\r\n        uint16 totaNumlWinners = uint16( numPlayers - ( (numPlayers * ( 100 - percentOfWinners ) ) / 100 ) );\r\n\r\n\r\n        numFixedAmountWinners = uint16( (totaNumlWinners * percentOfFixedPrizeWinners) / 100 );\r\n        numWinners = uint16( totaNumlWinners - numFixedAmountWinners );\r\n\r\n        return (numWinners, numFixedAmountWinners);\r\n    }\r\n\r\n    function calcaultePrizes(uint bet, uint numPlayers)\r\n        public\r\n        pure\r\n        returns (uint[50] memory prizes)\r\n    {\r\n        var (numWinners, numFixedAmountWinners) = getNumWinners(numPlayers);\r\n\r\n        require( uint(numWinners + numFixedAmountWinners) <= prizes.length );\r\n\r\n        uint[] memory y = new uint[]((numWinners - 1));\r\n        uint z = 0; // Sum of all Y values\r\n\r\n        if ( numWinners == 1 ) {\r\n            prizes[0] = getPrizeAmount(uint(bet*numPlayers));\r\n\r\n            return prizes;\r\n        } else if ( numWinners < 1 ) {\r\n            return prizes;\r\n        }\r\n\r\n        for (uint i = 0; i < y.length; i++) {\r\n            y[i] = formula( (calculateStep(numWinners) * i) );\r\n            z += y[i];\r\n        }\r\n\r\n        bool stop = false;\r\n\r\n        for (i = 0; i < 10; i++) {\r\n            uint[5] memory chunk = distributePrizeCalculation(\r\n                i, z, y, numPlayers, bet);\r\n\r\n            for ( uint j = 0; j < chunk.length; j++ ) {\r\n                if ( ( (i * chunk.length) + j ) >= ( numWinners + numFixedAmountWinners ) ) {\r\n                    stop = true;\r\n                    break;\r\n                }\r\n\r\n                prizes[ (i * chunk.length) + j ] = chunk[j];\r\n            }\r\n\r\n            if ( stop ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return prizes;\r\n    }\r\n\r\n    function distributePrizeCalculation (uint chunkNumber, uint z, uint[] memory y, uint totalNumPlayers, uint bet)\r\n        private\r\n        pure\r\n        returns (uint[5] memory prizes)\r\n    {\r\n        var(numWinners, numFixedAmountWinners) = getNumWinners(totalNumPlayers);\r\n        uint prizeAmountForDeligation = getPrizeAmount( (totalNumPlayers * bet) );\r\n        prizeAmountForDeligation -= uint( ( bet * minPrizeCoeficent ) * uint( numWinners + numFixedAmountWinners ) );\r\n\r\n        uint mainWinnerBaseAmount = ( (prizeAmountForDeligation * accuracy) / ( ( ( z * accuracy ) / ( 2 * y[0] ) ) + ( 1 * accuracy ) ) );\r\n        uint undeligatedAmount    = prizeAmountForDeligation;\r\n\r\n        uint startPoint = chunkNumber * prizes.length;\r\n\r\n        for ( uint i = 0; i < prizes.length; i++ ) {\r\n            if ( i >= uint(numWinners + numFixedAmountWinners) ) {\r\n                break;\r\n            }\r\n            prizes[ i ] = (bet * minPrizeCoeficent);\r\n            uint extraPrize = 0;\r\n\r\n            if ( i == ( numWinners - 1 ) ) {\r\n                extraPrize = undeligatedAmount;\r\n            } else if ( i == 0 && chunkNumber == 0 ) {\r\n                extraPrize = mainWinnerBaseAmount;\r\n            } else if ( ( startPoint + i ) < numWinners ) {\r\n                extraPrize = ( ( y[ ( startPoint + i ) - 1 ] * (prizeAmountForDeligation - mainWinnerBaseAmount) ) / z);\r\n            }\r\n\r\n            prizes[ i ] += extraPrize;\r\n            undeligatedAmount -= extraPrize;\r\n        }\r\n\r\n        return prizes;\r\n    }\r\n\r\n    function formula(uint x)\r\n        public\r\n        pure\r\n        returns (uint y)\r\n    {\r\n        y = ( (1 * accuracy**2) / (x + (5*accuracy/10))) - ((5 * accuracy) / 100);\r\n\r\n        return y;\r\n    }\r\n\r\n    function calculateStep(uint numWinners)\r\n        public\r\n        pure\r\n        returns(uint step)\r\n    {\r\n        step = ( MAX_X_FOR_Y * accuracy / 10 ) / numWinners;\r\n\r\n        return step;\r\n    }\r\n}\r\n\r\ncontract BaseUnilotGame is Game {\r\n    enum State {\r\n        ACTIVE,\r\n        ENDED,\r\n        REVOKING,\r\n        REVOKED,\r\n        MOVED\r\n    }\r\n\r\n    event PrizeResultCalculated(uint size, uint[] prizes);\r\n\r\n    State state;\r\n    address administrator;\r\n    uint bet;\r\n\r\n    mapping (address => TicketLib.Ticket) internal tickets;\r\n    address[] internal ticketIndex;\r\n\r\n    UnilotPrizeCalculator calculator;\r\n\r\n    //Modifiers\r\n    modifier onlyAdministrator() {\r\n        require(msg.sender == administrator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPlayer() {\r\n        require(msg.sender != administrator);\r\n        _;\r\n    }\r\n\r\n    modifier validBet() {\r\n        require(msg.value == bet);\r\n        _;\r\n    }\r\n\r\n    modifier activeGame() {\r\n        require(state == State.ACTIVE);\r\n        _;\r\n    }\r\n\r\n    modifier inactiveGame() {\r\n        require(state != State.ACTIVE);\r\n        _;\r\n    }\r\n\r\n    modifier finishedGame() {\r\n        require(state == State.ENDED);\r\n        _;\r\n    }\r\n\r\n    //Private methods\r\n\r\n    function getState()\r\n        public\r\n        view\r\n        returns(State)\r\n    {\r\n        return state;\r\n    }\r\n\r\n    function getBet()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return bet;\r\n    }\r\n\r\n    function getPlayers()\r\n        public\r\n        constant\r\n        returns(address[])\r\n    {\r\n        return ticketIndex;\r\n    }\r\n\r\n    function getPlayerDetails(address player)\r\n        public\r\n        view\r\n        inactiveGame\r\n        returns (uint, uint, uint)\r\n    {\r\n        TicketLib.Ticket memory ticket = tickets[player];\r\n\r\n        return (ticket.block_number, ticket.block_time, ticket.prize);\r\n    }\r\n\r\n    function getNumWinners()\r\n        public\r\n        constant\r\n        returns (uint, uint)\r\n    {\r\n        var(numWinners, numFixedAmountWinners) = calculator.getNumWinners(ticketIndex.length);\r\n\r\n        return (numWinners, numFixedAmountWinners);\r\n    }\r\n\r\n    function getPrizeAmount()\r\n        public\r\n        constant\r\n        returns (uint result)\r\n    {\r\n        uint totalAmount = this.balance;\r\n\r\n        if ( state == State.ENDED ) {\r\n            totalAmount = bet * ticketIndex.length;\r\n        }\r\n\r\n        result = calculator.getPrizeAmount(totalAmount);\r\n\r\n        return result;\r\n    }\r\n\r\n    function getStat()\r\n        public\r\n        constant\r\n        returns ( uint, uint, uint )\r\n    {\r\n        var (numWinners, numFixedAmountWinners) = getNumWinners();\r\n        return (ticketIndex.length, getPrizeAmount(), uint(numWinners + numFixedAmountWinners));\r\n    }\r\n\r\n    function calcaultePrizes()\r\n        public\r\n        returns(uint[] memory result)\r\n    {\r\n        var(numWinners, numFixedAmountWinners) = getNumWinners();\r\n        uint16 totalNumWinners = uint16( numWinners + numFixedAmountWinners );\r\n        result = new uint[]( totalNumWinners );\r\n\r\n\r\n        uint[50] memory prizes = calculator.calcaultePrizes(\r\n        bet, ticketIndex.length);\r\n\r\n        for (uint16 i = 0; i < totalNumWinners; i++) {\r\n            result[i] = prizes[i];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function revoke()\r\n        public\r\n        onlyAdministrator\r\n        activeGame\r\n    {\r\n        for (uint24 i = 0; i < ticketIndex.length; i++) {\r\n            ticketIndex[i].transfer(bet);\r\n        }\r\n\r\n        state = State.REVOKED;\r\n    }\r\n}\r\n\r\n\r\ncontract UnilotTailEther is BaseUnilotGame {\r\n\r\n    uint64 winnerIndex;\r\n\r\n    //Public methods\r\n    function UnilotTailEther(uint betAmount, address calculatorContractAddress)\r\n        public\r\n    {\r\n        state = State.ACTIVE;\r\n        administrator = msg.sender;\r\n        bet = betAmount;\r\n\r\n        calculator = UnilotPrizeCalculator(calculatorContractAddress);\r\n\r\n        GameStarted(betAmount);\r\n    }\r\n\r\n    function getWinners()\r\n        public\r\n        view\r\n        finishedGame\r\n        returns(address[] memory players, uint[] memory prizes)\r\n    {\r\n        var(numWinners, numFixedAmountWinners) = getNumWinners();\r\n        uint totalNumWinners = numWinners + numFixedAmountWinners;\r\n\r\n        players = new address[](totalNumWinners);\r\n        prizes = new uint[](totalNumWinners);\r\n\r\n        uint index;\r\n\r\n        for (uint i = 0; i < totalNumWinners; i++) {\r\n            if ( i > winnerIndex ) {\r\n                index = ( ( players.length ) - ( i - winnerIndex ) );\r\n            } else {\r\n                index = ( winnerIndex - i );\r\n            }\r\n\r\n            players[i] = ticketIndex[index];\r\n            prizes[i] = tickets[players[i]].prize;\r\n        }\r\n\r\n        return (players, prizes);\r\n    }\r\n\r\n    function ()\r\n        public\r\n        payable\r\n        validBet\r\n        onlyPlayer\r\n    {\r\n        require(tickets[msg.sender].block_number == 0);\r\n        require(ticketIndex.length <= 1000);\r\n\r\n        tickets[msg.sender].block_number = uint40(block.number);\r\n        tickets[msg.sender].block_time   = uint32(block.timestamp);\r\n\r\n        ticketIndex.push(msg.sender);\r\n\r\n        NewPlayerAdded(ticketIndex.length, getPrizeAmount());\r\n    }\r\n\r\n    function finish()\r\n        public\r\n        onlyAdministrator\r\n        activeGame\r\n    {\r\n        uint64 max_votes;\r\n        uint64[] memory num_votes = new uint64[](ticketIndex.length);\r\n\r\n        for (uint i = 0; i < ticketIndex.length; i++) {\r\n            TicketLib.Ticket memory ticket = tickets[ticketIndex[i]];\r\n            uint64 vote = uint64( ( ( ticket.block_number * ticket.block_time ) + uint( ticketIndex[i]) ) % ticketIndex.length );\r\n\r\n            num_votes[vote] += 1;\r\n\r\n            if ( num_votes[vote] > max_votes ) {\r\n                max_votes = num_votes[vote];\r\n                winnerIndex = vote;\r\n            }\r\n        }\r\n\r\n        uint[] memory prizes = calcaultePrizes();\r\n\r\n        uint lastId = winnerIndex;\r\n\r\n        for ( i = 0; i < prizes.length; i++ ) {\r\n            tickets[ticketIndex[lastId]].prize = prizes[i];\r\n            ticketIndex[lastId].transfer(prizes[i]);\r\n\r\n            if ( lastId <= 0 ) {\r\n                lastId = ticketIndex.length;\r\n            }\r\n\r\n            lastId -= 1;\r\n        }\r\n\r\n        administrator.transfer(this.balance);\r\n\r\n        state = State.ENDED;\r\n\r\n        GameFinished(ticketIndex[winnerIndex]);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStat\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"calcaultePrizes\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWinners\",\"outputs\":[{\"name\":\"players\",\"type\":\"address[]\"},{\"name\":\"prizes\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrizeAmount\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"betAmount\",\"type\":\"uint256\"},{\"name\":\"calculatorContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prizes\",\"type\":\"uint256[]\"}],\"name\":\"PrizeResultCalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numPlayers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"name\":\"NewPlayerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"GameFinished\",\"type\":\"event\"}]", "ContractName": "UnilotTailEther", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000071afd498d0000000000000000000000000000f3d9a8f4beabfac059ae62f743369f5dce18322d", "Library": "", "SwarmSource": "bzzr://358c6bf03a37680a9f9d7e92f2db66e987a7754db9396b58449f5c3c904cf17a"}]}