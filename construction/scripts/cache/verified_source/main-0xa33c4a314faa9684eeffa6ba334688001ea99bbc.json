{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\ncontract Phoenix {\r\n    // If round last more than a year - cancel is activated\r\n    uint private MAX_ROUND_TIME = 365 days;\r\n    \r\n    uint private totalCollected;\r\n    uint private currentRound;\r\n    uint private currentRoundCollected;\r\n    uint private prevLimit;\r\n    uint private currentLimit;\r\n    uint private currentRoundStartTime;\r\n\r\n    // That structure describes current user Account    \r\n    // moneyNew - invested money in currentRound\r\n    // moneyHidden - invested in previous round and not profit yet\r\n    // profitTotal - total profit of user account (it never decreases)\r\n    // profitTaken - profit taken by user\r\n    // lastUserUpdateRound - last round when account was updated\r\n    struct Account {\r\n        uint moneyNew;\r\n        uint moneyHidden;\r\n        uint profitTotal;\r\n        uint profitTaken;\r\n\r\n        uint lastUserUpdateRound;\r\n    }\r\n    \r\n    mapping (address => Account) private accounts;\r\n\r\n\r\n    function Phoenix() public {\r\n        totalCollected = 0;\r\n        currentRound = 0;\r\n        currentRoundCollected = 0;\r\n        prevLimit = 0;\r\n        currentLimit = 100e18;\r\n        currentRoundStartTime = block.timestamp;\r\n    }\r\n    \r\n    // This function increments round to next:\r\n    // - it sets new currentLimit (round)using sequence:\r\n    //      100e18, 200e18, 4 * currentLImit - 2 * prevLimit\r\n    function iterateToNextRound() private {\r\n        currentRound++;\r\n        uint tempcurrentLimit = currentLimit;\r\n        \r\n        if(currentRound == 1) {\r\n            currentLimit = 200e18;\r\n        }\r\n        else {\r\n            currentLimit = 4 * currentLimit - 2 * prevLimit;\r\n        }\r\n        \r\n        prevLimit = tempcurrentLimit;\r\n        currentRoundStartTime = block.timestamp;\r\n        currentRoundCollected = 0;\r\n    }\r\n    \r\n    // That function calculates profit update for user\r\n    // - if increments from last calculated round to current round and \r\n    //   calculates current user Account state\r\n    // - algorithm:\r\n    function calculateUpdateProfit(address user) private view returns (Account) {\r\n        Account memory acc = accounts[user];\r\n        \r\n        for(uint r = acc.lastUserUpdateRound; r < currentRound; r++) {\r\n            acc.profitTotal *= 2;\r\n\r\n            if(acc.moneyHidden > 0) {\r\n                acc.profitTotal += acc.moneyHidden * 2;\r\n                acc.moneyHidden = 0;\r\n            }\r\n            \r\n            if(acc.moneyNew > 0) {\r\n                acc.moneyHidden = acc.moneyNew;\r\n                acc.moneyNew = 0;\r\n            }\r\n        }\r\n        \r\n        acc.lastUserUpdateRound = currentRound;\r\n        return acc;\r\n    }\r\n    \r\n    // Here we calculate profit and update it for user\r\n    function updateProfit(address user) private returns(Account) {\r\n        Account memory acc = calculateUpdateProfit(user);\r\n        accounts[user] = acc;\r\n        return acc;\r\n    }\r\n\r\n    // That function returns canceled status.\r\n    // If round lasts for more than 1 year - cancel mode is on\r\n    function canceled() public view returns(bool isCanceled) {\r\n        return block.timestamp >= (currentRoundStartTime + MAX_ROUND_TIME);\r\n    }\r\n    \r\n    // Fallback function for handling money sending directly to contract\r\n    function () public payable {\r\n        require(!canceled());\r\n        deposit();\r\n    }\r\n\r\n    // Function for calculating and updating state during user money investment\r\n    // - first of all we update current user state using updateProfit function\r\n    // - after that we handle situation of investment that makes \r\n    //   currentRoundCollected more than current round limit. If that happen, \r\n    //   we set moneyNew to totalMoney - moneyPartForCrossingRoundLimit.\r\n    // - check crossing round limit in cycle for case when money invested are \r\n    //   more than several round limit\r\n    function deposit() public payable {\r\n        require(!canceled());\r\n        \r\n        updateProfit(msg.sender);\r\n\r\n        uint money2add = msg.value;\r\n        totalCollected += msg.value;\r\n        while(currentRoundCollected + money2add >= currentLimit) {\r\n            accounts[msg.sender].moneyNew += currentLimit - \r\n                currentRoundCollected;\r\n            money2add -= currentLimit - currentRoundCollected;\r\n\r\n            iterateToNextRound();\r\n            updateProfit(msg.sender);\r\n        }\r\n        \r\n        accounts[msg.sender].moneyNew += money2add;\r\n        currentRoundCollected += money2add;\r\n    }\r\n    \r\n    // Returns common information about round\r\n    // totalCollectedSum - total sum, collected in all rounds\r\n    // roundCollected - sum collected in current round\r\n    // currentRoundNumber - current round number\r\n    // remainsCurrentRound - how much remains for round change\r\n    function whatRound() public view returns (uint totalCollectedSum, \r\n            uint roundCollected, uint currentRoundNumber, \r\n            uint remainsCurrentRound) {\r\n        return (totalCollected, currentRoundCollected, currentRound, \r\n            currentLimit - currentRoundCollected);\r\n    }\r\n\r\n    // Returns current user account state\r\n    // profitTotal - how much profit is collected during all rounds\r\n    // profitTaken - how much profit was taken by user during all rounds\r\n    // profitAvailable (= profitTotal - profitTaken) - how much profit can be \r\n    //    taken by user\r\n    // investmentInProgress - how much money are not profit yet and are invested\r\n    //    in current or previous round\r\n    function myAccount() public view returns (uint profitTotal, \r\n            uint profitTaken, uint profitAvailable, uint investmentInProgress) {\r\n        var acc = calculateUpdateProfit(msg.sender);\r\n        return (acc.profitTotal, acc.profitTaken, \r\n                acc.profitTotal - acc.profitTaken, \r\n                acc.moneyNew + acc.moneyHidden);\r\n    }\r\n\r\n    // That function handles cancel state. In that case:\r\n    // - transfer all invested money in current round\r\n    // - transfer all user profit except money taken\r\n    // - remainder of 100 ETH is left after returning all invested in current\r\n    //      round and all profit. Transfer it to users that invest money in \r\n    //      previous round. Total investment in previous round = prevLimit.\r\n    //      So percent of money return = 100 ETH / prevLimit\r\n    function payback() private {\r\n        require(canceled());\r\n\r\n        var acc = accounts[msg.sender];\r\n        uint hiddenpart = 0;\r\n        if(prevLimit > 0) {\r\n            hiddenpart = (acc.moneyHidden * 100e18) / prevLimit;\r\n        }\r\n        uint money2send = acc.moneyNew + acc.profitTotal - acc.profitTaken + \r\n            hiddenpart;\r\n        if(money2send > this.balance) {\r\n            money2send = this.balance;\r\n        }\r\n        acc.moneyNew = 0;\r\n        acc.moneyHidden = 0;\r\n        acc.profitTaken = acc.profitTotal;\r\n\r\n        msg.sender.transfer(money2send);\r\n    }\r\n\r\n    // Function for taking all profit\r\n    // If round is canceled than do a payback (see above)\r\n    // Calculate money left on account = (profitTotal - profitTaken)\r\n    // Increase profitTaken by money left on account\r\n    // Transfer money to user\r\n    function takeProfit() public {\r\n        Account memory acc = updateProfit(msg.sender);\r\n\r\n        if(canceled()) {\r\n            payback();\r\n            return;\r\n        }\r\n\r\n        uint money2send = acc.profitTotal - acc.profitTaken;\r\n        acc.profitTaken += money2send;\r\n        accounts[msg.sender] = acc;\r\n\r\n        if(money2send > 0) {\r\n            msg.sender.transfer(money2send);\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"whatRound\",\"outputs\":[{\"name\":\"totalCollectedSum\",\"type\":\"uint256\"},{\"name\":\"roundCollected\",\"type\":\"uint256\"},{\"name\":\"currentRoundNumber\",\"type\":\"uint256\"},{\"name\":\"remainsCurrentRound\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canceled\",\"outputs\":[{\"name\":\"isCanceled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeProfit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myAccount\",\"outputs\":[{\"name\":\"profitTotal\",\"type\":\"uint256\"},{\"name\":\"profitTaken\",\"type\":\"uint256\"},{\"name\":\"profitAvailable\",\"type\":\"uint256\"},{\"name\":\"investmentInProgress\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Phoenix", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://e1cadde3cb22332c066f91cbccfa733eab396516183c626699e728ec53f08c49"}]}