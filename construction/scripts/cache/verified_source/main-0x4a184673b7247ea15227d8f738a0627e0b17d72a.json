{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.2;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract Minewar {\r\n    uint256 round = 0;\r\n    uint256 public deadline;\r\n    uint256 public CRTSTAL_MINING_PERIOD = 86400; \r\n    uint256 public SHARE_CRYSTAL = 10 * CRTSTAL_MINING_PERIOD;\r\n    uint256 public HALF_TIME = 12 hours;\r\n    uint256 public ROUND_TIME = 7 days;\r\n    uint256 BASE_PRICE = 0.005 ether;\r\n    uint256 RANK_LIST_LIMIT = 1000;\r\n    //miner info\r\n    mapping(uint256 => MinerData) private minerData;\r\n    uint256 private numberOfMiners;\r\n    // plyer info\r\n    mapping(address => PlyerData) private players;\r\n    //booster info\r\n    uint256 private numberOfBoosts;\r\n    mapping(uint256 => BoostData) private boostData;\r\n    //order info\r\n    uint256 private numberOfOrders;\r\n    mapping(uint256 => BuyOrderData) private buyOrderData;\r\n    mapping(uint256 => SellOrderData) private sellOrderData;\r\n    uint256 private numberOfRank;\r\n    address[21] rankList;\r\n    address public sponsor;\r\n    uint256 public sponsorLevel;\r\n    address public administrator;\r\n    /*** DATATYPES ***/\r\n    struct PlyerData {\r\n        uint256 round;\r\n        mapping(uint256 => uint256) minerCount;\r\n        uint256 hashrate;\r\n        uint256 crystals;\r\n        uint256 lastUpdateTime;\r\n    }\r\n    struct MinerData {\r\n        uint256 basePrice;\r\n        uint256 baseProduct;\r\n        uint256 limit;\r\n    }\r\n    struct BoostData {\r\n        address owner;\r\n        uint256 boostRate;\r\n        uint256 startingLevel;\r\n        uint256 startingTime;\r\n        uint256 halfLife;\r\n    }\r\n    struct BuyOrderData {\r\n        address owner;\r\n        string title;\r\n        string description;\r\n        uint256 unitPrice;\r\n        uint256 amount;\r\n    }\r\n    struct SellOrderData {\r\n        address owner;\r\n        string title;\r\n        string description;\r\n        uint256 unitPrice;\r\n        uint256 amount;\r\n    }\r\n    function Minewar() public\r\n    {\r\n        administrator = msg.sender;\r\n        numberOfMiners = 8;\r\n        numberOfBoosts = 5;\r\n        numberOfOrders = 5;\r\n        numberOfRank = 21;\r\n        //init miner data\r\n        //                      price,          prod.     limit\r\n        minerData[0] = MinerData(10,            10,         10);   //lv1\r\n        minerData[1] = MinerData(100,           200,        2);    //lv2\r\n        minerData[2] = MinerData(400,           800,        4);    //lv3\r\n        minerData[3] = MinerData(1600,          3200,       8);    //lv4 \r\n        minerData[4] = MinerData(6400,          12800,      16);   //lv5 \r\n        minerData[5] = MinerData(25600,         51200,      32);   //lv6 \r\n        minerData[6] = MinerData(204800,        409600,     64);   //lv7 \r\n        minerData[7] = MinerData(1638400,       1638400,    65536); //lv8\r\n        startNewRound();\r\n    }\r\n    function startNewRound() private \r\n    {\r\n        deadline = SafeMath.add(now, ROUND_TIME);\r\n        round = SafeMath.add(round, 1);\r\n        initData();\r\n    }\r\n    function initData() private\r\n    {\r\n        sponsor = administrator;\r\n        sponsorLevel = 5;\r\n        //init booster data\r\n        boostData[0] = BoostData(0, 150, 1, now, HALF_TIME);\r\n        boostData[1] = BoostData(0, 175, 1, now, HALF_TIME);\r\n        boostData[2] = BoostData(0, 200, 1, now, HALF_TIME);\r\n        boostData[3] = BoostData(0, 225, 1, now, HALF_TIME);\r\n        boostData[4] = BoostData(msg.sender, 250, 2, now, HALF_TIME);\r\n        //init order data\r\n        uint256 idx;\r\n        for (idx = 0; idx < numberOfOrders; idx++) {\r\n            buyOrderData[idx] = BuyOrderData(0, \"title\", \"description\", 0, 0);\r\n            sellOrderData[idx] = SellOrderData(0, \"title\", \"description\", 0, 0);\r\n        }\r\n        for (idx = 0; idx < numberOfRank; idx++) {\r\n            rankList[idx] = 0;\r\n        }\r\n    }\r\n    function lottery() public \r\n    {\r\n        require(now >= deadline);\r\n        uint256 balance = SafeMath.div(SafeMath.mul(this.balance, 90), 100);\r\n        administrator.transfer(SafeMath.div(SafeMath.mul(this.balance, 5), 100));\r\n        uint8[10] memory profit = [30,20,10,8,7,5,5,5,5,5];\r\n        for(uint256 idx = 0; idx < 10; idx++){\r\n            if(rankList[idx] != 0){\r\n                rankList[idx].transfer(SafeMath.div(SafeMath.mul(balance,profit[idx]),100));\r\n            }\r\n        }\r\n        startNewRound();\r\n    }\r\n    function getRankList() public view returns(address[21])\r\n    {\r\n        return rankList;\r\n    }\r\n    //sponser\r\n    function becomeSponsor() public payable\r\n    {\r\n        require(now <= deadline);\r\n        require(msg.value >= getSponsorFee());\r\n        sponsor.transfer(getCurrentPrice(sponsorLevel));\r\n        sponsor = msg.sender;\r\n        sponsorLevel = SafeMath.add(sponsorLevel, 1);\r\n    }\r\n    function getSponsorFee() public view returns(uint256 sponsorFee)\r\n    {\r\n        sponsorFee = getCurrentPrice(SafeMath.add(sponsorLevel, 1));\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Miner \r\n    //--------------------------------------------------------------------------\r\n    function getFreeMiner(address ref) public \r\n    {\r\n        require(now <= deadline);\r\n        PlyerData storage p = players[msg.sender];\r\n        require(p.round != round);\r\n        //reset player data\r\n        if(p.hashrate > 0){\r\n            for (uint idx = 1; idx < numberOfMiners; idx++) {\r\n                p.minerCount[idx] = 0;\r\n            }\r\n        }\r\n        p.crystals = 0;\r\n        p.round = round;\r\n        //free miner\r\n        p.lastUpdateTime = now;\r\n        p.minerCount[0] = 1;\r\n        MinerData storage m0 = minerData[0];\r\n        p.hashrate = m0.baseProduct;\r\n        //send referral \r\n        if (ref != msg.sender) {\r\n            PlyerData storage referral = players[ref];\r\n            if(referral.round == round){ \r\n                p.crystals = SafeMath.add(p.crystals, SHARE_CRYSTAL);\r\n                referral.crystals = SafeMath.add(referral.crystals, SHARE_CRYSTAL);\r\n            }\r\n        }\r\n    }\r\n    function buyMiner(uint256[] minerNumbers) public\r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(minerNumbers.length == numberOfMiners);\r\n        uint256 minerIdx = 0;\r\n        MinerData memory m;\r\n        for (; minerIdx < numberOfMiners; minerIdx++) {\r\n            m = minerData[minerIdx];\r\n            if(minerNumbers[minerIdx] > m.limit || minerNumbers[minerIdx] < 0){\r\n                revert();\r\n            }\r\n        }\r\n        updateCrytal(msg.sender);\r\n        PlyerData storage p = players[msg.sender];\r\n        uint256 price = 0;\r\n        uint256 minerNumber = 0;\r\n        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\r\n            minerNumber = minerNumbers[minerIdx];\r\n            if (minerNumber > 0) {\r\n                m = minerData[minerIdx];\r\n                price = SafeMath.add(price, SafeMath.mul(m.basePrice, minerNumber));\r\n            }\r\n        }\r\n        price = SafeMath.mul(price, CRTSTAL_MINING_PERIOD);\r\n        if(p.crystals < price){\r\n            revert();\r\n        }\r\n        for (minerIdx = 0; minerIdx < numberOfMiners; minerIdx++) {\r\n            minerNumber = minerNumbers[minerIdx];\r\n            if (minerNumber > 0) {\r\n                m = minerData[minerIdx];\r\n                p.minerCount[minerIdx] = SafeMath.min(m.limit, SafeMath.add(p.minerCount[minerIdx], minerNumber));\r\n            }\r\n        }\r\n        p.crystals = SafeMath.sub(p.crystals, price);\r\n        updateHashrate(msg.sender);\r\n    }\r\n    function getPlayerData(address addr) public view returns (uint256 crystals, uint256 lastupdate, uint256 hashratePerDay,\r\n     uint256[8] miners, uint256 hasBoost)\r\n    {\r\n        PlyerData storage p = players[addr];\r\n        if(p.round != round){\r\n            p = players[0];\r\n        }\r\n        crystals = SafeMath.div(p.crystals, CRTSTAL_MINING_PERIOD);\r\n        lastupdate = p.lastUpdateTime;\r\n        hashratePerDay = p.hashrate;\r\n        uint256 i = 0;\r\n        for(i = 0; i < numberOfMiners; i++)\r\n        {\r\n            miners[i] = p.minerCount[i];\r\n        }\r\n        hasBoost = hasBooster(addr);\r\n    }\r\n    function getHashratePerDay(address minerAddr) public view returns (uint256 personalProduction)\r\n    {\r\n        PlyerData storage p = players[minerAddr];   \r\n        personalProduction = p.hashrate;\r\n        uint256 boosterIdx = hasBooster(minerAddr);\r\n        if (boosterIdx != 999) {\r\n            BoostData storage b = boostData[boosterIdx];\r\n            personalProduction = SafeMath.div(SafeMath.mul(personalProduction, b.boostRate), 100);\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER \r\n    //--------------------------------------------------------------------------\r\n    function buyBooster(uint256 idx) public payable \r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(idx < numberOfBoosts);\r\n        BoostData storage b = boostData[idx];\r\n        if(msg.value < getBoosterPrice(idx) || msg.sender == b.owner){\r\n            revert();\r\n        }\r\n        address beneficiary = b.owner;\r\n        sponsor.transfer(devFee(getBoosterPrice(idx)));\r\n        beneficiary.transfer(getBoosterPrice(idx) / 2);\r\n        updateCrytal(msg.sender);\r\n        updateCrytal(beneficiary);\r\n        uint256 level = getCurrentLevel(b.startingLevel, b.startingTime, b.halfLife);\r\n        b.startingLevel = SafeMath.add(level, 1);\r\n        b.startingTime = now;\r\n        // transfer ownership    \r\n        b.owner = msg.sender;\r\n    }\r\n    function getBoosterData(uint256 idx) public view returns (address owner,uint256 boostRate, uint256 startingLevel, \r\n        uint256 startingTime, uint256 currentPrice, uint256 halfLife)\r\n    {\r\n        require(idx < numberOfBoosts);\r\n        owner            = boostData[idx].owner;\r\n        boostRate        = boostData[idx].boostRate; \r\n        startingLevel    = boostData[idx].startingLevel;\r\n        startingTime     = boostData[idx].startingTime;\r\n        currentPrice     = getBoosterPrice(idx);\r\n        halfLife         = boostData[idx].halfLife;\r\n    }\r\n    function getBoosterPrice(uint256 index) public view returns (uint256)\r\n    {\r\n        BoostData storage booster = boostData[index];\r\n        return getCurrentPrice(getCurrentLevel(booster.startingLevel, booster.startingTime, booster.halfLife));\r\n    }\r\n    function hasBooster(address addr) public view returns (uint256 boostIdx)\r\n    {         \r\n        boostIdx = 999;\r\n        for(uint256 i = 0; i < numberOfBoosts; i++){\r\n            uint256 revert_i = numberOfBoosts - i - 1;\r\n            if(boostData[revert_i].owner == addr){\r\n                boostIdx = revert_i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Market \r\n    //--------------------------------------------------------------------------\r\n    function buyCrystalDemand(uint256 amount, uint256 unitPrice,string title, string description) public payable \r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(unitPrice > 0);\r\n        require(amount >= 1000);\r\n        require(amount * unitPrice <= msg.value);\r\n        uint256 lowestIdx = getLowestUnitPriceIdxFromBuy();\r\n        BuyOrderData storage o = buyOrderData[lowestIdx];\r\n        if(o.amount > 10 && unitPrice <= o.unitPrice){\r\n            revert();\r\n        }\r\n        uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\r\n        if (o.owner != 0){\r\n            o.owner.transfer(balance);\r\n        }\r\n        o.owner = msg.sender;\r\n        o.unitPrice = unitPrice;\r\n        o.title = title;\r\n        o.description = description;\r\n        o.amount = amount;\r\n    }\r\n    function sellCrystal(uint256 amount, uint256 index) public \r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(index < numberOfOrders);\r\n        require(amount > 0);\r\n        BuyOrderData storage o = buyOrderData[index];\r\n        require(amount <= o.amount);\r\n        updateCrytal(msg.sender);\r\n        PlyerData storage seller = players[msg.sender];\r\n        PlyerData storage buyer = players[o.owner];\r\n        require(seller.crystals >= amount * CRTSTAL_MINING_PERIOD);\r\n        uint256 price = SafeMath.mul(amount, o.unitPrice);\r\n        uint256 fee = devFee(price);\r\n        sponsor.transfer(fee);\r\n        administrator.transfer(fee);\r\n        buyer.crystals = SafeMath.add(buyer.crystals, amount * CRTSTAL_MINING_PERIOD);\r\n        seller.crystals = SafeMath.sub(seller.crystals, amount * CRTSTAL_MINING_PERIOD);\r\n        o.amount = SafeMath.sub(o.amount, amount);\r\n        msg.sender.transfer(SafeMath.div(price, 2));\r\n    }\r\n    function withdrawBuyDemand(uint256 index) public \r\n    {\r\n        require(now <= deadline);\r\n        require(index < numberOfOrders);\r\n        require(players[msg.sender].round == round);\r\n        BuyOrderData storage o = buyOrderData[index];\r\n        require(o.owner == msg.sender);\r\n        if(o.amount > 0){\r\n            uint256 balance = SafeMath.mul(o.amount, o.unitPrice);\r\n            o.owner.transfer(balance);\r\n        }\r\n        o.unitPrice = 0;\r\n        o.amount = 0;  \r\n        o.title = \"title\";\r\n        o.description = \"description\";\r\n        o.owner = 0;\r\n    }\r\n    function getBuyDemand(uint256 index) public view returns(address owner, string title, string description,\r\n     uint256 amount, uint256 unitPrice)\r\n    {\r\n        require(index < numberOfOrders);\r\n        BuyOrderData storage o = buyOrderData[index];\r\n        owner = o.owner;\r\n        title = o.title;\r\n        description = o.description;\r\n        amount = o.amount;\r\n        unitPrice = o.unitPrice;\r\n    }\r\n    function getLowestUnitPriceIdxFromBuy() public returns(uint256 lowestIdx)\r\n    {\r\n        uint256 lowestPrice = 2**256 - 1;\r\n        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\r\n            BuyOrderData storage o = buyOrderData[idx];\r\n            //if empty\r\n            if (o.unitPrice == 0 || o.amount < 10) {\r\n                return idx;\r\n            }else if (o.unitPrice < lowestPrice) {\r\n                lowestPrice = o.unitPrice;\r\n                lowestIdx = idx;\r\n            }\r\n        }\r\n    }\r\n    //-------------------------Sell-----------------------------\r\n    function sellCrystalDemand(uint256 amount, uint256 unitPrice, string title, string description) public \r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(amount >= 1000);\r\n        require(unitPrice > 0);\r\n        updateCrytal(msg.sender);\r\n        PlyerData storage seller = players[msg.sender];\r\n        if(seller.crystals < amount * CRTSTAL_MINING_PERIOD){\r\n            revert();\r\n        }\r\n        uint256 highestIdx = getHighestUnitPriceIdxFromSell();\r\n        SellOrderData storage o = sellOrderData[highestIdx];\r\n        if(o.amount > 10 && unitPrice >= o.unitPrice){\r\n            revert();\r\n        }\r\n        if (o.owner != 0){\r\n            PlyerData storage prev = players[o.owner];\r\n            prev.crystals = SafeMath.add(prev.crystals, o.amount * CRTSTAL_MINING_PERIOD);\r\n        }\r\n        o.owner = msg.sender;\r\n        o.unitPrice = unitPrice;\r\n        o.title = title;\r\n        o.description = description;\r\n        o.amount = amount;\r\n        //sub crystals\r\n        seller.crystals = SafeMath.sub(seller.crystals, amount * CRTSTAL_MINING_PERIOD);\r\n    }\r\n    function buyCrystal(uint256 amount, uint256 index) public payable\r\n    {\r\n        require(now <= deadline);\r\n        require(players[msg.sender].round == round);\r\n        require(index < numberOfOrders);\r\n        require(amount > 0);\r\n        SellOrderData storage o = sellOrderData[index];\r\n        require(amount <= o.amount);\r\n        require(msg.value >= amount * o.unitPrice);\r\n        PlyerData storage buyer = players[msg.sender];\r\n        uint256 price = SafeMath.mul(amount, o.unitPrice);\r\n        uint256 fee = devFee(price);\r\n        sponsor.transfer(fee);\r\n        administrator.transfer(fee);\r\n        buyer.crystals = SafeMath.add(buyer.crystals, amount * CRTSTAL_MINING_PERIOD);\r\n        o.amount = SafeMath.sub(o.amount, amount);\r\n        o.owner.transfer(SafeMath.div(price, 2));\r\n    }\r\n    function withdrawSellDemand(uint256 index) public \r\n    {\r\n        require(now <= deadline);\r\n        require(index < numberOfOrders);\r\n        require(players[msg.sender].round == round);\r\n        SellOrderData storage o = sellOrderData[index];\r\n        require(o.owner == msg.sender);\r\n        if(o.amount > 0){\r\n            PlyerData storage p = players[o.owner];\r\n            p.crystals = SafeMath.add(p.crystals, o.amount * CRTSTAL_MINING_PERIOD);\r\n        }\r\n        o.unitPrice = 0;\r\n        o.amount = 0; \r\n        o.title = \"title\";\r\n        o.description = \"description\";\r\n        o.owner = 0;\r\n    }\r\n    function getSellDemand(uint256 index) public view returns(address owner, string title, string description,\r\n     uint256 amount, uint256 unitPrice)\r\n    {\r\n        require(index < numberOfOrders);\r\n        SellOrderData storage o = sellOrderData[index];\r\n        owner = o.owner;\r\n        title = o.title;\r\n        description = o.description;\r\n        amount = o.amount;\r\n        unitPrice = o.unitPrice;\r\n    }\r\n    function getHighestUnitPriceIdxFromSell() public returns(uint256 highestIdx)\r\n    {\r\n        uint256 highestPrice = 0;\r\n        for (uint256 idx = 0; idx < numberOfOrders; idx++) {\r\n            SellOrderData storage o = sellOrderData[idx];\r\n            //if empty\r\n            if (o.unitPrice == 0 || o.amount < 10) {\r\n                return idx;\r\n            }else if (o.unitPrice > highestPrice) {\r\n                highestPrice = o.unitPrice;\r\n                highestIdx = idx;\r\n            }\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Other \r\n    //--------------------------------------------------------------------------\r\n    function devFee(uint256 amount) public view returns(uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(amount, 5), 100);\r\n    }\r\n    function getBalance() public view returns(uint256)\r\n    {\r\n        return this.balance;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // Private \r\n    //--------------------------------------------------------------------------\r\n    function updateHashrate(address addr) private\r\n    {\r\n        PlyerData storage p = players[addr];\r\n        uint256 hashrate = 0;\r\n        for (uint idx = 0; idx < numberOfMiners; idx++) {\r\n            MinerData storage m = minerData[idx];\r\n            hashrate = SafeMath.add(hashrate, SafeMath.mul(p.minerCount[idx], m.baseProduct));\r\n        }\r\n        p.hashrate = hashrate;\r\n        if(hashrate > RANK_LIST_LIMIT){\r\n            updateRankList(addr);\r\n        }\r\n    }\r\n    function updateCrytal(address addr) private\r\n    {\r\n        require(now > players[addr].lastUpdateTime);\r\n        if (players[addr].lastUpdateTime != 0) {\r\n            PlyerData storage p = players[addr];\r\n            uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime);\r\n            uint256 revenue = getHashratePerDay(addr);\r\n            p.lastUpdateTime = now;\r\n            if (revenue > 0) {\r\n                revenue = SafeMath.mul(revenue, secondsPassed);\r\n                p.crystals = SafeMath.add(p.crystals, revenue);\r\n            }\r\n        }\r\n    }\r\n    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) private view returns(uint256) \r\n    {\r\n        uint256 timePassed=SafeMath.sub(now, startingTime);\r\n        uint256 levelsPassed=SafeMath.div(timePassed, halfLife);\r\n        if (startingLevel < levelsPassed) {\r\n            return 0;\r\n        }\r\n        return SafeMath.sub(startingLevel, levelsPassed);\r\n    }\r\n    function getCurrentPrice(uint256 currentLevel) private view returns(uint256) \r\n    {\r\n        return SafeMath.mul(BASE_PRICE, 2**currentLevel);\r\n    }\r\n    function updateRankList(address addr) private returns(bool)\r\n    {\r\n        uint256 idx = 0;\r\n        PlyerData storage insert = players[addr];\r\n        PlyerData storage lastOne = players[rankList[19]];\r\n        if(insert.hashrate < lastOne.hashrate) {\r\n            return false;\r\n        }\r\n        address[21] memory tempList = rankList;\r\n        if(!inRankList(addr)){\r\n            tempList[20] = addr;\r\n            quickSort(tempList, 0, 20);\r\n        }else{\r\n            quickSort(tempList, 0, 19);\r\n        }\r\n        for(idx = 0;idx < 21; idx++){\r\n            if(tempList[idx] != rankList[idx]){\r\n                rankList[idx] = tempList[idx];\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    function inRankList(address addr) internal returns(bool)\r\n    {\r\n        for(uint256 idx = 0;idx < 20; idx++){\r\n            if(addr == rankList[idx]){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function quickSort(address[21] list, int left, int right) internal\r\n    {\r\n        int i = left;\r\n        int j = right;\r\n        if(i == j) return;\r\n        address addr = list[uint(left + (right - left) / 2)];\r\n        PlyerData storage p = players[addr];\r\n        while (i <= j) {\r\n            while (players[list[uint(i)]].hashrate > p.hashrate) i++;\r\n            while (p.hashrate > players[list[uint(j)]].hashrate) j--;\r\n            if (i <= j) {\r\n                (list[uint(i)], list[uint(j)]) = (list[uint(j)], list[uint(i)]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(list, left, j);\r\n        if (i < right)\r\n            quickSort(list, i, right);\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"sellCrystal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"sellCrystalDemand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"minerAddr\",\"type\":\"address\"}],\"name\":\"getHashratePerDay\",\"outputs\":[{\"name\":\"personalProduction\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBoosterPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"crystals\",\"type\":\"uint256\"},{\"name\":\"lastupdate\",\"type\":\"uint256\"},{\"name\":\"hashratePerDay\",\"type\":\"uint256\"},{\"name\":\"miners\",\"type\":\"uint256[8]\"},{\"name\":\"hasBoost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getBoosterData\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"boostRate\",\"type\":\"uint256\"},{\"name\":\"startingLevel\",\"type\":\"uint256\"},{\"name\":\"startingTime\",\"type\":\"uint256\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"name\":\"halfLife\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"devFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"buyCrystalDemand\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minerNumbers\",\"type\":\"uint256[]\"}],\"name\":\"buyMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getHighestUnitPriceIdxFromSell\",\"outputs\":[{\"name\":\"highestIdx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdrawBuyDemand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSellDemand\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unitPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdrawSellDemand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"getFreeMiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SHARE_CRYSTAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSponsorFee\",\"outputs\":[{\"name\":\"sponsorFee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRankList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[21]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasBooster\",\"outputs\":[{\"name\":\"boostIdx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CRTSTAL_MINING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"buyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getLowestUnitPriceIdxFromBuy\",\"outputs\":[{\"name\":\"lowestIdx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeSponsor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sponsorLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBuyDemand\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"title\",\"type\":\"string\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unitPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"buyCrystal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "Minewar", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://c5e10fb5270ef9e99ad3fd359804b6ae6911b6b80cabd9c694284d3890a75527"}]}