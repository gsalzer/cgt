{"status": "1", "message": "OK", "result": [{"SourceCode": "contract testExpensiveFallback {\r\n    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\r\n    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\r\n    address constant veox = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\r\n\r\n    // public, so accessors available\r\n    bool public ran;\r\n    bool public forked;\r\n    bool public notforked;\r\n    \r\n    modifier before_dao_hf_block {\r\n        if (block.number >= 1920000) throw;\r\n        _\r\n    }\r\n    \r\n    modifier run_once {\r\n        if (ran) throw;\r\n        _\r\n    }\r\n\r\n    modifier has_millions(address _addr, uint _millions) {\r\n        if (_addr.balance >= (_millions * 1000000 ether)) _\r\n    }\r\n\r\n    // 10M ether is ~ 2M less than would be available for a short\r\n    // while in WithdrawDAO after the HF, but probably more than\r\n    // anyone is willing to drop into WithdrawDAO in Classic\r\n    function check_withdrawdao() internal\r\n        has_millions(WithdrawDAO, 10) {\r\n        forked = true;\r\n    }\r\n\r\n    // failsafe: if the above assumption is incorrect, HF tine\r\n    // won't have balance in DarkDAO anyway, and Classic has a\r\n    // sliver of time before DarkDAO split happens\r\n    function check_darkdao() internal\r\n        has_millions(DarkDAO, 3) {\r\n        notforked = true;\r\n    }\r\n\r\n    function kill1() { suicide(veox); }\r\n    function kill2() { selfdestruct(veox); }\r\n    \r\n    // running is possible only once\r\n    // after that the dapp can only throw\r\n    function ()\r\n        before_dao_hf_block run_once {\r\n        ran = true;\r\n\r\n        check_withdrawdao();\r\n        check_darkdao();\r\n\r\n        // if both flags are same, then something went wrong\r\n        if (forked == notforked) throw;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"ran\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill2\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill1\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notforked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"type\":\"function\"}]", "ContractName": "testExpensiveFallback", "CompilerVersion": "v0.3.5-2016-07-01-48238c9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}