{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.18;\r\n\r\ncontract CrowdsaleParameters {\r\n    // Accounts (2017-11-30)\r\n    address internal constant presalePoolAddress        = 0xF373BfD05C8035bE6dcB44CABd17557e49D5364C;\r\n    address internal constant foundersAddress           = 0x0ED375dd94c878703147580F044B6B1CE6a7F053;\r\n    address internal constant incentiveReserveAddress   = 0xD34121E853af290e61a0F0313B99abb24D4Dc6ea;\r\n    address internal constant generalSaleAddress        = 0xC107EC2077BA7d65944267B64F005471A6c05692;\r\n    address internal constant lotteryAddress            = 0x98631b688Bcf78D233C48E464fCfe6dC7aBd32A7;\r\n    address internal constant marketingAddress          = 0x2C1C916a4aC3d0f2442Fe0A9b9e570eB656582d8;\r\n\r\n    // PreICO and Main sale ICO Timing per requirements\r\n    uint256 internal constant presaleStartDate      = 1512121500; // 2017-12-01 09:45 GMT\r\n    uint256 internal constant presaleEndDate        = 1513382430; // 2017-12-16 00:00:30 GMT\r\n    uint256 internal constant generalSaleStartDate  = 1515319200; // 2018-01-07 10:00 GMT\r\n    uint256 internal constant generalSaleEndDate    = 1518602400; // 2018-02-14 10:00 GMT\r\n}\r\n\r\ncontract TokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    *  Constructor\r\n    *\r\n    *  Sets contract owner to address of constructor caller\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    *  Change Owner\r\n    *\r\n    *  Changes ownership of this contract. Only owner can call this method.\r\n    *\r\n    * @param newOwner - new owner's address\r\n    */\r\n    function changeOwner(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        require(newOwner != owner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SeedToken is Owned, CrowdsaleParameters {\r\n    uint8 public decimals;\r\n\r\n    function totalSupply() public  returns (uint256 result);\r\n\r\n    function balanceOf(address _address) public returns (uint256 balance);\r\n\r\n    function allowance(address _owner, address _spender) public returns (uint256 remaining);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function accountBalance(address _address) public returns (uint256 balance);\r\n}\r\n\r\ncontract LiveTreeCrowdsale is Owned, CrowdsaleParameters {\r\n    uint[] public ICOStagePeriod;\r\n\r\n    bool public icoClosedManually = false;\r\n\r\n    bool public allowRefunds = false;\r\n\r\n    uint public totalCollected = 0;\r\n\r\n    address private saleWalletAddress;\r\n\r\n    address private presaleWalletAddress;\r\n\r\n    uint private tokenMultiplier = 10;\r\n\r\n    SeedToken private tokenReward;\r\n\r\n    uint private reasonableCostsPercentage;\r\n\r\n    mapping (address => uint256) private investmentRecords;\r\n\r\n    event FundTransfer(address indexed _from, address indexed _to, uint _value);\r\n\r\n    event TokenTransfer(address indexed baker, uint tokenAmount, uint pricePerToken);\r\n\r\n    event Refund(address indexed backer, uint amount);\r\n\r\n    enum Stage { PreSale, GeneralSale, Inactive }\r\n\r\n    /**\r\n    * Constructor\r\n    *\r\n    * @param _tokenAddress - address of SED token (deployed before this contract)\r\n    */\r\n    function LiveTreeCrowdsale(address _tokenAddress) public {\r\n        tokenReward = SeedToken(_tokenAddress);\r\n        tokenMultiplier = tokenMultiplier ** tokenReward.decimals();\r\n        saleWalletAddress = CrowdsaleParameters.generalSaleAddress;\r\n        presaleWalletAddress = CrowdsaleParameters.presalePoolAddress;\r\n\r\n        ICOStagePeriod.push(CrowdsaleParameters.presaleStartDate);\r\n        ICOStagePeriod.push(CrowdsaleParameters.presaleEndDate);\r\n        ICOStagePeriod.push(CrowdsaleParameters.generalSaleStartDate);\r\n        ICOStagePeriod.push(CrowdsaleParameters.generalSaleEndDate);\r\n    }\r\n\r\n    /**\r\n    * Get active stage (pre-sale or general sale)\r\n    *\r\n    * @return stage - active stage\r\n    */\r\n    function getActiveStage() internal constant returns (Stage) {\r\n        if (ICOStagePeriod[0] <= now && now < ICOStagePeriod[1])\r\n            return Stage.PreSale;\r\n\r\n        if (ICOStagePeriod[2] <= now && now < ICOStagePeriod[3])\r\n            return Stage.GeneralSale;\r\n\r\n        return Stage.Inactive;\r\n    }\r\n\r\n    /**\r\n    *  Process received payment\r\n    *\r\n    *  Determine the number of tokens that was purchased considering current\r\n    *  stage, bonus tier and remaining amount of tokens in the sale wallet.\r\n    *  Transfer purchased tokens to bakerAddress and return unused portion of\r\n    *  ether (change)\r\n    *\r\n    * @param bakerAddress - address that ether was sent from\r\n    * @param amount - amount of Wei received\r\n    */\r\n    function processPayment(address bakerAddress, uint amount) internal {\r\n        // Check current stage, either pre-sale or general sale should be active\r\n        Stage currentStage = getActiveStage();\r\n        require(currentStage != Stage.Inactive);\r\n\r\n        // Validate if ICO is not closed manually or reached the threshold\r\n        require(!icoClosedManually);\r\n\r\n        // Before Metropolis update require will not refund gas, but\r\n        // for some reason require statement around msg.value always throws\r\n        assert(amount > 0 finney);\r\n\r\n        // Validate that we received less than a billion ETH to prevent overflow\r\n        require(amount < 1e27);\r\n\r\n        // Tell everyone about the transfer\r\n        FundTransfer(bakerAddress, address(this), amount);\r\n\r\n        // Calculate tokens per ETH for this tier\r\n        uint tokensPerEth = 1130;\r\n\r\n        if (amount < 1.5 ether)\r\n            tokensPerEth = 1000;\r\n        else if (amount < 3 ether)\r\n            tokensPerEth = 1005;\r\n        else if (amount < 5 ether)\r\n            tokensPerEth = 1010;\r\n        else if (amount < 7 ether)\r\n            tokensPerEth = 1015;\r\n        else if (amount < 10 ether)\r\n            tokensPerEth = 1020;\r\n        else if (amount < 15 ether)\r\n            tokensPerEth = 1025;\r\n        else if (amount < 20 ether)\r\n            tokensPerEth = 1030;\r\n        else if (amount < 30 ether)\r\n            tokensPerEth = 1035;\r\n        else if (amount < 50 ether)\r\n            tokensPerEth = 1040;\r\n        else if (amount < 75 ether)\r\n            tokensPerEth = 1045;\r\n        else if (amount < 100 ether)\r\n            tokensPerEth = 1050;\r\n        else if (amount < 150 ether)\r\n            tokensPerEth = 1055;\r\n        else if (amount < 250 ether)\r\n            tokensPerEth = 1060;\r\n        else if (amount < 350 ether)\r\n            tokensPerEth = 1070;\r\n        else if (amount < 500 ether)\r\n            tokensPerEth = 1075;\r\n        else if (amount < 750 ether)\r\n            tokensPerEth = 1080;\r\n        else if (amount < 1000 ether)\r\n            tokensPerEth = 1090;\r\n        else if (amount < 1500 ether)\r\n            tokensPerEth = 1100;\r\n        else if (amount < 2000 ether)\r\n            tokensPerEth = 1110;\r\n        else if (amount < 3500 ether)\r\n            tokensPerEth = 1120;\r\n\r\n        if (currentStage == Stage.PreSale)\r\n            tokensPerEth = tokensPerEth * 2;\r\n\r\n        // Calculate token amount that is purchased,\r\n        // truncate to integer\r\n        uint weiPerEth = 1e18;\r\n        uint tokenAmount = amount * tokensPerEth * tokenMultiplier / weiPerEth;\r\n\r\n        // Check that stage wallet has enough tokens. If not, sell the rest and\r\n        // return change.\r\n        address tokenSaleWallet = currentStage == Stage.PreSale ? presaleWalletAddress : saleWalletAddress;\r\n        uint remainingTokenBalance = tokenReward.accountBalance(tokenSaleWallet);\r\n        if (remainingTokenBalance < tokenAmount) {\r\n            tokenAmount = remainingTokenBalance;\r\n        }\r\n\r\n        // Calculate Wei amount that was received in this transaction\r\n        // adjusted to rounding and remaining token amount\r\n        uint acceptedAmount = tokenAmount * weiPerEth / (tokensPerEth * tokenMultiplier);\r\n\r\n        // Transfer tokens to baker and return ETH change\r\n        tokenReward.transferFrom(tokenSaleWallet, bakerAddress, tokenAmount);\r\n\r\n        TokenTransfer(bakerAddress, tokenAmount, tokensPerEth);\r\n\r\n        uint change = amount - acceptedAmount;\r\n        if (change > 0) {\r\n            if (bakerAddress.send(change)) {\r\n                FundTransfer(address(this), bakerAddress, change);\r\n            }\r\n            else\r\n                revert();\r\n        }\r\n\r\n        // Update crowdsale performance\r\n        investmentRecords[bakerAddress] += acceptedAmount;\r\n        totalCollected += acceptedAmount;\r\n    }\r\n\r\n    /**\r\n    * Change pre-sale end date\r\n    *\r\n    * @param endDate - end date of pre-sale in milliseconds from unix epoch\r\n    */\r\n    function changePresaleEndDate(uint256 endDate) external onlyOwner {\r\n        require(ICOStagePeriod[0] < endDate);\r\n        require(ICOStagePeriod[2] >= endDate);\r\n\r\n        ICOStagePeriod[1] = endDate;\r\n    }\r\n\r\n    /**\r\n    * Change general sale start date\r\n    *\r\n    * @param startDate - start date of general sale in milliseconds from unix epoch\r\n    */\r\n    function changeGeneralSaleStartDate(uint256 startDate) external onlyOwner {\r\n        require(now < startDate);\r\n        require(ICOStagePeriod[1] <= startDate);\r\n\r\n        ICOStagePeriod[2] = startDate;\r\n    }\r\n\r\n    /**\r\n    * Change general sale end date\r\n    *\r\n    * @param endDate - end date of general sale in milliseconds from unix epoch\r\n    */\r\n    function changeGeneralSaleEndDate(uint256 endDate) external onlyOwner {\r\n        require(ICOStagePeriod[2] < endDate);\r\n\r\n        ICOStagePeriod[3] = endDate;\r\n    }\r\n\r\n    /**\r\n    * Stop ICO manually\r\n    */\r\n    function pauseICO() external onlyOwner {\r\n        require(!icoClosedManually);\r\n\r\n        icoClosedManually = true;\r\n    }\r\n\r\n    /**\r\n    * Reopen ICO\r\n    */\r\n    function unpauseICO() external onlyOwner {\r\n        require(icoClosedManually);\r\n\r\n        icoClosedManually = false;\r\n    }\r\n\r\n    /**\r\n    * Close main sale and destroy unsold tokens\r\n    */\r\n    function closeMainSaleICO() external onlyOwner {\r\n        var amountToDestroy = tokenReward.balanceOf(CrowdsaleParameters.generalSaleAddress);\r\n        tokenReward.transferFrom(CrowdsaleParameters.generalSaleAddress, 0, amountToDestroy);\r\n        ICOStagePeriod[3] = now;\r\n        TokenTransfer(0, amountToDestroy, 0);\r\n    }\r\n\r\n    /**\r\n    * Close pre ICO and transfer all unsold tokens to main sale wallet\r\n    */\r\n    function closePreICO() external onlyOwner {\r\n        var amountToTransfer = tokenReward.balanceOf(CrowdsaleParameters.presalePoolAddress);\r\n        ICOStagePeriod[1] = now;\r\n        tokenReward.transferFrom(CrowdsaleParameters.presalePoolAddress, CrowdsaleParameters.generalSaleAddress, amountToTransfer);\r\n    }\r\n\r\n\r\n    /**\r\n    * Allow or disallow refunds\r\n    *\r\n    * @param value - if true, refunds will be allowed; if false, disallowed\r\n    * @param _reasonableCostsPercentage - non-refundable fraction of total\r\n    *        collections in tens of a percent. Valid range is 0 to 1000:\r\n    *        0 = 0.0%, 123 = 12.3%, 1000 = 100.0%\r\n    */\r\n    function setAllowRefunds(bool value, uint _reasonableCostsPercentage) external onlyOwner {\r\n        require(isICOClosed());\r\n        require(_reasonableCostsPercentage >= 1 && _reasonableCostsPercentage <= 999);\r\n\r\n        allowRefunds = value;\r\n        reasonableCostsPercentage = _reasonableCostsPercentage;\r\n    }\r\n\r\n    /**\r\n    *  Transfer ETH amount from contract to owner's address.\r\n    *\r\n    * @param amount - ETH amount to transfer in Wei\r\n    */\r\n    function safeWithdrawal(uint amount) external onlyOwner {\r\n        require(this.balance >= amount);\r\n\r\n        if (owner.send(amount))\r\n            FundTransfer(address(this), owner, amount);\r\n    }\r\n\r\n    /**\r\n    function\r\n    * Is ICO closed (either closed manually or not started)\r\n    *\r\n    * @return true if ICO is closed manually or stage is \"Inactive\", otherwise false\r\n    */\r\n    function isICOClosed() public constant returns (bool closed) {\r\n        Stage currentStage = getActiveStage();\r\n        return icoClosedManually || currentStage == Stage.Inactive;\r\n    }\r\n\r\n    /**\r\n    *  Default method\r\n    *\r\n    *  Processes all ETH that it receives and credits SED tokens to sender\r\n    *  according to current stage and tier bonus\r\n    */\r\n    function () external payable {\r\n        processPayment(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n    *  Kill method\r\n    *\r\n    *  Destructs this contract\r\n    */\r\n    function kill() external onlyOwner {\r\n        require(isICOClosed());\r\n\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    /**\r\n    *  Refund\r\n    *\r\n    *  Sends a partial refund to the sender who calls this method.\r\n    *  Fraction of collected amount will not be refunded\r\n    */\r\n    function refund() external {\r\n        require(isICOClosed() && allowRefunds && investmentRecords[msg.sender] > 0);\r\n\r\n        var amountToReturn = investmentRecords[msg.sender] * (1000 - reasonableCostsPercentage) / 1000;\r\n\r\n        require(this.balance >= amountToReturn);\r\n\r\n        investmentRecords[msg.sender] = 0;\r\n        msg.sender.transfer(amountToReturn);\r\n        Refund(msg.sender, amountToReturn);\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"changeGeneralSaleEndDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ICOStagePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"changePresaleEndDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowRefunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"safeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"bool\"},{\"name\":\"_reasonableCostsPercentage\",\"type\":\"uint256\"}],\"name\":\"setAllowRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closePreICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoClosedManually\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isICOClosed\",\"outputs\":[{\"name\":\"closed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeMainSaleICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"changeGeneralSaleStartDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"baker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"name\":\"TokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "LiveTreeCrowdsale", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000044F850D75023E8d3Da9981B70e84E092c4B1067c", "Library": "", "SwarmSource": "bzzr://df32df02a84b31bb2631a0617816071c22899872010475430d10f80666740363"}]}