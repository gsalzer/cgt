{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\r\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MonsterAccessControl {\r\n\r\n    event ContractUpgrade(address newContract);\r\n\r\n     // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public adminAddress;\r\n    \r\n\r\n  \r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress);\r\n        _;\r\n    }\r\n\r\n  \r\n\r\n    \r\n}\r\n\r\n// This contract stores all data on the blockchain\r\n// only our other contracts can interact with this\r\n// the data here will be valid for all eternity even if other contracts get updated\r\n// this way we can make sure that our Monsters have a hard-coded value attached to them\r\n// that no one including us can change(!)\r\ncontract MonstersData {\r\n\r\n    address coreContract; // \r\n    \r\n\r\n\r\n    struct Monster {\r\n        // timestamp of block when this monster was spawned/created\r\n        uint64 birthTime;\r\n\r\n        // generation number\r\n        // gen0 is the very first generation - the later monster spawn the less likely they are to have\r\n        // special attributes and stats\r\n       // uint16 generation;\r\n\r\n        uint16 hp; // health points \r\n        uint16 attack; // attack points\r\n        uint16 defense; // defense points\r\n        uint16 spAttack; // special attack\r\n        uint16 spDefense; // special defense\r\n        uint16 speed; // speed responsible of who attacks first(!)\r\n        \r\n\r\n        uint16 typeOne;\r\n        uint16 typeTwo;\r\n\r\n        uint16 mID; // this id (from 1 to 151) is responsible for everything visually like showing the real deal!\r\n        bool tradeable;\r\n        //uint16 uID; // unique id\r\n        \r\n        // These attributes are handled by mappings since they would overflow the maximum stack\r\n        //bool female\r\n        // string nickname\r\n        \r\n\r\n    }\r\n\r\n    // lv1 base stats\r\n    struct MonsterBaseStats {\r\n        uint16 hp;\r\n        uint16 attack;\r\n        uint16 defense;\r\n        uint16 spAttack;\r\n        uint16 spDefense;\r\n        uint16 speed;\r\n        \r\n    }\r\n\r\n    // lomonsterion struct used for travelling around the \"world\"\r\n    // \r\n    struct Area {\r\n        // areaID used in-engine to determine world position\r\n       \r\n             \r\n        // minimum level to enter this area...\r\n        uint16 minLevel;\r\n    }\r\n\r\n    struct Trainer {\r\n        // timestamp of block when this player/trainer was created\r\n        uint64 birthTime;\r\n        \r\n        // add username\r\n        string username;\r\n       \r\n        \r\n        // current area in the \"world\"\r\n        uint16 currArea;\r\n        \r\n        address owner;\r\n        \r\n       \r\n        \r\n    }\r\n\r\n\r\n   \r\n\r\n\r\n    // take timestamp of block this game was created on the blockchain\r\n    uint64 creationBlock = uint64(now);\r\n   \r\n   \r\n\r\n   \r\n  \r\n    \r\n\r\n\r\n    \r\n  \r\n        \r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MonstersBase is MonsterAccessControl, MonstersData {\r\n\r\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a monster\r\n    ///  ownership is assigned, including births.\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    bool lockedMonsterCreator = false;\r\n\r\n    MonsterAuction public monsterAuction;\r\n\r\n    MonsterCreatorInterface public monsterCreator;\r\n\r\n\r\n    function setMonsterCreatorAddress(address _address) external onlyAdmin {\r\n        // only set this once so we (the devs) can't cheat!\r\n        require(!lockedMonsterCreator);\r\n        MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address);\r\n\r\n       \r\n\r\n        monsterCreator = candidateContract;\r\n        lockedMonsterCreator = true;\r\n\r\n    }\r\n    \r\n    // An approximation of currently how many seconds are in between blocks.\r\n    uint256 public secondsPerBlock = 15;\r\n  \r\n\r\n    // array containing all monsters in existence\r\n    Monster[] monsters;\r\n\r\n    uint8[] areas;\r\n\r\n    uint8 areaIndex = 0;\r\n    \r\n\r\n\r\n      mapping(address => Trainer) public addressToTrainer;\r\n    \r\n\r\n    /// @dev A mapping from monster IDs to the address that owns them. All monster have\r\n    ///  some valid owner address, even gen0 monster are created with a non-zero owner.\r\n    mapping (uint256 => address) public monsterIndexToOwner;\r\n\r\n    // @dev A mapping from owner address to count of tokens that address owns.\r\n    //  Used internally inside balanceOf() to resolve ownership count.\r\n    mapping (address => uint256) ownershipTokenCount;\r\n\r\n\r\n    mapping (uint256 => address) public monsterIndexToApproved;\r\n    \r\n    mapping (uint256 => string) public monsterIdToNickname;\r\n    \r\n    mapping (uint256 => bool) public monsterIdToTradeable;\r\n    \r\n    mapping (uint256 => uint256) public monsterIdToGeneration;\r\n\r\n\r\n     mapping (uint256 => MonsterBaseStats) public baseStats;\r\n\r\n     mapping (uint256 => uint8[7]) public monsterIdToIVs;\r\n    \r\n\r\n\r\n    // adds new area to world \r\n    function _createArea() internal {\r\n            \r\n            areaIndex++;\r\n            areas.push(areaIndex);\r\n            \r\n            \r\n        }\r\n\r\n    \r\n\r\n\r\n    function _createMonster(\r\n        uint256 _generation,\r\n        uint256 _hp,\r\n        uint256 _attack,\r\n        uint256 _defense,\r\n        uint256 _spAttack,\r\n        uint256 _spDefense,\r\n        uint256 _speed,\r\n        uint256 _typeOne,\r\n        uint256 _typeTwo,\r\n        address _owner,\r\n        uint256 _mID,\r\n        bool tradeable\r\n        \r\n    )\r\n        internal\r\n        returns (uint)\r\n        {\r\n           \r\n\r\n            Monster memory _monster = Monster({\r\n                birthTime: uint64(now),\r\n                hp: uint16(_hp),\r\n                attack: uint16(_attack),\r\n                defense: uint16(_defense),\r\n                spAttack: uint16(_spAttack),\r\n                spDefense: uint16(_spDefense),\r\n                speed: uint16(_speed),\r\n                typeOne: uint16(_typeOne),\r\n                typeTwo: uint16(_typeTwo),\r\n                mID: uint16(_mID),\r\n                tradeable: tradeable\r\n                \r\n\r\n\r\n            });\r\n            uint256 newMonsterId = monsters.push(_monster) - 1;\r\n            monsterIdToTradeable[newMonsterId] = tradeable;\r\n            monsterIdToGeneration[newMonsterId] = _generation;\r\n           \r\n\r\n            require(newMonsterId == uint256(uint32(newMonsterId)));\r\n            \r\n           \r\n          \r\n            \r\n             monsterIdToNickname[newMonsterId] = \"\";\r\n\r\n            _transfer(0, _owner, newMonsterId);\r\n\r\n            return newMonsterId;\r\n\r\n\r\n        }\r\n    \r\n    function _createTrainer(string _username, uint16 _starterId, address _owner)\r\n        internal\r\n        returns (uint mon)\r\n        {\r\n            \r\n           \r\n            Trainer memory _trainer = Trainer({\r\n               \r\n                birthTime: uint64(now),\r\n                username: string(_username),\r\n                currArea: uint16(1), // sets to first area!,\r\n                owner: address(_owner)\r\n                \r\n            });\r\n            \r\n            // starter stats are hardcoded!\r\n            if (_starterId == 1) {\r\n                uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(1));\r\n                mon = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, 1, false);\r\n               \r\n            } else if (_starterId == 2) {\r\n                uint8[8] memory Stats2 = uint8[8](monsterCreator.getMonsterStats(4));\r\n                mon = _createMonster(0, Stats2[0], Stats2[1], Stats2[2], Stats2[3], Stats2[4], Stats2[5], Stats2[6], Stats2[7], _owner, 4, false);\r\n                \r\n            } else if (_starterId == 3) {\r\n                uint8[8] memory Stats3 = uint8[8](monsterCreator.getMonsterStats(7));\r\n                mon = _createMonster(0, Stats3[0], Stats3[1], Stats3[2], Stats3[3], Stats3[4], Stats3[5], Stats3[6], Stats3[7], _owner, 7, false);\r\n                \r\n            }\r\n            \r\n        }\r\n\r\n\r\n    function _moveToArea(uint16 _newArea, address player) internal {\r\n            \r\n            addressToTrainer[player].currArea = _newArea;\r\n          \r\n        }   \r\n        \r\n    \r\n     \r\n\r\n    \r\n    // assigns ownership of monster to address\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        ownershipTokenCount[_to]++;\r\n        monsterIndexToOwner[_tokenId] = _to;\r\n\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // clear any previously approved ownership exchange\r\n            delete monsterIndexToApproved[_tokenId];\r\n        }\r\n\r\n        // Emit Transfer event\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n\r\n    // Only admin can fix how many seconds per blocks are currently observed.\r\n    function setSecondsPerBlock(uint256 secs) external onlyAdmin {\r\n        //require(secs < cooldowns[0]);\r\n        secondsPerBlock = secs;\r\n    }\r\n\r\n\r\n    \r\n\r\n\r\n}\r\n\r\n/// @title The external contract that is responsible for generating metadata for the monsters,\r\n///  it has one function that will return the data as bytes.\r\ncontract ERC721Metadata {\r\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\r\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\r\n        if (_tokenId == 1) {\r\n            buffer[0] = \"Hello World! :D\";\r\n            count = 15;\r\n        } else if (_tokenId == 2) {\r\n            buffer[0] = \"I would definitely choose a medi\";\r\n            buffer[1] = \"um length string.\";\r\n            count = 49;\r\n        } else if (_tokenId == 3) {\r\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\r\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\r\n            buffer[2] = \" tristique vestibulum id, libero\";\r\n            buffer[3] = \" suscipit varius sapien aliquam.\";\r\n            count = 128;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract MonsterOwnership is MonstersBase, ERC721 {\r\n\r\n    string public constant name = \"ChainMonsters\";\r\n    string public constant symbol = \"CHMO\";\r\n\r\n\r\n    // The contract that will return monster metadata\r\n    ERC721Metadata public erc721Metadata;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 =\r\n        bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n\r\n\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 =\r\n        bytes4(keccak256('name()')) ^\r\n        bytes4(keccak256('symbol()')) ^\r\n        bytes4(keccak256('totalSupply()')) ^\r\n        bytes4(keccak256('balanceOf(address)')) ^\r\n        bytes4(keccak256('ownerOf(uint256)')) ^\r\n        bytes4(keccak256('approve(address,uint256)')) ^\r\n        bytes4(keccak256('transfer(address,uint256)')) ^\r\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n        bytes4(keccak256('tokensOfOwner(address)')) ^\r\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n\r\n\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        // DEBUG ONLY\r\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\r\n\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    /// @dev Set the address of the sibling contract that tracks metadata.\r\n    ///  CEO only.\r\n    function setMetadataAddress(address _contractAddress) public onlyAdmin {\r\n        erc721Metadata = ERC721Metadata(_contractAddress);\r\n    }\r\n\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return monsterIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n    \r\n    function _isTradeable(uint256 _tokenId) external view returns (bool) {\r\n        return monsterIdToTradeable[_tokenId];\r\n    }\r\n    \r\n    \r\n    /// @dev Checks if a given address currently has transferApproval for a particular monster.\r\n    /// @param _claimant the address we are confirming monster is approved for.\r\n    /// @param _tokenId monster id, only valid when > 0\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return monsterIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\r\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\r\n    ///  _approve() and transferFrom() are used together for putting monsters on auction, and\r\n    ///  there is no value in spamming the log with Approval events in that case.\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        monsterIndexToApproved[_tokenId] = _approved;\r\n    }\r\n    \r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n\r\n    function transfer (address _to, uint256 _tokenId) external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any monsters (except very briefly\r\n        // after a gen0 monster is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        \r\n\r\n        // You can only send your own monster.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    \r\n    \r\n\r\n/// @notice Grant another address the right to transfer a specific monster via\r\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n    ///  clear all approvals.\r\n    /// @param _tokenId The ID of the monster that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function approve(address _to, uint256 _tokenId ) external {\r\n        // Only an owner can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Transfer a monster owned by another address, for which the calling address\r\n    ///  has previously been granted transfer approval by the owner.\r\n    /// @param _from The address that owns the monster to be transfered.\r\n    /// @param _to The address that should take ownership of the monster. Can be any address,\r\n    ///  including the caller.\r\n    /// @param _tokenId The ID of the monster to be transferred.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom (address _from, address _to, uint256 _tokenId ) external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any monsters (except very briefly\r\n        // after a gen0 monster is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        //require(_approvedFor(msg.sender, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return monsters.length;\r\n    }\r\n\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n            external\r\n            view\r\n            returns (address owner)\r\n        {\r\n            owner = monsterIndexToOwner[_tokenId];\r\n\r\n            require(owner != address(0));\r\n        }\r\n\r\n     function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalMonsters = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            \r\n            uint256 monsterId;\r\n\r\n            for (monsterId = 0; monsterId <= totalMonsters; monsterId++) {\r\n                if (monsterIndexToOwner[monsterId] == _owner) {\r\n                    result[resultIndex] = monsterId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n\r\n   \r\n\r\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _memcpy(uint _dest, uint _src, uint _len) private view {\r\n        // Copy word-length chunks while possible\r\n        for(; _len >= 32; _len -= 32) {\r\n            assembly {\r\n                mstore(_dest, mload(_src))\r\n            }\r\n            _dest += 32;\r\n            _src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256 ** (32 - _len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(_src), not(mask))\r\n            let destpart := and(mload(_dest), mask)\r\n            mstore(_dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\r\n    ///  This method is licenced under the Apache License.\r\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\r\n        var outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n    /// @notice Returns a URI pointing to a metadata package for this token conforming to\r\n    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\r\n    /// @param _tokenId The ID number of the monster whose metadata should be returned.\r\n    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\r\n        require(erc721Metadata != address(0));\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n\r\n}\r\n\r\ncontract MonsterAuctionBase {\r\n    \r\n    \r\n    // Reference to contract tracking NFT ownership\r\n    ERC721 public nonFungibleContract;\r\n    ChainMonstersCore public core;\r\n    \r\n    struct Auction {\r\n\r\n        // current owner\r\n        address seller;\r\n\r\n        // price in wei\r\n        uint256 price;\r\n\r\n        // time when auction started\r\n        uint64 startedAt;\r\n\r\n        uint256 id;\r\n    }\r\n\r\n  \r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping(uint256 => Auction) tokenIdToAuction;\r\n\r\n    mapping(uint256 => address) public auctionIdToSeller;\r\n    \r\n    mapping (address => uint256) public ownershipAuctionCount;\r\n\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 price, uint256 uID, address seller);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 price, address newOwner, uint256 uID);\r\n    event AuctionCancelled(uint256 tokenId, uint256 uID);\r\n\r\n\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transfer(_receiver, _tokenId);\r\n    }\r\n\r\n\r\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\r\n        \r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.price),\r\n            uint256(_auction.id),\r\n            address(_auction.seller)\r\n        );\r\n       \r\n    }\r\n\r\n\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        \r\n        Auction storage _auction = tokenIdToAuction[_tokenId];\r\n\r\n        uint256 uID = _auction.id;\r\n        \r\n        _removeAuction(_tokenId);\r\n        ownershipAuctionCount[_seller]--;\r\n        _transfer(_seller, _tokenId);\r\n        \r\n        AuctionCancelled(_tokenId, uID);\r\n    }\r\n\r\n\r\n    function _buy(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n        {\r\n            Auction storage auction = tokenIdToAuction[_tokenId];\r\n        \r\n\r\n        require(_isOnAuction(auction));\r\n\r\n        uint256 price = auction.price;\r\n        require(_bidAmount >= price);\r\n\r\n        address seller = auction.seller;\r\n\r\n        uint256 uID = auction.id;\r\n        // Auction Bid looks fine! so remove\r\n        _removeAuction(_tokenId);\r\n        ownershipAuctionCount[seller]--;\r\n\r\n        if (price > 0) {\r\n\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            if(seller != address(core)) {\r\n                seller.transfer(sellerProceeds);\r\n            }\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(_tokenId, price, msg.sender, uID);\r\n\r\n        return price;\r\n\r\n\r\n    }\r\n\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n     function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n    \r\n\r\n}\r\n\r\n\r\ncontract MonsterAuction is  MonsterAuctionBase, Ownable {\r\n\r\n\r\n    bool public isMonsterAuction = true;\r\n     uint256 public auctionIndex = 0;\r\n\r\n    /// @dev The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\r\n\r\n    function MonsterAuction(address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ERC721 candidateContract = ERC721(_nftAddress);\r\n        \r\n        nonFungibleContract = candidateContract;\r\n        ChainMonstersCore candidateCoreContract = ChainMonstersCore(_nftAddress);\r\n        core = candidateCoreContract;\r\n\r\n        \r\n    }\r\n    \r\n    // only possible to decrease ownerCut!\r\n    function setOwnerCut(uint256 _cut) external onlyOwner {\r\n        require(_cut <= ownerCut);\r\n        ownerCut = _cut;\r\n    }\r\n    \r\n    \r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n    \r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    function withdrawBalance() external onlyOwner {\r\n       \r\n       \r\n       uint256 balance = this.balance;\r\n       \r\n       \r\n        owner.transfer(balance);\r\n\r\n        \r\n       \r\n    }\r\n\r\n    \r\n    function tokensInAuctionsOfOwner(address _owner) external view returns(uint256[] auctionTokens) {\r\n        \r\n           uint256 numAuctions = ownershipAuctionCount[_owner];\r\n\r\n            \r\n        \r\n            uint256[] memory result = new uint256[](numAuctions);\r\n            uint256 totalAuctions = core.totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            \r\n            uint256 auctionId;\r\n\r\n            for (auctionId = 0; auctionId <= totalAuctions; auctionId++) {\r\n                \r\n                Auction storage auction = tokenIdToAuction[auctionId];\r\n                if (auction.seller == _owner) {\r\n                    \r\n                    result[resultIndex] = auctionId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        \r\n        \r\n    }\r\n\r\n\r\n\r\n\r\n    function createAuction(uint256 _tokenId, uint256 _price, address _seller) external {\r\n             require(_price == uint256(_price));\r\n            require(core._isTradeable(_tokenId));\r\n             require(_owns(msg.sender, _tokenId));\r\n             _escrow(msg.sender, _tokenId);\r\n\r\n            \r\n\r\n            \r\n             Auction memory auction = Auction(\r\n                 _seller,\r\n                 uint256(_price),\r\n                 uint64(now),\r\n                 uint256(auctionIndex)\r\n             );\r\n\r\n            auctionIdToSeller[auctionIndex] = _seller;\r\n            ownershipAuctionCount[_seller]++;\r\n            \r\n             auctionIndex++;\r\n             _addAuction(_tokenId, auction);\r\n        }\r\n\r\n    function buy(uint256 _tokenId) external payable {\r\n            //delete auctionIdToSeller[_tokenId];\r\n            // buy will throw if the bid or funds transfer fails\r\n            _buy (_tokenId, msg.value);\r\n            _transfer(msg.sender, _tokenId);\r\n            \r\n            \r\n        }\r\n\r\n    \r\n    function cancelAuction(uint256 _tokenId) external {\r\n            Auction storage auction = tokenIdToAuction[_tokenId];\r\n            require(_isOnAuction(auction));\r\n\r\n            address seller = auction.seller;\r\n            require(msg.sender == seller);\r\n            \r\n            \r\n            _cancelAuction(_tokenId, seller);\r\n        }\r\n\r\n    \r\n    function getAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns\r\n        (\r\n            address seller,\r\n            uint256 price,\r\n            uint256 startedAt\r\n        ) {\r\n            Auction storage auction = tokenIdToAuction[_tokenId];\r\n            require(_isOnAuction(auction));\r\n\r\n            return (\r\n                auction.seller,\r\n                auction.price,\r\n                auction.startedAt\r\n            );\r\n        }\r\n\r\n\r\n    function getPrice(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n        {\r\n            Auction storage auction = tokenIdToAuction[_tokenId];\r\n            require(_isOnAuction(auction));\r\n            return auction.price;\r\n        }\r\n}\r\n\r\n\r\ncontract ChainMonstersAuction is MonsterOwnership {\r\n\r\n  \r\n\r\n\r\n    function setMonsterAuctionAddress(address _address) external onlyAdmin {\r\n        MonsterAuction candidateContract = MonsterAuction(_address);\r\n\r\n        require(candidateContract.isMonsterAuction());\r\n\r\n        monsterAuction = candidateContract;\r\n    }\r\n\r\n\r\n\r\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\r\n\r\n    uint256 public constant GEN0_CREATION_LIMIT = 5000;\r\n\r\n    // Counts the number of monster the contract owner has created.\r\n    uint256 public promoCreatedCount;\r\n    uint256 public gen0CreatedCount;\r\n\r\n\r\n    \r\n    // its stats are completely dependent on the spawn alghorithm\r\n    function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {\r\n       \r\n\r\n       // during generation we have to keep in mind that we have only 10,000 tokens available\r\n       // which have to be divided by 151 monsters, some rarer than others\r\n       // see WhitePaper for gen0/promo monster plan\r\n        \r\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\r\n\r\n        promoCreatedCount++;\r\n        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));\r\n        uint8[7] memory IVs = uint8[7](monsterCreator.getGen0IVs());\r\n        \r\n        uint256 monsterId = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, _mId, true);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        monsterIdToIVs[monsterId] = IVs;\r\n        \r\n       \r\n    }\r\n\r\n   \r\n\r\n\r\n    function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {\r\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n\r\n        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));\r\n        uint8[7] memory IVs = uint8[7](monsterCreator.getGen0IVs());\r\n        uint256 monsterId = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], this, _mId, true);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        monsterIdToIVs[monsterId] = IVs;\r\n\r\n        monsterAuction.createAuction(monsterId, price, address(this));\r\n\r\n\r\n        gen0CreatedCount++;\r\n        \r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\n// used during launch for world championship\r\n// can and will be upgraded during development with new battle system!\r\n// this is just to give players something to do and test their monsters\r\n// also demonstrates how we can build up more mechanics on top of our locked core contract!\r\ncontract MonsterChampionship is Ownable {\r\n\r\n    bool public isMonsterChampionship = true;\r\n    \r\n    ChainMonstersCore core;\r\n    \r\n    // list of top ten \r\n    address[10] topTen;\r\n\r\n    // holds the address current \"world\" champion\r\n    address public currChampion;\r\n    \r\n    \r\n    mapping (address => uint256) public addressToPowerlevel;\r\n    mapping (uint256 => address) public rankToAddress;\r\n    \r\n\r\n   \r\n    \r\n    \r\n     // try to beat every other player in the top10 with your strongest monster!\r\n    // effectively looping through all top10 players, beating them one by one \r\n    // and if strong enough placing your in the top10 as well\r\n    function contestChampion(uint256 _tokenId) external {\r\n            uint maxIndex = 9;\r\n            \r\n           \r\n            \r\n           \r\n            \r\n            // fail tx if player is already champion!\r\n            // in theory players could increase their powerlevel by contesting themselves but\r\n            // this check stops that from happening so other players have the chance to\r\n            // become the temporary champion!\r\n            if (currChampion == msg.sender)\r\n                revert();\r\n                \r\n            \r\n           require(core.isTrainer(msg.sender));        \r\n           require(core.monsterIndexToOwner(_tokenId) == msg.sender);\r\n            \r\n           \r\n           uint myPowerlevel = core.getMonsterPowerLevel(_tokenId);\r\n\r\n           \r\n           // checks if this transaction is useless\r\n           // since we can't fight against ourself!\r\n           // also stops reentrancy attacks\r\n           require(myPowerlevel > addressToPowerlevel[msg.sender]);\r\n           \r\n          \r\n           uint myRank = 0;\r\n            \r\n            for (uint i=0; i<=maxIndex; i++) {\r\n                //if (addres)\r\n                if ( myPowerlevel > addressToPowerlevel[topTen[i]] ) {\r\n                    // you have beaten this one so increase temporary rank\r\n                    myRank = i;\r\n                    \r\n                    if (myRank == maxIndex) {\r\n                        currChampion = msg.sender;\r\n                    }\r\n                    \r\n                    \r\n                    \r\n                    \r\n                }\r\n               \r\n                \r\n                \r\n               \r\n               \r\n            }\r\n            \r\n            addressToPowerlevel[msg.sender] = myPowerlevel;\r\n            \r\n            address[10] storage newTopTen = topTen;\r\n            \r\n            if (currChampion == msg.sender) {\r\n                for (uint j=0; j<maxIndex; j++) {\r\n                    // remove ourselves from this list in case \r\n                    if (newTopTen[j] == msg.sender) {\r\n                        newTopTen[j] = 0x0;\r\n                        break;\r\n                    }\r\n                    \r\n                }\r\n            }\r\n            \r\n            \r\n            for (uint x=0; x<=myRank; x++) {\r\n                if (x == myRank) {\r\n                    \r\n                   \r\n                    newTopTen[x] = msg.sender;\r\n                } else {\r\n                    if (x < maxIndex)\r\n                        newTopTen[x] = topTen[x+1];    \r\n                }\r\n                \r\n                \r\n            }\r\n            \r\n            \r\n            topTen = newTopTen;\r\n            \r\n        }\r\n    \r\n    \r\n    \r\n    function getTopPlayers()\r\n        external\r\n        view\r\n        returns (\r\n            address[10] players\r\n        ) {\r\n            players = topTen;\r\n        }\r\n    \r\n\r\n\r\n\r\n    \r\n    \r\n    \r\n    \r\n    function MonsterChampionship(address coreContract) public {\r\n       core = ChainMonstersCore(coreContract);\r\n    }\r\n    \r\n    function withdrawBalance() external onlyOwner {\r\n       \r\n        uint256 balance = this.balance;\r\n       \r\n       \r\n        owner.transfer(balance);\r\n        \r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n// where the not-so-much \"hidden\" magic happens\r\ncontract MonsterCreatorInterface is Ownable {\r\n\r\n    uint8 public lockedMonsterStatsCount = 0;\r\n    uint nonce = 0;\r\n\r\n    function rand(uint8 min, uint8 max) public returns (uint8) {\r\n        nonce++;\r\n        uint8 result = (uint8(sha3(block.blockhash(block.number-1), nonce ))%max);\r\n        \r\n        if (result < min)\r\n        {\r\n            result = result+min;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    \r\n\r\n\r\n    function shinyRand(uint16 min, uint16 max) public returns (uint16) {\r\n        nonce++;\r\n        uint16 result = (uint16(sha3(block.blockhash(block.number-1), nonce ))%max);\r\n        \r\n        if (result < min)\r\n        {\r\n            result = result+min;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    \r\n    \r\n    mapping(uint256 => uint8[8]) public baseStats;\r\n\r\n    function addBaseStats(uint256 _mId, uint8[8] data) external onlyOwner {\r\n        // lock\" the stats down forever\r\n        // since hp is never going to be 0 this is a valid check\r\n        // so we have to be extra careful when adding new baseStats!\r\n        require(data[0] > 0);\r\n        require(baseStats[_mId][0] == 0);\r\n        baseStats[_mId] = data;\r\n    }\r\n    \r\n    function _addBaseStats(uint256 _mId, uint8[8] data) internal {\r\n        \r\n        \r\n        baseStats[_mId] = data;\r\n        lockedMonsterStatsCount++;\r\n    }\r\n\r\n\r\n    \r\n\r\n\r\n    \r\n    function MonsterCreatorInterface() public {\r\n        \r\n       // these monsters are already down and \"locked\" down stats/design wise\r\n        _addBaseStats(1, [45, 49, 49, 65, 65, 45, 12, 4]);\r\n        _addBaseStats(2, [60, 62, 63, 80, 80, 60, 12, 4]);\r\n        _addBaseStats(3, [80, 82, 83, 100, 100, 80, 12, 4]);\r\n        _addBaseStats(4, [39, 52, 43, 60, 50, 65, 10, 6]);\r\n        _addBaseStats(5, [58, 64, 58, 80, 65, 80, 10, 6]);\r\n        _addBaseStats(6, [78, 84, 78, 109, 85, 100, 10, 6]);\r\n        _addBaseStats(7, [44, 48, 65, 50, 64, 43, 11, 14]);\r\n        _addBaseStats(8, [59, 63, 80, 65, 80, 58, 11, 14]);\r\n        _addBaseStats(9, [79, 83, 100, 85, 105, 78, 11, 14]);\r\n        _addBaseStats(10, [40, 35, 30, 20, 20, 50, 7, 4]);\r\n        \r\n        _addBaseStats(149, [55, 50, 45, 135, 95, 120, 8, 14]);\r\n        _addBaseStats(150, [91, 134, 95, 100, 100, 80, 2, 5]);\r\n        _addBaseStats(151, [100, 100, 100, 100, 100, 100, 5, 19]);\r\n    }\r\n    \r\n    // this serves as a lookup for new monsters to be generated since all monsters \r\n    // of the same id share the base stats\r\n    function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) {\r\n           stats[0] = baseStats[_mID][0];\r\n           stats[1] = baseStats[_mID][1];\r\n           stats[2] = baseStats[_mID][2];\r\n           stats[3] = baseStats[_mID][3];\r\n           stats[4] = baseStats[_mID][4];\r\n           stats[5] = baseStats[_mID][5];\r\n           stats[6] = baseStats[_mID][6];\r\n           stats[7] = baseStats[_mID][7];\r\n           \r\n          \r\n\r\n        }\r\n\r\n        // generates randomized IVs for a new monster\r\n        function getMonsterIVs() external returns(uint8[7] ivs) {\r\n\r\n            bool shiny = false;\r\n\r\n            uint16 chance = shinyRand(1, 8192);\r\n\r\n            if (chance == 42) {\r\n                shiny = true;\r\n            }\r\n\r\n            // IVs range between 0 and 31\r\n            // stat range modified for shiny monsters!\r\n            if (shiny == true) {\r\n                ivs[0] = uint8(rand(10, 31));\r\n                ivs[1] = uint8(rand(10, 31));\r\n                ivs[2] = uint8(rand(10, 31));\r\n                ivs[3] = uint8(rand(10, 31));\r\n                ivs[4] = uint8(rand(10, 31));\r\n                ivs[5] = uint8(rand(10, 31));\r\n                ivs[6] = 1;\r\n                \r\n            } else {\r\n                ivs[0] = uint8(rand(0, 31));\r\n                ivs[1] = uint8(rand(0, 31));\r\n                ivs[2] = uint8(rand(0, 31));\r\n                ivs[3] = uint8(rand(0, 31));\r\n                ivs[4] = uint8(rand(0, 31));\r\n                ivs[5] = uint8(rand(0, 31));\r\n                ivs[6] = 0;\r\n            }\r\n\r\n            \r\n\r\n        }\r\n\r\n\r\n        // gen0 monsters profit from shiny boost while shiny gen0s have potentially even higher IVs!\r\n        // further increasing the rarity by also doubling the shiny chance!\r\n        function getGen0IVs() external returns (uint8[7] ivs) {\r\n            \r\n            bool shiny = false;\r\n\r\n            uint16 chance = shinyRand(1, 4096);\r\n\r\n            if (chance == 42) {\r\n                shiny = true;\r\n            }\r\n            \r\n            if (shiny) {\r\n                 ivs[0] = uint8(rand(15, 31));\r\n                ivs[1] = uint8(rand(15, 31));\r\n                ivs[2] = uint8(rand(15, 31));\r\n                ivs[3] = uint8(rand(15, 31));\r\n                ivs[4] = uint8(rand(15, 31));\r\n                ivs[5] = uint8(rand(15, 31));\r\n                ivs[6] = 1;\r\n                \r\n            } else {\r\n                ivs[0] = uint8(rand(10, 31));\r\n                ivs[1] = uint8(rand(10, 31));\r\n                ivs[2] = uint8(rand(10, 31));\r\n                ivs[3] = uint8(rand(10, 31));\r\n                ivs[4] = uint8(rand(10, 31));\r\n                ivs[5] = uint8(rand(10, 31));\r\n                ivs[6] = 0;\r\n            }\r\n            \r\n        }\r\n        \r\n        function withdrawBalance() external onlyOwner {\r\n       \r\n        uint256 balance = this.balance;\r\n       \r\n       \r\n        owner.transfer(balance);\r\n        \r\n    }\r\n}\r\n\r\ncontract GameLogicContract {\r\n    \r\n    bool public isGameLogicContract = true;\r\n    \r\n    function GameLogicContract() public {\r\n        \r\n    }\r\n}\r\n\r\ncontract ChainMonstersCore is ChainMonstersAuction, Ownable {\r\n\r\n\r\n   // using a bool to enable us to prepare the game \r\n   bool hasLaunched = false;\r\n\r\n\r\n    // this address will hold future gamelogic in place\r\n    address gameContract;\r\n    \r\n\r\n    function ChainMonstersCore() public {\r\n\r\n        adminAddress = msg.sender;\r\n        \r\n\r\n        _createArea(); // area 1\r\n        _createArea(); // area 2\r\n        \r\n    \r\n\r\n        \r\n    }\r\n    \r\n    // we don't know the exact interfaces yet so use the lockedMonsterStats value to determine if the game is \"ready\"\r\n    // see WhitePaper for explaination for our upgrade and development roadmap\r\n    function setGameLogicContract(address _candidateContract) external onlyOwner {\r\n        require(monsterCreator.lockedMonsterStatsCount() == 151);\r\n        \r\n        require(GameLogicContract(_candidateContract).isGameLogicContract());\r\n        gameContract = _candidateContract;\r\n    }\r\n\r\n    // only callable by gameContract after the full game is launched\r\n    // since all additional monsters after the promo/gen0 ones need to use this coreContract\r\n    // contract as well we have to prepare this core for our future updates where\r\n    // players can freely roam the world and hunt ChainMonsters thus generating more\r\n    function spawnMonster(uint256 _mId, address _owner) external {\r\n         \r\n        require(msg.sender == gameContract);\r\n        \r\n        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));\r\n        uint8[7] memory IVs = uint8[7](monsterCreator.getMonsterIVs());\r\n        \r\n        // important to note that the IV generators do not use Gen0 methods and are Generation 1 \r\n        // this means there won't be more than the 10,000 Gen0 monsters sold during the development through the marketplace\r\n        uint256 monsterId = _createMonster(1, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, _mId, true);\r\n        monsterIdToTradeable[monsterId] = true;\r\n\r\n        monsterIdToIVs[monsterId] = IVs;\r\n    }\r\n    \r\n    \r\n    // used to add playable content to the game \r\n    // monsters will only spawn in certain areas so some are locked on release\r\n    // due to the game being in active development on \"launch\"\r\n    // each monster has a maximum number of 3 areas where it can appear\r\n    // \r\n     function createArea() public onlyAdmin {\r\n            _createArea();\r\n        }\r\n\r\n    function createTrainer(string _username, uint16 _starterId) public {\r\n            \r\n            require(hasLaunched);\r\n\r\n            // only one trainer/account per ethereum address\r\n            require(addressToTrainer[msg.sender].owner == 0);\r\n           \r\n           // valid input check\r\n            require(_starterId == 1 || _starterId == 2 || _starterId == 3 );\r\n            \r\n            uint256 mon = _createTrainer(_username, _starterId, msg.sender);\r\n            \r\n            // due to stack limitations we have to assign the IVs here:\r\n            uint8[7] memory IVs = uint8[7](monsterCreator.getMonsterIVs());\r\n            monsterIdToIVs[mon] = IVs;\r\n            \r\n        }\r\n        \r\n        \r\n    function changeUsername(string _name) public {\r\n            require(addressToTrainer[msg.sender].owner == msg.sender);\r\n            \r\n            \r\n            addressToTrainer[msg.sender].username = _name;\r\n        }\r\n        \r\n    function changeMonsterNickname(uint256 _tokenId, string _name) public {\r\n            // users won't be able to rename a monster that is part of an auction\r\n            require(_owns(msg.sender, _tokenId));\r\n            \r\n            \r\n            // some string checks...?\r\n            monsterIdToNickname[_tokenId] = _name;\r\n        }\r\n\r\n    function moveToArea(uint16 _newArea) public {\r\n           \r\n            // never allow anyone to move to area 0 or below since this is used\r\n            // to determine if a trainer profile exists in another method!\r\n            require(_newArea > 0);\r\n            \r\n            // make sure that this area exists yet!\r\n            require(areas.length >= _newArea);\r\n             \r\n            // when player is not stuck doing something else he can move freely!\r\n            _moveToArea(_newArea, msg.sender);\r\n        }\r\n\r\n    \r\n    // to be changed to retrieve current stats!\r\n    function getMonster(uint256 _id) external view returns (\r\n        uint256 birthTime,\r\n        uint256 generation,\r\n        uint256 hp,\r\n        uint256 attack,\r\n        uint256 defense,\r\n        uint256 spAttack,\r\n        uint256 spDefense,\r\n        uint256 speed,\r\n        uint256 typeOne,\r\n        uint256 typeTwo,\r\n        \r\n        uint256 mID,\r\n        bool tradeable, \r\n        uint256 uID\r\n        \r\n            \r\n        ) {    \r\n       Monster storage mon = monsters[_id];\r\n        birthTime = uint256(mon.birthTime);\r\n        generation = 0; // hardcoding due to stack too deep error\r\n        hp = uint256(mon.hp);\r\n        attack = uint256(mon.attack);\r\n        defense = uint256(mon.defense);\r\n        spAttack = uint256(mon.spAttack);\r\n        spDefense = uint256(mon.spDefense);\r\n        speed = uint256(mon.speed);\r\n        typeOne = uint256(mon.typeOne);\r\n        typeTwo = uint256(mon.typeTwo);\r\n        mID = uint256(mon.mID);\r\n        tradeable = bool(mon.tradeable);\r\n        \r\n        // hack to overcome solidity's stack limitation in monster struct....\r\n        uID = _id;\r\n            \r\n        }\r\n\r\n        \r\n        // this method only returns the \"base\" powerlevel of a monster which will be used\r\n        // in more advanced fighting calculations later on\r\n    function getMonsterPowerLevel(uint256 _tokenId) external view returns (\r\n            uint256 powerlevel\r\n        ) {\r\n            Monster storage mon = monsters[_tokenId];\r\n            uint8[7] storage IVs = monsterIdToIVs[_tokenId];\r\n\r\n            \r\n            powerlevel = mon.hp + IVs[0] + mon.attack + IVs[1] + mon.defense + IVs[2] + mon.spAttack + IVs[3] + mon.spDefense + IVs[4] + mon.speed + IVs[5];\r\n        }\r\n        \r\n        \r\n        \r\n\r\n   \r\n    \r\n    function isTrainer(address _check)\r\n    external \r\n    view \r\n    returns (\r\n        bool isTrainer\r\n    ) {\r\n        Trainer storage trainer = addressToTrainer[_check];\r\n\r\n        if (trainer.currArea > 0)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n   \r\n\r\n    \r\n   \r\n   \r\n    function withdrawBalance() external onlyOwner {\r\n       \r\n        uint256 balance = this.balance;\r\n       \r\n       \r\n        owner.transfer(balance);\r\n        \r\n    }\r\n\r\n    // after we have setup everything we can unlock the game\r\n    // for public\r\n    function launchGame() external onlyOwner {\r\n        hasLaunched = true;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"min\",\"type\":\"uint8\"},{\"name\":\"max\",\"type\":\"uint8\"}],\"name\":\"rand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getGen0IVs\",\"outputs\":[{\"name\":\"ivs\",\"type\":\"uint8[7]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"min\",\"type\":\"uint16\"},{\"name\":\"max\",\"type\":\"uint16\"}],\"name\":\"shinyRand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedMonsterStatsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"uint8[8]\"}],\"name\":\"addBaseStats\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"baseStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMonsterIVs\",\"outputs\":[{\"name\":\"ivs\",\"type\":\"uint8[7]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mID\",\"type\":\"uint256\"}],\"name\":\"getMonsterStats\",\"outputs\":[{\"name\":\"stats\",\"type\":\"uint8[8]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "MonsterCreatorInterface", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://0bddd70d096f0185f5070d1378a9ae40071d4385e3003102b7ae23b917227059"}]}