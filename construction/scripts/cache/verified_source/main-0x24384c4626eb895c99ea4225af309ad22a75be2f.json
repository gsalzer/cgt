{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n/**\r\n * @title Owned contract with safe ownership pass.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract Owned {\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public contractOwner;\r\n\r\n    /**\r\n     * Contract owner address\r\n     */\r\n    address public pendingContractOwner;\r\n\r\n    function Owned() {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner check modifier\r\n    */\r\n    modifier onlyContractOwner() {\r\n        if (contractOwner == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy contract and scrub a data\r\n     * @notice Only owner can call it\r\n     */\r\n    function destroy() onlyContractOwner {\r\n        suicide(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Prepares ownership pass.\r\n     *\r\n     * Can only be called by current owner.\r\n     *\r\n     * @param _to address of the next owner. 0x0 is not allowed.\r\n     *\r\n     * @return success.\r\n     */\r\n    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\r\n        if (_to  == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Finalize ownership pass.\r\n     *\r\n     * Can only be called by pending owner.\r\n     *\r\n     * @return success.\r\n     */\r\n    function claimContractOwnership() returns(bool) {\r\n        if (pendingContractOwner != msg.sender) {\r\n            return false;\r\n        }\r\n\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    string public symbol;\r\n\r\n    function totalSupply() constant returns (uint256 supply);\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n}\r\n\r\n/**\r\n * @title Generic owned destroyable contract\r\n */\r\ncontract Object is Owned {\r\n    /**\r\n    *  Common result code. Means everything is fine.\r\n    */\r\n    uint constant OK = 1;\r\n    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\r\n\r\n    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\r\n        for(uint i=0;i<tokens.length;i++) {\r\n            address token = tokens[i];\r\n            uint balance = ERC20Interface(token).balanceOf(this);\r\n            if(balance != 0)\r\n                ERC20Interface(token).transfer(_to,balance);\r\n        }\r\n        return OK;\r\n    }\r\n\r\n    function checkOnlyContractOwner() internal constant returns(uint) {\r\n        if (contractOwner == msg.sender) {\r\n            return OK;\r\n        }\r\n\r\n        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Events History universal multi contract.\r\n *\r\n * Contract serves as an Events storage for any type of contracts.\r\n * Events appear on this contract address but their definitions provided by calling contracts.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n */\r\ncontract MultiEventsHistory is Object {\r\n    // Authorized calling contracts.\r\n    mapping(address => bool) public isAuthorized;\r\n\r\n    /**\r\n     * Authorize new caller contract.\r\n     *\r\n     * @param _caller address of the new caller.\r\n     *\r\n     * @return success.\r\n     */\r\n    function authorize(address _caller) onlyContractOwner() returns(bool) {\r\n        if (isAuthorized[_caller]) {\r\n            return false;\r\n        }\r\n        isAuthorized[_caller] = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Reject access.\r\n     *\r\n     * @param _caller address of the caller.\r\n     */\r\n    function reject(address _caller) onlyContractOwner() {\r\n        delete isAuthorized[_caller];\r\n    }\r\n\r\n    /**\r\n     * Event emitting fallback.\r\n     *\r\n     * Can be and only called by authorized caller.\r\n     * Delegate calls back with provided msg.data to emit an event.\r\n     *\r\n     * Throws if call failed.\r\n     */\r\n    function () {\r\n        if (!isAuthorized[msg.sender]) {\r\n            return;\r\n        }\r\n        // Internal Out Of Gas/Throw: revert this transaction too;\r\n        // Recursive Call: safe, all changes already made.\r\n        if (!msg.sender.delegatecall(msg.data)) {\r\n            throw;\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"reject\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":false,\"type\":\"fallback\"}]", "ContractName": "MultiEventsHistory", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://73ce4cc9ea35dce8a31e3d11711258a7da469520859f162279ec4dff834225a5"}]}