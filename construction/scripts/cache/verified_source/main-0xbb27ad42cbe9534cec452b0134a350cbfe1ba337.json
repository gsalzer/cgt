{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.25;\r\n\r\ncontract Sacrific3d {\r\n    \r\n    struct Stage {\r\n        uint8 numberOfPlayers;\r\n        uint256 blocknumber;\r\n        bool finalized;\r\n        mapping (uint8 => address) slotXplayer;\r\n        mapping (address => bool) players;\r\n    }\r\n    \r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n   \r\n    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\r\n    uint256 constant private P3D_SHARE = 0.125 ether;\r\n    \r\n    uint8 constant public MAX_PLAYERS_PER_STAGE = 5;\r\n    uint256 constant public OFFER_SIZE = 2.5 ether;\r\n    \r\n    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\r\n    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \r\n    uint256 public winningsPerRound = OFFER_SIZE + OFFER_SIZE / (MAX_PLAYERS_PER_STAGE - 1) - P3D_SHARE;\r\n    \r\n    mapping(address => uint256) private playerVault;\r\n    mapping(uint256 => Stage) private stages;\r\n    uint256 private numberOfFinalizedStages;\r\n    \r\n    uint256 public numberOfStages;\r\n    \r\n    event SacrificeOffered(address indexed player);\r\n    event SacrificeChosen(address indexed sarifice);\r\n    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\r\n    event StageInvalidated(uint256 indexed stage);\r\n    \r\n    modifier isValidOffer()\r\n    {\r\n        require(msg.value == OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier canPayFromVault()\r\n    {\r\n        require(playerVault[msg.sender] >= OFFER_SIZE);\r\n        _;\r\n    }\r\n    \r\n    modifier hasEarnings()\r\n    {\r\n        require(playerVault[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    modifier prepareStage()\r\n    {\r\n        //create a new stage if current has reached max amount of players\r\n        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n           stages[numberOfStages] = Stage(0, 0, false);\r\n           numberOfStages++;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier isNewToStage()\r\n    {\r\n        require(stages[numberOfStages - 1].players[msg.sender] == false);\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        stages[numberOfStages] = Stage(0, 0, false);\r\n        numberOfStages++;\r\n    }\r\n    \r\n    function() external payable {}\r\n    \r\n    function offerAsSacrifice()\r\n        external\r\n        payable\r\n        isValidOffer\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        acceptOffer();\r\n        \r\n        //try to choose a sacrifice in an already full stage (finalize a stage)\r\n        tryFinalizeStage();\r\n    }\r\n    \r\n    function offerAsSacrificeFromVault()\r\n        external\r\n        canPayFromVault\r\n        prepareStage\r\n        isNewToStage\r\n    {\r\n        playerVault[msg.sender] -= OFFER_SIZE;\r\n        \r\n        acceptOffer();\r\n        \r\n        tryFinalizeStage();\r\n    }\r\n    \r\n    function withdraw()\r\n        external\r\n        hasEarnings\r\n    {\r\n        tryFinalizeStage();\r\n        \r\n        uint256 amount = playerVault[msg.sender];\r\n        playerVault[msg.sender] = 0;\r\n        \r\n        emit EarningsWithdrawn(msg.sender, amount); \r\n        \r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function myEarnings()\r\n        external\r\n        view\r\n        hasEarnings\r\n        returns(uint256)\r\n    {\r\n        return playerVault[msg.sender];\r\n    }\r\n    \r\n    function currentPlayers()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return stages[numberOfStages - 1].numberOfPlayers;\r\n    }\r\n    \r\n    function acceptOffer()\r\n        private\r\n    {\r\n        Stage storage currentStage = stages[numberOfStages - 1];\r\n        \r\n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\r\n        \r\n        address player = msg.sender;\r\n        \r\n        //add player to current stage\r\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\r\n        currentStage.numberOfPlayers++;\r\n        currentStage.players[player] = true;\r\n        \r\n        emit SacrificeOffered(player);\r\n        \r\n        //add blocknumber to current stage when the last player is added\r\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\r\n            currentStage.blocknumber = block.number;\r\n        }\r\n    }\r\n    \r\n    function tryFinalizeStage()\r\n        public\r\n    {\r\n        assert(numberOfStages >= numberOfFinalizedStages);\r\n        \r\n        //there are no stages to finalize\r\n        if(numberOfStages == numberOfFinalizedStages) {return;}\r\n        \r\n        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\r\n        \r\n        assert(!stageToFinalize.finalized);\r\n        \r\n        //stage is not ready to be finalized\r\n        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\r\n        \r\n        assert(stageToFinalize.blocknumber != 0);\r\n        \r\n        //check if blockhash can be determined\r\n        if(block.number - 256 <= stageToFinalize.blocknumber) {\r\n            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\r\n            if(block.number == stageToFinalize.blocknumber) {return;}\r\n                \r\n            //determine sacrifice\r\n            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\r\n            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\r\n            \r\n            emit SacrificeChosen(sacrifice);\r\n            \r\n            //allocate winnings to survivors\r\n            allocateSurvivorWinnings(sacrifice);\r\n            \r\n            //allocate p3d dividends to sacrifice if existing\r\n            uint256 dividends = p3dContract.myDividends(true);\r\n            if(dividends > 0) {\r\n                p3dContract.withdraw();\r\n                playerVault[sacrifice]+= dividends;\r\n            }\r\n            \r\n            //purchase p3d (using ref)\r\n            p3dContract.buy.value(p3dPerStage)(address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\r\n        } else {\r\n            invalidateStage(numberOfFinalizedStages);\r\n            \r\n            emit StageInvalidated(numberOfFinalizedStages);\r\n        }\r\n        //finalize stage\r\n        stageToFinalize.finalized = true;\r\n        numberOfFinalizedStages++;\r\n    }\r\n    \r\n    function allocateSurvivorWinnings(address sacrifice)\r\n        private\r\n    {\r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\r\n            if(survivor != sacrifice) {\r\n                playerVault[survivor] += winningsPerRound;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function invalidateStage(uint256 stageIndex)\r\n        private\r\n    {\r\n        Stage storage stageToInvalidate = stages[stageIndex];\r\n        \r\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\r\n            address player = stageToInvalidate.slotXplayer[i];\r\n            playerVault[player] += OFFER_SIZE;\r\n        }\r\n    }\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"offerAsSacrificeFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OFFER_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"offerAsSacrifice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winningsPerRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tryFinalizeStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfStages\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PLAYERS_PER_STAGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"SacrificeOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sarifice\",\"type\":\"address\"}],\"name\":\"SacrificeChosen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EarningsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"StageInvalidated\",\"type\":\"event\"}]", "ContractName": "Sacrific3d", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://ece64d0a8dc0aa522c62e2e9ec4f629fda31b28871d073f336b22d37dffce90f"}]}