{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.24;\r\n//pragma experimental ABIEncoderV2;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/registry/BancorBuyer.sol\r\n\r\n//pragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\ncontract IMultiToken {\r\n    function changeableTokenCount() external view returns(uint16 count);\r\n    function tokens(uint256 i) public view returns(ERC20);\r\n    function weights(address t) public view returns(uint256);\r\n    function totalSupply() public view returns(uint256);\r\n    function mint(address _to, uint256 _amount) public;\r\n}\r\n\r\n\r\ncontract BancorBuyer {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public tokenBalances; // [owner][token]\r\n\r\n    function sumWeightOfMultiToken(IMultiToken mtkn) public view returns(uint256 sumWeight) {\r\n        for (uint i = mtkn.changeableTokenCount(); i > 0; i--) {\r\n            sumWeight += mtkn.weights(mtkn.tokens(i - 1));\r\n        }\r\n    }\r\n\r\n    function deposit(address _beneficiary, address[] _tokens, uint256[] _tokenValues) payable external {\r\n        if (msg.value > 0) {\r\n            balances[_beneficiary] = balances[_beneficiary].add(msg.value);\r\n        }\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            ERC20 token = ERC20(_tokens[i]);\r\n            uint256 tokenValue = _tokenValues[i];\r\n\r\n            uint256 balance = token.balanceOf(this);\r\n            token.transferFrom(msg.sender, this, tokenValue);\r\n            require(token.balanceOf(this) == balance.add(tokenValue));\r\n            tokenBalances[_beneficiary][token] = tokenBalances[_beneficiary][token].add(tokenValue);\r\n        }\r\n    }\r\n\r\n    function withdraw(address _to, uint256 _value, address[] _tokens, uint256[] _tokenValues) external {\r\n        if (_value > 0) {\r\n            _to.transfer(_value);\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        }\r\n\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            ERC20 token = ERC20(_tokens[i]);\r\n            uint256 tokenValue = _tokenValues[i];\r\n\r\n            uint256 tokenBalance = token.balanceOf(this);\r\n            token.transfer(_to, tokenValue);\r\n            require(token.balanceOf(this) == tokenBalance.sub(tokenValue));\r\n            tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenValue);\r\n        }\r\n    }\r\n\r\n    // function approveAndCall(address _to, uint256 _value, bytes _data, address[] _tokens, uint256[] _tokenValues) payable external {\r\n    //     uint256[] memory tempBalances = new uint256[](_tokens.length);\r\n    //     for (uint i = 0; i < _tokens.length; i++) {\r\n    //         ERC20 token = ERC20(_tokens[i]);\r\n    //         uint256 tokenValue = _tokenValues[i];\r\n\r\n    //         tempBalances[i] = token.balanceOf(this);\r\n    //         token.approve(_to, tokenValue);\r\n    //     }\r\n\r\n    //     require(_to.call.value(_value)(_data));\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value).sub(_value);\r\n\r\n    //     for (i = 0; i < _tokens.length; i++) {\r\n    //         token = ERC20(_tokens[i]);\r\n    //         tokenValue = _tokenValues[i];\r\n\r\n    //         uint256 tokenSpent = tempBalances[i].sub(token.balanceOf(this));\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(tokenSpent);\r\n    //         token.approve(_to, 0);\r\n    //     }\r\n    // }\r\n    \r\n    function buyOne(\r\n        ERC20 token,\r\n        address _exchange,\r\n        uint256 _value,\r\n        bytes _data\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        uint256 tokenBalance = token.balanceOf(this);\r\n        require(_exchange.call.value(_value)(_data));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token]\r\n            .add(token.balanceOf(this).sub(tokenBalance));\r\n    }\r\n    \r\n    function buy1(\r\n        address[] _tokens,\r\n        address[] _exchanges,\r\n        uint256[] _values,\r\n        bytes _data1\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);\r\n    }\r\n    \r\n    function buy2(\r\n        address[] _tokens,\r\n        address[] _exchanges,\r\n        uint256[] _values,\r\n        bytes _data1,\r\n        bytes _data2\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);\r\n        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);\r\n    }\r\n    \r\n    function buy3(\r\n        address[] _tokens,\r\n        address[] _exchanges,\r\n        uint256[] _values,\r\n        bytes _data1,\r\n        bytes _data2,\r\n        bytes _data3\r\n    ) \r\n        payable\r\n        public\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n        this.buyOne(ERC20(_tokens[0]), _exchanges[0], _values[0], _data1);\r\n        this.buyOne(ERC20(_tokens[1]), _exchanges[1], _values[1], _data2);\r\n        this.buyOne(ERC20(_tokens[2]), _exchanges[2], _values[2], _data3);\r\n    }\r\n    \r\n    // function buyMany(\r\n    //     address[] _tokens,\r\n    //     address[] _exchanges,\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    //     for (uint i = 0; i < _tokens.length; i++) {\r\n    //         this.buyOne(ERC20(_tokens[i]), _exchanges[i], _values[i], _datas[i]);\r\n    //     }\r\n    // }\r\n\r\n    // function buy(\r\n    //     IMultiToken _mtkn, // may be 0\r\n    //     address[] _exchanges, // may have 0\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     require(_mtkn.changeableTokenCount() == _exchanges.length, \"\");\r\n\r\n    //     balances[msg.sender] = balances[msg.sender].add(msg.value);\r\n    //     for (uint i = 0; i < _exchanges.length; i++) {\r\n    //         if (_exchanges[i] == 0) {\r\n    //             continue;\r\n    //         }\r\n\r\n    //         ERC20 token = _mtkn.tokens(i);\r\n            \r\n    //         // ETH => XXX\r\n    //         uint256 tokenBalance = token.balanceOf(this);\r\n    //         require(_exchanges[i].call.value(_values[i])(_datas[i]));\r\n    //         balances[msg.sender] = balances[msg.sender].sub(_values[i]);\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));\r\n    //     }\r\n    // }\r\n\r\n    // function buyAndMint(\r\n    //     IMultiToken _mtkn, // may be 0\r\n    //     uint256 _minAmount,\r\n    //     address[] _exchanges, // may have 0\r\n    //     uint256[] _values,\r\n    //     bytes[] _datas\r\n    // ) \r\n    //     payable\r\n    //     public\r\n    // {\r\n    //     buy(_mtkn, _exchanges, _values, _datas);\r\n\r\n    //     uint256 totalSupply = _mtkn.totalSupply();\r\n    //     uint256 bestAmount = uint256(-1);\r\n    //     for (uint i = 0; i < _exchanges.length; i++) {\r\n    //         ERC20 token = _mtkn.tokens(i);\r\n\r\n    //         // Approve XXX to mtkn\r\n    //         uint256 thisTokenBalance = tokenBalances[msg.sender][token];\r\n    //         uint256 mtknTokenBalance = token.balanceOf(_mtkn);\r\n    //         _values[i] = token.balanceOf(this);\r\n    //         token.approve(_mtkn, thisTokenBalance);\r\n            \r\n    //         uint256 amount = totalSupply.mul(thisTokenBalance).div(mtknTokenBalance);\r\n    //         if (amount < bestAmount) {\r\n    //             bestAmount = amount;\r\n    //         }\r\n    //     }\r\n\r\n    //     require(bestAmount >= _minAmount);\r\n    //     _mtkn.mint(msg.sender, bestAmount);\r\n\r\n    //     for (i = 0; i < _exchanges.length; i++) {\r\n    //         token = _mtkn.tokens(i);\r\n    //         token.approve(_mtkn, 0);\r\n    //         tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].sub(token.balanceOf(this).sub(_values[i]));\r\n    //     }\r\n    // }\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_exchanges\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data1\",\"type\":\"bytes\"},{\"name\":\"_data2\",\"type\":\"bytes\"},{\"name\":\"_data3\",\"type\":\"bytes\"}],\"name\":\"buy3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"buyOne\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_tokenValues\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_exchanges\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data1\",\"type\":\"bytes\"}],\"name\":\"buy1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_exchanges\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_data1\",\"type\":\"bytes\"},{\"name\":\"_data2\",\"type\":\"bytes\"}],\"name\":\"buy2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"mtkn\",\"type\":\"address\"}],\"name\":\"sumWeightOfMultiToken\",\"outputs\":[{\"name\":\"sumWeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"address[]\"},{\"name\":\"_tokenValues\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BancorBuyer", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://b0a9a5091cfe3b437ea4d0141e282d8e55f3c8d4170ffc822376a2903211e3b3"}]}