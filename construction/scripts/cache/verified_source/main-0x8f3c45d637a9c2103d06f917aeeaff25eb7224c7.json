{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n// ------------------------------------------------------------------------\r\n// TokenTraderFactory\r\n//\r\n// Decentralised trustless ERC20-compliant token to ETH exchange contract\r\n// on the Ethereum blockchain.\r\n//\r\n// Note that this TokenTrader cannot be used with the Golem Network Token\r\n// directly as the token does not implement the ERC20\r\n// transferFrom(...), approve(...) and allowance(...) methods\r\n//\r\n// History:\r\n//   Jan 25 2017 - BPB Added makerTransferAsset(...) and\r\n//                     makerTransferEther(...)\r\n//   Feb 05 2017 - BPB Bug fix in the change calculation for the Unicorn\r\n//                     token with natural number 1\r\n//   Feb 08 2017 - BPB/JL Renamed etherValueOfTokensToSell to\r\n//                     amountOfTokensToSell in takerSellAsset(...) to\r\n//                     better describe the parameter\r\n//                     Added check in createTradeContract(...) to prevent\r\n//                     GNTs from being used with this contract. The asset\r\n//                     token will need to have an allowance(...) function.\r\n//\r\n// Enjoy. (c) JonnyLatte & BokkyPooBah 2017. The MIT licence.\r\n// ------------------------------------------------------------------------\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint totalSupply);\r\n    function balanceOf(address _owner) constant returns (uint balance);\r\n    function transfer(address _to, uint _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrTokenTraderWithSameOwner {\r\n        if (msg.sender != owner && TokenTrader(msg.sender).owner() != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// contract can buy or sell tokens for ETH\r\n// prices are in amount of wei per batch of token units\r\n\r\ncontract TokenTrader is Owned {\r\n\r\n    address public asset;       // address of token\r\n    uint256 public buyPrice;    // contract buys lots of token at this price\r\n    uint256 public sellPrice;   // contract sells lots at this price\r\n    uint256 public units;       // lot size (token-wei)\r\n\r\n    bool public buysTokens;     // is contract buying\r\n    bool public sellsTokens;    // is contract selling\r\n\r\n    event ActivatedEvent(bool buys, bool sells);\r\n    event MakerDepositedEther(uint256 amount);\r\n    event MakerWithdrewAsset(uint256 tokens);\r\n    event MakerTransferredAsset(address toTokenTrader, uint256 tokens);\r\n    event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens);\r\n    event MakerWithdrewEther(uint256 ethers);\r\n    event MakerTransferredEther(address toTokenTrader, uint256 ethers);\r\n    event TakerBoughtAsset(address indexed buyer, uint256 ethersSent,\r\n        uint256 ethersReturned, uint256 tokensBought);\r\n    event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell,\r\n        uint256 tokensSold, uint256 etherValueOfTokensSold);\r\n\r\n    // Constructor - only to be called by the TokenTraderFactory contract\r\n    function TokenTrader (\r\n        address _asset,\r\n        uint256 _buyPrice,\r\n        uint256 _sellPrice,\r\n        uint256 _units,\r\n        bool    _buysTokens,\r\n        bool    _sellsTokens\r\n    ) {\r\n        asset       = _asset;\r\n        buyPrice    = _buyPrice;\r\n        sellPrice   = _sellPrice;\r\n        units       = _units;\r\n        buysTokens  = _buysTokens;\r\n        sellsTokens = _sellsTokens;\r\n        ActivatedEvent(buysTokens, sellsTokens);\r\n    }\r\n\r\n    // Maker can activate or deactivate this contract's buying and\r\n    // selling status\r\n    //\r\n    // The ActivatedEvent() event is logged with the following\r\n    // parameter:\r\n    //   buysTokens   this contract can buy asset tokens\r\n    //   sellsTokens  this contract can sell asset tokens\r\n    //\r\n    function activate (\r\n        bool _buysTokens,\r\n        bool _sellsTokens\r\n    ) onlyOwner {\r\n        buysTokens  = _buysTokens;\r\n        sellsTokens = _sellsTokens;\r\n        ActivatedEvent(buysTokens, sellsTokens);\r\n    }\r\n\r\n    // Maker can deposit ethers to this contract so this contract\r\n    // can buy asset tokens.\r\n    //\r\n    // Maker deposits asset tokens to this contract by calling the\r\n    // asset's transfer() method with the following parameters\r\n    //   _to     is the address of THIS contract\r\n    //   _value  is the number of asset tokens to be transferred\r\n    //\r\n    // Taker MUST NOT send tokens directly to this contract. Takers\r\n    // MUST use the takerSellAsset() method to sell asset tokens\r\n    // to this contract\r\n    //\r\n    // Maker can also transfer ethers from one TokenTrader contract\r\n    // to another TokenTrader contract, both owned by the Maker\r\n    //\r\n    // The MakerDepositedEther() event is logged with the following\r\n    // parameter:\r\n    //   ethers  is the number of ethers deposited by the maker\r\n    //\r\n    // This method was called deposit() in the old version\r\n    //\r\n    function makerDepositEther() payable onlyOwnerOrTokenTraderWithSameOwner {\r\n        MakerDepositedEther(msg.value);\r\n    }\r\n\r\n    // Maker can withdraw asset tokens from this contract, with the\r\n    // following parameter:\r\n    //   tokens  is the number of asset tokens to be withdrawn\r\n    //\r\n    // The MakerWithdrewAsset() event is logged with the following\r\n    // parameter:\r\n    //   tokens  is the number of tokens withdrawn by the maker\r\n    //\r\n    // This method was called withdrawAsset() in the old version\r\n    //\r\n    function makerWithdrawAsset(uint256 tokens) onlyOwner returns (bool ok) {\r\n        MakerWithdrewAsset(tokens);\r\n        return ERC20(asset).transfer(owner, tokens);\r\n    }\r\n\r\n    // Maker can transfer asset tokens from this contract to another\r\n    // TokenTrader contract, with the following parameter:\r\n    //   toTokenTrader  Another TokenTrader contract owned by the\r\n    //                  same owner and with the same asset\r\n    //   tokens         is the number of asset tokens to be moved\r\n    //\r\n    // The MakerTransferredAsset() event is logged with the following\r\n    // parameters:\r\n    //   toTokenTrader  The other TokenTrader contract owned by\r\n    //                  the same owner and with the same asset\r\n    //   tokens         is the number of tokens transferred\r\n    //\r\n    // The asset Transfer() event is also logged from this contract\r\n    // to the other contract\r\n    //\r\n    function makerTransferAsset(\r\n        TokenTrader toTokenTrader,\r\n        uint256 tokens\r\n    ) onlyOwner returns (bool ok) {\r\n        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\r\n            throw;\r\n        }\r\n        MakerTransferredAsset(toTokenTrader, tokens);\r\n        return ERC20(asset).transfer(toTokenTrader, tokens);\r\n    }\r\n\r\n    // Maker can withdraw any ERC20 asset tokens from this contract\r\n    //\r\n    // This method is included in the case where this contract receives\r\n    // the wrong tokens\r\n    //\r\n    // The MakerWithdrewERC20Token() event is logged with the following\r\n    // parameter:\r\n    //   tokenAddress  is the address of the tokens withdrawn by the maker\r\n    //   tokens        is the number of tokens withdrawn by the maker\r\n    //\r\n    // This method was called withdrawToken() in the old version\r\n    //\r\n    function makerWithdrawERC20Token(\r\n        address tokenAddress,\r\n        uint256 tokens\r\n    ) onlyOwner returns (bool ok) {\r\n        MakerWithdrewERC20Token(tokenAddress, tokens);\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // Maker can withdraw ethers from this contract\r\n    //\r\n    // The MakerWithdrewEther() event is logged with the following parameter\r\n    //   ethers  is the number of ethers withdrawn by the maker\r\n    //\r\n    // This method was called withdraw() in the old version\r\n    //\r\n    function makerWithdrawEther(uint256 ethers) onlyOwner returns (bool ok) {\r\n        if (this.balance >= ethers) {\r\n            MakerWithdrewEther(ethers);\r\n            return owner.send(ethers);\r\n        }\r\n    }\r\n\r\n    // Maker can transfer ethers from this contract to another TokenTrader\r\n    // contract, with the following parameters:\r\n    //   toTokenTrader  Another TokenTrader contract owned by the\r\n    //                  same owner and with the same asset\r\n    //   ethers         is the number of ethers to be moved\r\n    //\r\n    // The MakerTransferredEther() event is logged with the following parameter\r\n    //   toTokenTrader  The other TokenTrader contract owned by the\r\n    //                  same owner and with the same asset\r\n    //   ethers         is the number of ethers transferred\r\n    //\r\n    // The MakerDepositedEther() event is logged on the other\r\n    // contract with the following parameter:\r\n    //   ethers  is the number of ethers deposited by the maker\r\n    //\r\n    function makerTransferEther(\r\n        TokenTrader toTokenTrader,\r\n        uint256 ethers\r\n    ) onlyOwner returns (bool ok) {\r\n        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\r\n            throw;\r\n        }\r\n        if (this.balance >= ethers) {\r\n            MakerTransferredEther(toTokenTrader, ethers);\r\n            toTokenTrader.makerDepositEther.value(ethers)();\r\n        }\r\n    }\r\n\r\n    // Taker buys asset tokens by sending ethers\r\n    //\r\n    // The TakerBoughtAsset() event is logged with the following parameters\r\n    //   buyer           is the buyer's address\r\n    //   ethersSent      is the number of ethers sent by the buyer\r\n    //   ethersReturned  is the number of ethers sent back to the buyer as\r\n    //                   change\r\n    //   tokensBought    is the number of asset tokens sent to the buyer\r\n    //\r\n    // This method was called buy() in the old version\r\n    //\r\n    function takerBuyAsset() payable {\r\n        if (sellsTokens || msg.sender == owner) {\r\n            // Note that sellPrice has already been validated as > 0\r\n            uint order    = msg.value / sellPrice;\r\n            // Note that units has already been validated as > 0\r\n            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;\r\n            uint256 change = 0;\r\n            if (msg.value > (can_sell * sellPrice)) {\r\n                change  = msg.value - (can_sell * sellPrice);\r\n                order = can_sell;\r\n            }\r\n            if (change > 0) {\r\n                if (!msg.sender.send(change)) throw;\r\n            }\r\n            if (order > 0) {\r\n                if (!ERC20(asset).transfer(msg.sender, order * units)) throw;\r\n            }\r\n            TakerBoughtAsset(msg.sender, msg.value, change, order * units);\r\n        }\r\n        // Return user funds if the contract is not selling\r\n        else if (!msg.sender.send(msg.value)) throw;\r\n    }\r\n\r\n    // Taker sells asset tokens for ethers by:\r\n    // 1. Calling the asset's approve() method with the following parameters\r\n    //    _spender            is the address of this contract\r\n    //    _value              is the number of tokens to be sold\r\n    // 2. Calling this takerSellAsset() method with the following parameter\r\n    //    etherValueOfTokens  is the ether value of the asset tokens to be sold\r\n    //                        by the taker\r\n    //\r\n    // The TakerSoldAsset() event is logged with the following parameters\r\n    //   seller                  is the seller's address\r\n    //   amountOfTokensToSell    is the amount of the asset tokens being\r\n    //                           sold by the taker\r\n    //   tokensSold              is the number of the asset tokens sold\r\n    //   etherValueOfTokensSold  is the ether value of the asset tokens sold\r\n    //\r\n    // This method was called sell() in the old version\r\n    //\r\n    function takerSellAsset(uint256 amountOfTokensToSell) {\r\n        if (buysTokens || msg.sender == owner) {\r\n            // Maximum number of token the contract can buy\r\n            // Note that buyPrice has already been validated as > 0\r\n            uint256 can_buy = this.balance / buyPrice;\r\n            // Token lots available\r\n            // Note that units has already been validated as > 0\r\n            uint256 order = amountOfTokensToSell / units;\r\n            // Adjust order for funds available\r\n            if (order > can_buy) order = can_buy;\r\n            if (order > 0) {\r\n                // Extract user tokens\r\n                if (!ERC20(asset).transferFrom(msg.sender, address(this), order * units)) throw;\r\n                // Pay user\r\n                if (!msg.sender.send(order * buyPrice)) throw;\r\n            }\r\n            TakerSoldAsset(msg.sender, amountOfTokensToSell, order * units, order * buyPrice);\r\n        }\r\n    }\r\n\r\n    // Taker buys tokens by sending ethers\r\n    function () payable {\r\n        takerBuyAsset();\r\n    }\r\n}\r\n\r\n// This contract deploys TokenTrader contracts and logs the event\r\ncontract TokenTraderFactory is Owned {\r\n\r\n    event TradeListing(address indexed ownerAddress, address indexed tokenTraderAddress,\r\n        address indexed asset, uint256 buyPrice, uint256 sellPrice, uint256 units,\r\n        bool buysTokens, bool sellsTokens);\r\n    event OwnerWithdrewERC20Token(address indexed tokenAddress, uint256 tokens);\r\n\r\n    mapping(address => bool) _verify;\r\n\r\n    // Anyone can call this method to verify the settings of a\r\n    // TokenTrader contract. The parameters are:\r\n    //   tradeContract  is the address of a TokenTrader contract\r\n    //\r\n    // Return values:\r\n    //   valid        did this TokenTraderFactory create the TokenTrader contract?\r\n    //   owner        is the owner of the TokenTrader contract\r\n    //   asset        is the ERC20 asset address\r\n    //   buyPrice     is the buy price in ethers per `units` of asset tokens\r\n    //   sellPrice    is the sell price in ethers per `units` of asset tokens\r\n    //   units        is the number of units of asset tokens\r\n    //   buysTokens   is the TokenTrader contract buying tokens?\r\n    //   sellsTokens  is the TokenTrader contract selling tokens?\r\n    //\r\n    function verify(address tradeContract) constant returns (\r\n        bool    valid,\r\n        address owner,\r\n        address asset,\r\n        uint256 buyPrice,\r\n        uint256 sellPrice,\r\n        uint256 units,\r\n        bool    buysTokens,\r\n        bool    sellsTokens\r\n    ) {\r\n        valid = _verify[tradeContract];\r\n        if (valid) {\r\n            TokenTrader t = TokenTrader(tradeContract);\r\n            owner         = t.owner();\r\n            asset         = t.asset();\r\n            buyPrice      = t.buyPrice();\r\n            sellPrice     = t.sellPrice();\r\n            units         = t.units();\r\n            buysTokens    = t.buysTokens();\r\n            sellsTokens   = t.sellsTokens();\r\n        }\r\n    }\r\n\r\n    // Maker can call this method to create a new TokenTrader contract\r\n    // with the maker being the owner of this new contract\r\n    //\r\n    // Parameters:\r\n    //   asset        is the ERC20 asset address\r\n    //   buyPrice     is the buy price in ethers per `units` of asset tokens\r\n    //   sellPrice    is the sell price in ethers per `units` of asset tokens\r\n    //   units        is the number of units of asset tokens\r\n    //   buysTokens   is the TokenTrader contract buying tokens?\r\n    //   sellsTokens  is the TokenTrader contract selling tokens?\r\n    //\r\n    // For example, listing a TokenTrader contract on the REP Augur token where\r\n    // the contract will buy REP tokens at a rate of 39000/100000 = 0.39 ETH\r\n    // per REP token and sell REP tokens at a rate of 41000/100000 = 0.41 ETH\r\n    // per REP token:\r\n    //   asset        0x48c80f1f4d53d5951e5d5438b54cba84f29f32a5\r\n    //   buyPrice     39000\r\n    //   sellPrice    41000\r\n    //   units        100000\r\n    //   buysTokens   true\r\n    //   sellsTokens  true\r\n    //\r\n    // The TradeListing() event is logged with the following parameters\r\n    //   ownerAddress        is the Maker's address\r\n    //   tokenTraderAddress  is the address of the newly created TokenTrader contract\r\n    //   asset               is the ERC20 asset address\r\n    //   buyPrice            is the buy price in ethers per `units` of asset tokens\r\n    //   sellPrice           is the sell price in ethers per `units` of asset tokens\r\n    //   unit                is the number of units of asset tokens\r\n    //   buysTokens          is the TokenTrader contract buying tokens?\r\n    //   sellsTokens         is the TokenTrader contract selling tokens?\r\n    //\r\n    function createTradeContract(\r\n        address asset,\r\n        uint256 buyPrice,\r\n        uint256 sellPrice,\r\n        uint256 units,\r\n        bool    buysTokens,\r\n        bool    sellsTokens\r\n    ) returns (address trader) {\r\n        // Cannot have invalid asset\r\n        if (asset == 0x0) throw;\r\n        // Check for ERC20 allowance function\r\n        // This will throw an error if the allowance function\r\n        // is undefined to prevent GNTs from being used\r\n        // with this factory\r\n        uint256 allowance = ERC20(asset).allowance(msg.sender, this);\r\n        // Cannot set zero or negative price\r\n        if (buyPrice <= 0 || sellPrice <= 0) throw;\r\n        // Must make profit on spread\r\n        if (buyPrice >= sellPrice) throw;\r\n        // Cannot buy or sell zero or negative units\r\n        if (units <= 0) throw;\r\n\r\n        trader = new TokenTrader(\r\n            asset,\r\n            buyPrice,\r\n            sellPrice,\r\n            units,\r\n            buysTokens,\r\n            sellsTokens);\r\n        // Record that this factory created the trader\r\n        _verify[trader] = true;\r\n        // Set the owner to whoever called the function\r\n        TokenTrader(trader).transferOwnership(msg.sender);\r\n        TradeListing(msg.sender, trader, asset, buyPrice, sellPrice, units, buysTokens, sellsTokens);\r\n    }\r\n\r\n    // Factory owner can withdraw any ERC20 asset tokens from this contract\r\n    //\r\n    // This method is included in the case where this contract receives\r\n    // the wrong tokens\r\n    //\r\n    // The OwnerWithdrewERC20Token() event is logged with the following\r\n    // parameter:\r\n    //   tokenAddress  is the address of the tokens withdrawn by the maker\r\n    //   tokens        is the number of tokens withdrawn by the maker\r\n    //\r\n    function ownerWithdrawERC20Token(address tokenAddress, uint256 tokens) onlyOwner returns (bool ok) {\r\n        OwnerWithdrewERC20Token(tokenAddress, tokens);\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // Prevents accidental sending of ether to the factory\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract FixedSupplyToken is ERC20 {\r\n    string public name;\r\n    string public symbol;\r\n    uint256 _totalSupply;\r\n    uint8 public decimals;\r\n\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n\r\n    // Owner of account approves the transfer of an amount to another account\r\n    mapping(address => mapping (address => uint256)) allowed;\r\n\r\n    // Constructor\r\n    function FixedSupplyToken(\r\n      string _name,\r\n      string _symbol,\r\n      uint256 _supply,\r\n      uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        _totalSupply = _supply;\r\n        decimals = _decimals;\r\n        balances[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 totalSupply) {\r\n        totalSupply = _totalSupply;\r\n    }\r\n\r\n    // What is the balance of a particular account?\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    // Transfer the balance from owner's account to another account\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (balances[msg.sender] >= _amount\r\n            && _amount > 0\r\n            && balances[_to] + _amount > balances[_to]) {\r\n            balances[msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(msg.sender, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n    // fees in sub-currencies; the command should fail unless the _from account has\r\n    // deliberately authorized the sender of the message via some mechanism; we propose\r\n    // these standardized APIs for approval:\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) returns (bool success) {\r\n        if (balances[_from] >= _amount\r\n            && allowed[_from][msg.sender] >= _amount\r\n            && _amount > 0\r\n            && balances[_to] + _amount > balances[_to]) {\r\n            balances[_from] -= _amount;\r\n            allowed[_from][msg.sender] -= _amount;\r\n            balances[_to] += _amount;\r\n            Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract TokenToken is FixedSupplyToken{\r\n  TokenTrader[] public tokenExchanges;\r\n  uint256[] public tokenRatios; // Measured in per 1e18, e.g.g 5e17 = 50%\r\n                                // TokenRatios MUST ADD TO 1 (1e18)\r\n  uint256 tokensBought = 0;\r\n\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n  /* This generates a public event on the blockchain that will notify clients */\r\n  //event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /* Initializes contract with initial supply tokens to the creator of the contract */\r\n\r\n  function TokenToken(\r\n    string _name,\r\n    string _symbol,\r\n    uint256 _supply,\r\n    uint8 _decimals,\r\n    TokenTrader[] initialTokenExchanges,\r\n    uint256[] initialTokenRatios\r\n    ) FixedSupplyToken(\r\n      _name,\r\n      _symbol,\r\n      _supply,\r\n      _decimals\r\n    ) {\r\n    tokenExchanges = initialTokenExchanges;\r\n    tokenRatios = initialTokenRatios;\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n      if (msg.sender != owner) throw;\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n      OwnershipTransferred(owner, newOwner);\r\n      owner = newOwner;\r\n  }\r\n\r\n  function setPurchaseRatios (\r\n    TokenTrader[] newTokenExchanges,\r\n    uint256[] newTokenRatios\r\n  ) onlyOwner returns (bool success) {\r\n      // Should have a lot of assertions\r\n      // TODO: Assert newTokenRatios.length == tokenRatios.length\r\n      // TODO: Assert newTokenRatios add to 1\r\n      tokenExchanges = newTokenExchanges;\r\n      tokenRatios = newTokenRatios;\r\n      return true;\r\n  }\r\n\r\n  function buyPrice() constant returns (uint256 totalPrice) {\r\n    totalPrice = 0;\r\n    for (uint i = 0; i < tokenExchanges.length; ++i) {\r\n      totalPrice += tokenExchanges[i].buyPrice() * tokenRatios[i] / 1e18;\r\n    }\r\n    return totalPrice;\r\n  }\r\n\r\n  function sellPrice() constant returns (uint256 totalPrice) {\r\n    totalPrice = 0;\r\n    for (uint i = 0; i < tokenExchanges.length; ++i) {\r\n      totalPrice += tokenExchanges[i].sellPrice() * tokenRatios[i] / 1e18;\r\n    }\r\n    return totalPrice;\r\n  }\r\n\r\n  function () { // Sending ether to it buys coins automatically\r\n    buy();\r\n  }\r\n  function buy() payable returns (uint256 amount){        // Buy in ETH\r\n\r\n    amount = msg.value / buyPrice();\r\n    for (uint i = 0; i < tokenExchanges.length; ++i) {\r\n      TokenTrader tokenExchange = tokenExchanges[i];\r\n      tokenExchange.transfer(msg.value * tokenRatios[i] / 1e18);\r\n    }\r\n    tokensBought += amount;\r\n    balances[msg.sender] += amount;                   // adds the amount to buyer's balance\r\n    balances[this] -= amount;                         // subtracts amount from seller's balance\r\n    Transfer(this, msg.sender, amount);                // execute an event reflecting the change\r\n    return amount;                                     // ends function and returns\r\n  }\r\n\r\n  function sell(uint amount) returns (uint256 revenue){   // Sell in tokens\r\n    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\r\n    balances[this] += amount;                         // adds the amount to owner's balance\r\n    balances[msg.sender] -= amount;                   // subtracts the amount from seller's balance\r\n\r\n    uint256 subTokensToSell = 0;\r\n    revenue = 0;\r\n    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\r\n      TokenTrader tokenExchange = tokenExchanges[i];\r\n      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\r\n\r\n      revenue += subTokensToSell * tokenExchange.sellPrice();\r\n      ERC20(tokenExchange.asset()).approve(address(tokenExchange), subTokensToSell); // Approve sale\r\n      tokenExchange.takerSellAsset(subTokensToSell); // Make Sale\r\n    }\r\n\r\n    tokensBought -= amount;\r\n    msg.sender.transfer(revenue);\r\n    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n    return revenue;                                // ends function and returns\r\n  }\r\n\r\n  function breakdown(uint256 amount) {   // Breakdown in tokens\r\n    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\r\n    balances[this] += amount;                         // adds the amount to owner's balance\r\n    balances[msg.sender] -= amount;                   // subtracts the amount from seller's balance\r\n\r\n    uint256 subTokensToSell = 0;\r\n    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\r\n      TokenTrader tokenExchange = tokenExchanges[i];\r\n      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\r\n      ERC20(tokenExchange.asset()).transfer(msg.sender, subTokensToSell);\r\n    }\r\n\r\n    tokensBought -= amount;\r\n    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\r\n  }\r\n\r\n  function rebalance(TokenTrader fromExchange, TokenTrader toExchange, uint256 fromPercent) onlyOwner {\r\n    uint256 subTokensToSell = ERC20(fromExchange.asset()).balanceOf(this) * fromPercent / 1e18;\r\n\r\n    uint256 revenue = subTokensToSell * fromExchange.sellPrice();\r\n    ERC20(fromExchange.asset()).approve(address(fromExchange), subTokensToSell); // Approve sale\r\n    fromExchange.takerSellAsset(subTokensToSell); // Make sale\r\n\r\n    toExchange.transfer(revenue); // Make purchase with new contract.\r\n  }\r\n\r\n  function kill() { if (msg.sender == owner) selfdestruct(owner); }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenExchanges\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromExchange\",\"type\":\"address\"},{\"name\":\"toExchange\",\"type\":\"address\"},{\"name\":\"fromPercent\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenExchanges\",\"type\":\"address[]\"},{\"name\":\"newTokenRatios\",\"type\":\"uint256[]\"}],\"name\":\"setPurchaseRatios\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"breakdown\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenRatios\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"initialTokenExchanges\",\"type\":\"address[]\"},{\"name\":\"initialTokenRatios\",\"type\":\"uint256[]\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "TokenToken", "CompilerVersion": "v0.4.11+commit.68ef5810", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000001b4944454f20436f4c616220546f6b656e2046756e6420546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000003435446000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000004492e0bbed736730fabecd51be91587080464226000000000000000000000000d0f7e41d49e56ed1bd5e1b8249cdd70748c3ca47000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000006f05b59d3b20000", "Library": "", "SwarmSource": "bzzr://3253a9b89b0fd1bfa17f84cc514f1cd6b49ae9fcbac86cc893a6717924cd238a"}]}