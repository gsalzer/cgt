{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n/**\r\n *\r\n * ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n * Web              - https://winethfree.com\r\n * Twitter          - https://twitter.com/winethfree\r\n * Telegram_channel - https://t.me/winethfree\r\n * Telegram_group   - https://t.me/wef_group\r\n *\r\n * __          ___         ______ _______ _    _   ______\r\n * \\ \\        / (_)       |  ____|__   __| |  | | |  ____|\r\n *  \\ \\  /\\  / / _ _ __   | |__     | |  | |__| | | |__ _ __ ___  ___\r\n *   \\ \\/  \\/ / | | '_ \\  |  __|    | |  |  __  | |  __| '__/ _ \\/ _ \\\r\n *    \\  /\\  /  | | | | | | |____   | |  | |  | | | |  | | |  __/  __/\r\n *     \\/  \\/   |_|_| |_| |______|  |_|  |_|  |_| |_|  |_|  \\___|\\___|\r\n */\r\n\r\ncontract WinEthFree{\r\n\r\n    // investor gets 2% interest per day to return.\r\n    struct Investor {\r\n        uint waveNum;      // wave Num\r\n        uint investment;    // investment gets 2% interest per day\r\n        uint payableInterest;  // payable interest until last pay time\r\n        uint paidInterest;   // interest already paid\r\n        uint payTime;\r\n    }\r\n\r\n    // Lottery ticket number from beginNum to endNum.\r\n    struct LotteryTicket {\r\n        address player;\r\n        uint beginNum;\r\n        uint endNum;\r\n        bool conservative; // winner would not return interest for conservative wager.\r\n    }\r\n\r\n    enum WagerType { Conservative, Aggressive, Interest }\r\n\r\n    Leverage private leverage;\r\n\r\n    modifier onlyLeverage() {\r\n        require(msg.sender == address(leverage), \"access denied\");\r\n        _;\r\n    }\r\n\r\n    event LogNextWave();\r\n    event LogNextBet();\r\n    event LogWithdrawInterest(address, uint);\r\n    event LogInvestChange(address, uint, uint, uint);\r\n    event LogBet(WagerType, address, uint, uint, uint, uint);\r\n    event LogPayWinnerPrize(address, uint, uint);\r\n\r\n    address private admin;\r\n    uint private constant commissionPercent = 10;\r\n\r\n    uint private constant ratePercent = 2;\r\n    uint private constant ratePeriod = 24 hours;\r\n    uint private constant minInvestment = 10 finney;  //       0.01 ETH\r\n\r\n    uint private constant leverageMultiple = 10;\r\n    uint private constant minInterestWager = minInvestment / leverageMultiple;\r\n    uint private constant prize1st = 1 ether;\r\n    uint private constant prize2nd = 20 finney;\r\n    uint private constant winnerNum = 11;\r\n    uint private constant minPrizePool = prize1st + prize2nd * (winnerNum - 1);   // 1 + 0.02 * 10 ETH\r\n    uint private constant prizePercent = 50;\r\n\r\n    uint private waveNum;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    uint private activeTicketSlotSum;\r\n    LotteryTicket[] private lotteryTickets;\r\n    uint private ticketSum;\r\n    uint private prizePool;\r\n    uint private roundStartup;\r\n\r\n    function isInvestor(address addr) private view returns (bool) {\r\n        return investors[addr].waveNum == waveNum;\r\n    }\r\n\r\n    function resetInvestor(address addr) private {\r\n        investors[addr].waveNum--;\r\n    }\r\n\r\n    function calcInterest(address addr) private returns (uint) {\r\n\r\n        if (!isInvestor(addr)) {\r\n            return 0;\r\n        }\r\n\r\n        uint investment = investors[addr].investment;\r\n        uint paidInterest = investors[addr].paidInterest;\r\n\r\n        if (investment <= paidInterest) {\r\n            // investment decreases when player wins prize, could be less than paid interest.\r\n            resetInvestor(addr);\r\n\r\n            emit LogInvestChange(addr, 0, 0, 0);\r\n\r\n            return 0;\r\n        }\r\n\r\n        uint payableInterest = investors[addr].payableInterest;\r\n        uint payTime = investors[addr].payTime;\r\n\r\n        uint interest = investment * ratePercent / 100 * (now - payTime) / ratePeriod;\r\n        interest += payableInterest;\r\n\r\n        uint restInterest = investment - paidInterest;\r\n\r\n        if (interest > restInterest) {\r\n            interest = restInterest;\r\n        }\r\n\r\n        return interest;\r\n    }\r\n\r\n    function takeInterest(address addr) private returns(uint) {\r\n        uint interest = calcInterest(addr);\r\n\r\n        if (interest < minInterestWager) {\r\n            return 0;\r\n        }\r\n\r\n        // round down to FINNEY\r\n        uint interestRoundDown = uint(interest / minInterestWager) * minInterestWager;\r\n\r\n        investors[addr].payableInterest = interest - interestRoundDown;\r\n        investors[addr].paidInterest += interestRoundDown;\r\n        investors[addr].payTime = now;\r\n\r\n        emit LogInvestChange(\r\n            addr, investors[addr].payableInterest,\r\n            investors[addr].paidInterest, investors[addr].investment\r\n            );\r\n\r\n        return interestRoundDown;\r\n    }\r\n\r\n    function withdrawInterest(address addr) private {\r\n        uint interest = takeInterest(addr);\r\n\r\n        if (interest == 0) {\r\n            return;\r\n        }\r\n\r\n        uint balance = address(this).balance - prizePool;\r\n        bool outOfBalance;\r\n\r\n        if (balance <= interest) {\r\n            outOfBalance = true;\r\n            interest = balance;\r\n        }\r\n\r\n        addr.transfer(interest);\r\n\r\n        emit LogWithdrawInterest(addr, interest);\r\n\r\n        if (outOfBalance) {\r\n            nextWave();\r\n        }\r\n    }\r\n\r\n    // new investment or add more investment\r\n    function doInvest(address addr, uint value) private {\r\n\r\n        uint interest = calcInterest(addr);\r\n\r\n        if (interest > 0) {\r\n            // update payable Interest from last pay time.\r\n            investors[addr].payableInterest = interest;\r\n        }\r\n\r\n        if (isInvestor(addr)) {\r\n            // add more investment\r\n            investors[addr].investment += value;\r\n            investors[addr].payTime = now;\r\n        } else {\r\n            // new investment\r\n            investors[addr].waveNum = waveNum;\r\n            investors[addr].investment = value;\r\n            investors[addr].payableInterest = 0;\r\n            investors[addr].paidInterest = 0;\r\n            investors[addr].payTime = now;\r\n        }\r\n\r\n        emit LogInvestChange(\r\n            addr, investors[addr].payableInterest,\r\n            investors[addr].paidInterest, investors[addr].investment\r\n            );\r\n    }\r\n\r\n    // Change to not return interest if the player wins a prize.\r\n    function WinnerNotReturn(address addr) private {\r\n\r\n        // investment could be less than wager, if nextWave() triggered.\r\n        if (investors[addr].investment >= minInvestment) {\r\n            investors[addr].investment -= minInvestment;\r\n\r\n            emit LogInvestChange(\r\n                addr, investors[addr].payableInterest,\r\n                investors[addr].paidInterest, investors[addr].investment\r\n                );\r\n        }\r\n    }\r\n\r\n    // wageType: 0 for conservative, 1 for aggressive, 2 for interest\r\n    function doBet(address addr, uint value, WagerType wagerType) private returns(bool){\r\n        uint ticketNum;\r\n        bool conservative;\r\n\r\n        if (wagerType != WagerType.Interest) {\r\n            takeCommission(value);\r\n        }\r\n\r\n        if (value >= minInvestment) {\r\n            // take 50% wager as winner's prize pool\r\n            prizePool += value * prizePercent / 100;\r\n        }\r\n\r\n        if (wagerType == WagerType.Conservative) {\r\n            // conservative, 0.01 ETH for 1 ticket\r\n            ticketNum = value / minInvestment;\r\n            conservative = true;\r\n        } else if (wagerType == WagerType.Aggressive) {\r\n            // aggressive\r\n            ticketNum = value * leverageMultiple / minInvestment;\r\n        } else {\r\n            // interest\r\n            ticketNum = value * leverageMultiple / minInvestment;\r\n        }\r\n\r\n        if (activeTicketSlotSum == lotteryTickets.length) {\r\n            lotteryTickets.length++;\r\n        }\r\n\r\n        uint slot = activeTicketSlotSum++;\r\n        lotteryTickets[slot].player = addr;\r\n        lotteryTickets[slot].conservative = conservative;\r\n        lotteryTickets[slot].beginNum = ticketSum;\r\n        ticketSum += ticketNum;\r\n        lotteryTickets[slot].endNum = ticketSum - 1;\r\n\r\n        emit LogBet(wagerType, addr, value, lotteryTickets[slot].beginNum, lotteryTickets[slot].endNum, prizePool);\r\n\r\n        if (prizePool >= minPrizePool) {\r\n\r\n            if (address(this).balance - prizePool >= minInvestment) {\r\n                // last one gets extra 0.01 ETH award.\r\n                addr.transfer(minInvestment);\r\n            }\r\n\r\n            drawLottery();\r\n            nextBet();\r\n        }\r\n    }\r\n\r\n    function drawLottery() private {\r\n        uint[] memory luckyTickets = getLuckyTickets();\r\n\r\n        payTicketsPrize(luckyTickets);\r\n    }\r\n\r\n    function random(uint i) private view returns(uint) {\r\n        // take last block hash as random seed\r\n        return uint(keccak256(abi.encodePacked(blockhash(block.number - 1), i)));\r\n    }\r\n\r\n    function getLuckyTickets() private view returns(uint[] memory) {\r\n\r\n        // lucky ticket number, 1 for first prize(1 ETH), 10 for second prize(0.02 ETH)\r\n        uint[] memory luckyTickets = new uint[](winnerNum);\r\n\r\n        uint num;\r\n        uint k;\r\n\r\n        for (uint i = 0;; i++) {\r\n            num = random(i) % ticketSum;\r\n            bool duplicate = false;\r\n            for (uint j = 0; j < k; j++) {\r\n                if (num == luckyTickets[j]) {\r\n                    // random seed may generate duplicated lucky numbers.\r\n                    duplicate = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!duplicate) {\r\n                luckyTickets[k++] = num;\r\n\r\n                if (k == winnerNum)\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return luckyTickets;\r\n    }\r\n\r\n    function sort(uint[] memory data) private {\r\n        if (data.length == 0)\r\n            return;\r\n        quickSort(data, 0, data.length - 1);\r\n    }\r\n\r\n    function quickSort(uint[] memory arr, uint left, uint right) private {\r\n        uint i = left;\r\n        uint j = right;\r\n        if(i == j) return;\r\n        uint pivot = arr[uint(left + (right - left) / 2)];\r\n        while (i <= j) {\r\n            while (arr[i] < pivot) i++;\r\n            while (pivot < arr[j]) j--;\r\n            if (i <= j) {\r\n                (arr[i], arr[j]) = (arr[j], arr[i]);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(arr, left, j);\r\n        if (i < right)\r\n            quickSort(arr, i, right);\r\n    }\r\n\r\n    function payTicketsPrize(uint[] memory luckyTickets) private {\r\n\r\n        uint j;\r\n        uint k;\r\n        uint prize;\r\n\r\n        uint prize1st_num = luckyTickets[0];\r\n\r\n        sort(luckyTickets);\r\n\r\n        for (uint i = 0 ; i < activeTicketSlotSum; i++) {\r\n            uint beginNum = lotteryTickets[i].beginNum;\r\n            uint endNum = lotteryTickets[i].endNum;\r\n\r\n            for (k = j; k < luckyTickets.length; k++) {\r\n                uint luckyNum = luckyTickets[k];\r\n\r\n                if (luckyNum == prize1st_num) {\r\n                    prize = prize1st;\r\n                } else {\r\n                    prize = prize2nd;\r\n                }\r\n\r\n                if (beginNum <= luckyNum && luckyNum <= endNum) {\r\n                    address winner = lotteryTickets[i].player;\r\n                    winner.transfer(prize);\r\n\r\n                    emit LogPayWinnerPrize(winner, luckyNum, prize);\r\n\r\n                    // winner would not get the interest(2% per day)\r\n                    // for conservative wager\r\n                    if (lotteryTickets[i].conservative) {\r\n                        WinnerNotReturn(winner);\r\n                    }\r\n\r\n                    // found luckyTickets[k]\r\n                    j = k + 1;\r\n                } else {\r\n                    // break on luckyTickets[k]\r\n                    j = k;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (j == luckyTickets.length) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(address addr) public {\r\n        admin = addr;\r\n\r\n        // create Leverage contract instance\r\n        leverage = new Leverage();\r\n\r\n        nextWave();\r\n        nextBet();\r\n    }\r\n\r\n    function nextWave() private {\r\n        waveNum++;\r\n        emit LogNextWave();\r\n    }\r\n\r\n    function nextBet() private {\r\n\r\n        prizePool = 0;\r\n        roundStartup = now;\r\n\r\n        activeTicketSlotSum = 0;\r\n        ticketSum = 0;\r\n\r\n        emit LogNextBet();\r\n    }\r\n\r\n    function() payable public {\r\n\r\n        if (msg.sender == address(leverage)) {\r\n            // from Leverage Contract\r\n            return;\r\n        }\r\n\r\n        // value round down\r\n        uint value = uint(msg.value / minInvestment) * minInvestment;\r\n\r\n\r\n        if (value < minInvestment) {\r\n            withdrawInterest(msg.sender);\r\n\r\n        } else {\r\n            doInvest(msg.sender, value);\r\n\r\n            doBet(msg.sender, value, WagerType.Conservative);\r\n        }\r\n    }\r\n\r\n    function takeCommission(uint value) private {\r\n        uint commission = value * commissionPercent / 100;\r\n        admin.transfer(commission);\r\n    }\r\n\r\n    function doLeverageBet(address addr, uint value) public onlyLeverage {\r\n        if (value < minInvestment) {\r\n\r\n            uint interest = takeInterest(addr);\r\n\r\n            if (interest > 0)\r\n                doBet(addr, interest, WagerType.Interest);\r\n\r\n        } else {\r\n            doBet(addr, value, WagerType.Aggressive);\r\n        }\r\n    }\r\n\r\n    function getLeverageAddress() public view returns(address) {\r\n        return address(leverage);\r\n    }\r\n\r\n}\r\n\r\ncontract Leverage {\r\n\r\n    WinEthFree private mainContract;\r\n    uint private constant minInvestment = 10 finney;\r\n\r\n    constructor() public {\r\n        mainContract = WinEthFree(msg.sender);\r\n    }\r\n\r\n    function() payable public {\r\n\r\n        uint value = msg.value;\r\n        if (value > 0) {\r\n            address(mainContract).transfer(value);\r\n        }\r\n\r\n        // round down\r\n        value = uint(value / minInvestment) * minInvestment;\r\n\r\n        mainContract.doLeverageBet(msg.sender, value);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Leverage", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://7d49653b50d584e9c3abdc8a1b57a0b3cc554f0262e396ff6b790f37c495ed01"}]}