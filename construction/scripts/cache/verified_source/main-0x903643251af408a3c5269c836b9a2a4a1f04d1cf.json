{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n\r\ncontract SysEscrow {\r\n\r\n    address public owner;\r\n    address arbitrator;\r\n\r\n    uint public MinDeposit = 600000000000000000; // 0.6 Ether\r\n\r\n    uint constant ARBITRATOR_PERCENT = 1; //1%\r\n\r\n    struct Escrow {\r\n            // Set so we know the trade has already been created\r\n            bool exists;        \r\n        \r\n            address seller;\r\n            address buyer;\r\n            uint summ;\r\n            uint buyerCanCancelAfter;\r\n            bool buyerApprovedTheTransaction;\r\n            bool arbitratorStopTransaction;\r\n    }\r\n\r\n    // Mapping of active trades. Key is a hash of the trade data\r\n    mapping (bytes32 => Escrow) public escrows;\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(tx.origin == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    function SysEscrow() {\r\n        owner = msg.sender;\r\n        arbitrator = msg.sender;\r\n    }\r\n\r\n\r\nfunction createEscrow(\r\n      /**\r\n       * Create a new escrow and add it to `escrows`.\r\n       * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.\r\n       * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).\r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n\r\n      uint _paymentWindowInSeconds // The time in seconds from Escrow creation that the buyer can return money\r\n    ) payable external {\r\n        uint256 _value = msg.value;\r\n        require(_value>=MinDeposit);\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);\r\n        require(!escrows[_tradeHash].exists); // Require that trade does not already exist\r\n        uint _buyerCanCancelAfter =  now + _paymentWindowInSeconds;\r\n        escrows[_tradeHash] = Escrow(true, _seller, _buyer, _value, _buyerCanCancelAfter, false, false);\r\n\r\n    }    \r\n\r\n\r\n\r\n    function setArbitrator( address _newArbitrator ) onlyOwner {\r\n        /**\r\n         * Set the arbitrator to a new address. Only the owner can call this.\r\n         * @param address _newArbitrator\r\n         */\r\n        arbitrator = _newArbitrator;\r\n    }\r\n\r\n    function setOwner(address _newOwner) onlyOwner external {\r\n        /**\r\n         * Change the owner to a new address. Only the owner can call this.\r\n         * @param address _newOwner\r\n         */\r\n        owner = _newOwner;\r\n    }\r\n\r\n\r\n    function cancelEscrow(\r\n      /**\r\n       * Cancel escrow. Return money to buyer\r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value // \r\n    )  external {\r\n        \r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);\r\n        require(escrows[_tradeHash].exists);\r\n        require(escrows[_tradeHash].buyerCanCancelAfter<now);\r\n        \r\n        uint256 arbitratorValue = escrows[_tradeHash].summ*ARBITRATOR_PERCENT/100;\r\n        uint256 buyerValue =  escrows[_tradeHash].summ - arbitratorValue;\r\n        \r\n        bool buyerReceivedMoney = escrows[_tradeHash].buyer.call.value(buyerValue)();\r\n        bool arbitratorReceivedMoney = arbitrator.call.value(arbitratorValue)();\r\n        \r\n        if ( buyerReceivedMoney && arbitratorReceivedMoney )\r\n        {    \r\n            delete escrows[_tradeHash];\r\n        } else {\r\n            throw;\r\n        }\r\n\r\n    }\r\n    \r\n    function approveEscrow(\r\n      /**\r\n       * Approve escrow. \r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value // Trade value\r\n    )  external {\r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);\r\n        require(escrows[_tradeHash].exists);\r\n        require(escrows[_tradeHash].buyer==msg.sender);\r\n        escrows[_tradeHash].buyerApprovedTheTransaction = true;\r\n    }\r\n    \r\n    \r\n    function releaseEscrow(\r\n      /**\r\n       * Release escrow. Send money to seller\r\n       */\r\n      bytes16 _tradeID, // The unique ID of the trade\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value // Trade value\r\n    )  external {\r\n        \r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);\r\n        require(escrows[_tradeHash].exists);\r\n        require(escrows[_tradeHash].buyerApprovedTheTransaction);\r\n        \r\n        \r\n        uint256 arbitratorValue = escrows[_tradeHash].summ*ARBITRATOR_PERCENT/100;\r\n        uint256 buyerValue =  escrows[_tradeHash].summ - arbitratorValue;\r\n        \r\n        bool sellerReceivedMoney = escrows[_tradeHash].seller.call.value(buyerValue)();\r\n        bool arbitratorReceivedMoney = arbitrator.call.value(arbitratorValue)();\r\n        \r\n        if ( sellerReceivedMoney && arbitratorReceivedMoney )\r\n        {    \r\n            delete escrows[_tradeHash];\r\n        } else {\r\n            throw;\r\n        }\r\n\r\n    }\r\n        \r\n    \r\n    \r\n    function isExistsEscrow(\r\n      bytes16 _tradeID, // The unique ID of the trade\r\n      address _seller, // The selling party of the trade\r\n      address _buyer, // The buying party of the trade\r\n      uint256 _value // Trade value\r\n    )  constant returns (bool es)  { \r\n        bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value);\r\n        return escrows[_tradeHash].exists; \r\n        \r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"MinDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"summ\",\"type\":\"uint256\"},{\"name\":\"buyerCanCancelAfter\",\"type\":\"uint256\"},{\"name\":\"buyerApprovedTheTransaction\",\"type\":\"bool\"},{\"name\":\"arbitratorStopTransaction\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"cancelEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_paymentWindowInSeconds\",\"type\":\"uint256\"}],\"name\":\"createEscrow\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newArbitrator\",\"type\":\"address\"}],\"name\":\"setArbitrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approveEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"isExistsEscrow\",\"outputs\":[{\"name\":\"es\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tradeID\",\"type\":\"bytes16\"},{\"name\":\"_seller\",\"type\":\"address\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"releaseEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "SysEscrow", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://dd6125a1fecc2c6dfbe662359d368e672f509cac239b42f80a5dde853b03a2a2"}]}