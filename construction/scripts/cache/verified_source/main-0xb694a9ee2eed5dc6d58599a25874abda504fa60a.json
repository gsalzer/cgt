{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n/**\r\n* assert(2 + 2 is 4 - 1 thats 3) Quick Mafs \r\n*/\r\nlibrary QuickMafs {\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a * _b;\r\n        assert(_a == 0 || c / _a == _b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = _a / _b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b <= _a);\r\n        return _a - _b;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/** \r\n* The ownable contract contains an owner address. This give us simple ownership privledges and can allow ownship transfer. \r\n*/\r\ncontract Ownable {\r\n\r\n     /** \r\n     * The owner/admin of the contract\r\n     */ \r\n     address public owner;\r\n    \r\n     /**\r\n     * Constructor for contract. Sets The contract creator to the default owner.\r\n     */\r\n     function Ownable() public {\r\n         owner = msg.sender;\r\n     }\r\n    \r\n    /**\r\n    * Modifier to apply to methods to restrict access to the owner\r\n    */\r\n     modifier onlyOwner(){\r\n         require(msg.sender == owner);\r\n         _; //Placeholder for method content\r\n     }\r\n    \r\n    /**\r\n    * Transfer the ownership to a new owner can only be done by the current owner. \r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n    \r\n        //Only make the change if required\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n    }\r\n    \r\n    /**\r\n    *  ERC Token Standard #20 Interface\r\n    */\r\n    contract ERC20 {\r\n    \r\n    /**\r\n    * Get the total token supply\r\n    */\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    \r\n    /**\r\n    * Get the account balance of another account with address _owner\r\n    */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    \r\n    /**\r\n    * Send _amount of tokens to address _to\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Send _amount of tokens from address _from to address _to\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Allow _spender to withdraw from your account, multiple times, up to the _amount.\r\n    * If this function is called again it overwrites the current allowance with _amount.\r\n    * this function is required for some DEX functionality\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns (bool success);\r\n    \r\n    /**\r\n    * Returns the amount which _spender is still allowed to withdraw from _owner\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    \r\n    /**\r\n    * Triggered when tokens are transferred.\r\n    */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    \r\n    /**\r\n    * Triggered whenever approve(address _spender, uint256 _amount) is called.\r\n    */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n}\r\n\r\n\r\n/**\r\n* The CTN Token\r\n*/\r\ncontract CTNToken is ERC20, Ownable {\r\n\r\nusing QuickMafs for uint256;\r\n\r\nstring public constant SYMBOL = \"CTN\";\r\nstring public constant NAME = \"Crypto Trust Network\";\r\nuint8 public constant DECIMALS = 18;\r\n\r\n/**\r\n* Total supply of tokens\r\n*/\r\nuint256 totalTokens;\r\n\r\n/**\r\n* The initial supply of coins before minting\r\n */\r\nuint256 initialSupply;\r\n\r\n/**\r\n* Balances for each account\r\n*/\r\nmapping(address => uint256) balances;\r\n\r\n/**\r\n* Whos allowed to withdrawl funds from which accounts\r\n*/\r\nmapping(address => mapping (address => uint256)) allowed;\r\n\r\n/**\r\n * If the token is tradable\r\n */ \r\n bool tradable;\r\n \r\n/**\r\n* The address to store the initialSupply\r\n*/\r\naddress public vault;\r\n\r\n/**\r\n* If the coin can be minted\r\n*/\r\nbool public mintingFinished = false;\r\n\r\n/**\r\n * Event for when new coins are created \r\n */\r\nevent Mint(address indexed _to, uint256 _value);\r\n\r\n/**\r\n* Event that is fired when token sale is over\r\n*/\r\nevent MintFinished();\r\n\r\n/**\r\n * Tokens can now be traded\r\n */ \r\nevent TradableTokens(); \r\n\r\n\r\n/**\r\n * Allows this coin to be traded between users\r\n */ \r\nmodifier isTradable(){\r\n    require(tradable);\r\n    _;\r\n}\r\n\r\n/**\r\n * If this coin can be minted modifier\r\n */\r\nmodifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n}\r\n\r\n\r\n/**\r\n* Initializing the token with the owner and the amount of coins excluding the token sale\r\n*/\r\nfunction CTNToken() public {\r\n    initialSupply = 4500000 * 1 ether;\r\n    totalTokens = initialSupply;\r\n    tradable = false;\r\n    vault = 0x6e794AAA2db51fC246b1979FB9A9849f53919D1E; \r\n    balances[vault] = balances[vault].add(initialSupply); //Set initial supply to the vault\r\n}\r\n\r\n/**\r\n* To get the total supply of CTN coins \r\n*/\r\nfunction totalSupply() public constant returns (uint256 totalAmount) {\r\n      totalAmount = totalTokens;\r\n}\r\n\r\n/**\r\n* To get the total supply of CTN coins \r\n*/\r\nfunction baseSupply() public constant returns (uint256 initialAmount) {\r\n      initialAmount = initialSupply;\r\n}\r\n\r\n/**\r\n* Returns the balance of the wallet\r\n*/ \r\nfunction balanceOf(address _address) public constant returns (uint256 balance) {\r\n    return balances[_address];\r\n}\r\n\r\n\r\nfunction transfer(address _to, uint256 _amount) public isTradable returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Transfer(msg.sender, _to, _amount);\r\n    return true;\r\n}\r\n  /**\r\n  * Send _amount of tokens from address _from to address _to\r\n  * The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n  * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n  * fees in sub-currencies; the command should fail unless the _from account has\r\n  * deliberately authorized the sender of the message via some mechanism; we propose\r\n  * these standardized APIs for approval:\r\n  */\r\n  function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _amount\r\n ) public isTradable returns (bool success) \r\n {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    /** \r\n    *   QuickMaf will roll back any changes so no need to check before these operations\r\n    */\r\n    balances[_to] = balances[_to].add(_amount);\r\n    balances[_from] = balances[_from].sub(_amount);\r\n    allowed[_from][msg.sender] = _allowance.sub(_amount);\r\n    Transfer(_from, _to, _amount);\r\n    return true;  \r\n }\r\n\r\n/**\r\n* Allows an address to transfer money out this is administered by the contract owner who can specify how many coins an account can take.\r\n* Needs to be called to feault the amount to 0 first -> https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n*/\r\nfunction approve(address _spender, uint256 _amount) public returns (bool) {\r\n    /**\r\n    *Set the amount they are able to spend to 0 first so that transaction ordering cannot allow multiple withdrawls asyncly\r\n    *This function always requires to calls if a user has an amount they can withdrawl.\r\n    */\r\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _amount;\r\n    Approval(msg.sender, _spender, _amount);\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * Check the amount of tokens the owner has allowed to a spender\r\n */\r\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n     return allowed[_owner][_spender];\r\n}\r\n\r\n/**\r\n * Makes the coin tradable between users cannot be undone\r\n */\r\nfunction makeTradable() public onlyOwner {\r\n    tradable = true;\r\n    TradableTokens();\r\n}\r\n\r\n/**\r\n* Mint tokens to users\r\n*/\r\nfunction mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\r\n    totalTokens = totalTokens.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n}\r\n\r\n/**\r\n* Function to stop minting tokens irreversable\r\n*/\r\nfunction finishMinting() public onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n}\r\n\r\n}\r\n\r\n/**\r\n* The initial crowdsale of the token\r\n*/\r\ncontract CTNTokenSale is Ownable {\r\n\r\n\r\nusing QuickMafs for uint256;\r\n\r\n/**\r\n * The hard cap of the token sale\r\n */\r\nuint256 hardCap;\r\n\r\n/**\r\n * The soft cap of the token sale\r\n */\r\nuint256 softCap;\r\n\r\n/**\r\n * The bonus cap for the token sale\r\n */\r\nuint256 bonusCap;\r\n\r\n/**\r\n * How many tokens you get per ETH\r\n */\r\nuint256 tokensPerETH;\r\n\r\n/** \r\n* //the start time of the sale (new Date(\"Dec 15 2017 18:00:00 GMT\").getTime() / 1000)\r\n*/\r\nuint256 public start = 1513360800;\r\n\r\n\r\n/**\r\n * The end time of the sale (new Date(\"Jan 15 2018 18:00:00 GMT\").getTime() / 1000)\r\n */ \r\nuint256 public end = 1516039200;\r\n\r\n\r\n\r\n/**\r\n * Two months after the sale ends used to retrieve unclaimed refunds (new Date(\"Mar 15 2018 18:00:00 GMT\").getTime() / 1000)\r\n */\r\nuint256 public twoMonthsLater = 1521136800;\r\n\r\n\r\n/**\r\n* Token for minting purposes\r\n*/\r\nCTNToken public token;\r\n\r\n/**\r\n* The address to store eth in during sale \r\n*/\r\naddress public vault;\r\n\r\n\r\n/**\r\n* How much ETH each user has sent to this contract. For softcap unmet refunds\r\n*/\r\nmapping(address => uint256) investments;\r\n\r\n\r\n/**\r\n* Every purchase during the sale\r\n*/\r\nevent TokenSold(address recipient, uint256 etherAmount, uint256 ctnAmount, bool bonus);\r\n\r\n\r\n/**\r\n* Triggered when tokens are transferred.\r\n*/\r\nevent PriceUpdated(uint256 amount);\r\n\r\n/**\r\n* Only make certain changes before the sale starts\r\n*/\r\nmodifier isPreSale(){\r\n     require(now < start);\r\n    _;\r\n}\r\n\r\n/**\r\n* Is the sale still on\r\n*/\r\nmodifier isSaleOn() {\r\n    require(now >= start && now <= end);\r\n    _;\r\n}\r\n\r\n/**\r\n* Has the sale completed\r\n*/\r\nmodifier isSaleFinished() {\r\n    \r\n    bool hitHardCap = token.totalSupply().sub(token.baseSupply()) >= hardCap;\r\n    require(now > end || hitHardCap);\r\n    \r\n    _;\r\n}\r\n\r\n/**\r\n* Has the sale completed\r\n*/\r\nmodifier isTwoMonthsLater() {\r\n    require(now > twoMonthsLater);\r\n    _;\r\n}\r\n\r\n/**\r\n* Make sure we are under the hardcap\r\n*/\r\nmodifier isUnderHardCap() {\r\n\r\n    bool underHard = token.totalSupply().sub(token.baseSupply()) <= hardCap;\r\n    require(underHard);\r\n    _;\r\n}\r\n\r\n/**\r\n* Make sure we are over the soft cap\r\n*/\r\nmodifier isOverSoftCap() {\r\n    bool overSoft = token.totalSupply().sub(token.baseSupply()) >= softCap;\r\n    require(overSoft);\r\n    _;\r\n}\r\n\r\n/**\r\n* Make sure we are over the soft cap\r\n*/\r\nmodifier isUnderSoftCap() {\r\n    bool underSoft = token.totalSupply().sub(token.baseSupply()) < softCap;\r\n    require(underSoft);\r\n    _;\r\n}\r\n\r\n/** \r\n*   The token sale constructor\r\n*/\r\nfunction CTNTokenSale() public {\r\n    hardCap = 10500000 * 1 ether;\r\n    softCap = 500000 * 1 ether;\r\n    bonusCap = 2000000 * 1 ether;\r\n    tokensPerETH = 536; //Tokens per 1 ETH\r\n    token = new CTNToken();\r\n    vault = 0x6e794AAA2db51fC246b1979FB9A9849f53919D1E; \r\n}\r\n\r\n/**\r\n* Update the ETH price for the token sale\r\n*/\r\nfunction updatePrice(uint256 _newPrice) public onlyOwner isPreSale {\r\n    tokensPerETH = _newPrice;\r\n    PriceUpdated(_newPrice);\r\n}\r\n\r\n\r\n/**\r\n* Allows user to buy coins if we are under the hardcap also adds a bonus if under the bonus amount\r\n*/\r\nfunction createTokens(address recipient) public isUnderHardCap isSaleOn payable {\r\n\r\n    uint256 amount = msg.value;\r\n    uint256 tokens = tokensPerETH.mul(amount);\r\n    bool bonus = false;\r\n    \r\n    if (token.totalSupply().sub(token.baseSupply()) < bonusCap) {\r\n        bonus = true;\r\n        tokens = tokens.add(tokens.div(5));\r\n    }\r\n    \r\n    //Add the amount to user invetment total\r\n    investments[msg.sender] = investments[msg.sender].add(msg.value);\r\n    \r\n    token.mint(recipient, tokens);\r\n    \r\n    TokenSold(recipient, amount, tokens, bonus);\r\n}\r\n\r\n\r\n/**\r\n * Withdrawl the funds from the contract.\r\n * Make the token tradeable and finish minting\r\n */ \r\nfunction cleanup() public isTwoMonthsLater {\r\n    vault.transfer(this.balance);\r\n    token.finishMinting();\r\n    token.makeTradable();\r\n}\r\n\r\nfunction destroy() public onlyOwner isTwoMonthsLater {\r\n     token.finishMinting();\r\n     token.makeTradable();\r\n     token.transferOwnership(owner);\r\n     selfdestruct(vault);\r\n}\r\n\r\n\r\n/**\r\n * Withdrawl the funds from the contract.\r\n * Make the token tradeable and finish minting\r\n */ \r\nfunction withdrawl() public isSaleFinished isOverSoftCap {\r\n    vault.transfer(this.balance);\r\n    //Finish the minting and make tradeable before we own the token contract\r\n    token.finishMinting();\r\n    token.makeTradable();\r\n   \r\n}\r\n\r\n/**\r\n * If the soft cap has not been reached and the sale is over investors can reclaim their funds\r\n */ \r\nfunction refund() public isSaleFinished isUnderSoftCap {\r\n    uint256 amount = investments[msg.sender];\r\n    investments[msg.sender] = investments[msg.sender].sub(amount);\r\n    msg.sender.transfer(amount);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Get the ETH balance of this contract\r\n */ \r\nfunction getBalance() public constant returns (uint256 totalAmount) {\r\n      totalAmount = this.balance;\r\n}\r\n\r\n\r\n\r\n/**\r\n* Fallback function which receives ether and created the appropriate number of tokens for the \r\n* msg.sender.\r\n*/\r\nfunction() external payable {\r\n    createTokens(msg.sender);\r\n}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawl\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cleanup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"twoMonthsLater\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ctnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"bool\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"}]", "ContractName": "CTNTokenSale", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://afd35db2885e44d5f90f666ee1b52f1d4fa7e97e44dbddc827bb916041e05365"}]}