{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n/**\r\n * IPausable\r\n *\r\n * Simple interface to pause and resume \r\n *\r\n * #created 11/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IPausable {\r\n\r\n\r\n    /**\r\n     * Returns whether the implementing contract is \r\n     * currently paused or not\r\n     *\r\n     * @return Whether the paused state is active\r\n     */\r\n    function isPaused() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Change the state to paused\r\n     */\r\n    function pause() public;\r\n\r\n\r\n    /**\r\n     * Change the state to resume, undo the effects \r\n     * of calling pause\r\n     */\r\n    function resume() public;\r\n}\r\n\r\n\r\n/**\r\n * IOwnership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Ownership() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public view returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) public returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * IManagedToken\r\n *\r\n * Adds the following functionality to the basic ERC20 token\r\n * - Locking\r\n * - Issuing\r\n * - Burning \r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IManagedToken { \r\n\r\n    /** \r\n     * Returns true if the token is locked\r\n     * \r\n     * @return Whether the token is locked\r\n     */\r\n    function isLocked() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Locks the token so that the transfering of value is disabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function lock() public returns (bool);\r\n\r\n\r\n    /**\r\n     * Unlocks the token so that the transfering of value is enabled \r\n     *\r\n     * @return Whether the unlocking was successful or not\r\n     */\r\n    function unlock() public returns (bool);\r\n\r\n\r\n    /**\r\n     * Issues `_value` new tokens to `_to`\r\n     *\r\n     * @param _to The address to which the tokens will be issued\r\n     * @param _value The amount of new tokens to issue\r\n     * @return Whether the tokens where sucessfully issued or not\r\n     */\r\n    function issue(address _to, uint _value) public returns (bool);\r\n\r\n\r\n    /**\r\n     * Burns `_value` tokens of `_from`\r\n     *\r\n     * @param _from The address that owns the tokens to be burned\r\n     * @param _value The amount of tokens to be burned\r\n     * @return Whether the tokens where sucessfully burned or not \r\n     */\r\n    function burn(address _from, uint _value) public returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * ITokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public;\r\n}\r\n\r\n\r\n/**\r\n * TokenRetriever\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * IAuthenticator \r\n *\r\n * Authenticator interface\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IAuthenticator {\r\n    \r\n\r\n    /**\r\n     * Authenticate \r\n     *\r\n     * Returns whether `_account` is authenticated or not\r\n     *\r\n     * @param _account The account to authenticate\r\n     * @return whether `_account` is successfully authenticated\r\n     */\r\n    function authenticate(address _account) public view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * IAuthenticationManager \r\n *\r\n * Allows the authentication process to be enabled and disabled\r\n *\r\n * #created 15/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IAuthenticationManager {\r\n    \r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication() public;\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication() public;\r\n}\r\n\r\n\r\n/**\r\n * IWingsAdapter\r\n * \r\n * WINGS DAO Price Discovery & Promotion Pre-Beta https://www.wings.ai\r\n *\r\n * #created 04/10/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IWingsAdapter {\r\n\r\n    /**\r\n     * Get the total raised amount of Ether\r\n     *\r\n     * Can only increase, meaning if you withdraw ETH from the wallet, it should be not modified (you can use two fields \r\n     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\r\n     *\r\n     * @return Total raised Ether amount\r\n     */\r\n    function totalCollected() public view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * IPersonalCrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface IPersonalCrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n}\r\n\r\n\r\n/**\r\n * PersonalCrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract PersonalCrowdsaleProxy is IPersonalCrowdsaleProxy {\r\n\r\n    address public owner;\r\n    ICrowdsale public target;\r\n    \r\n\r\n    /**\r\n     * Deploy proxy\r\n     *\r\n     * @param _owner Owner of the proxy\r\n     * @param _target Target crowdsale\r\n     */\r\n    function PersonalCrowdsaleProxy(address _owner, address _target) public {\r\n        target = ICrowdsale(_target);\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive contribution and forward to the target crowdsale\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     */\r\n    function () public payable {\r\n        target.contributeFor.value(msg.value)(owner);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ICrowdsaleProxy\r\n *\r\n * #created 23/11/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsaleProxy {\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * CrowdsaleProxy\r\n *\r\n * #created 22/11/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract CrowdsaleProxy is ICrowdsaleProxy {\r\n\r\n    address public owner;\r\n    ICrowdsale public target;\r\n    \r\n\r\n    /**\r\n     * Deploy proxy\r\n     *\r\n     * @param _owner Owner of the proxy\r\n     * @param _target Target crowdsale\r\n     */\r\n    function CrowdsaleProxy(address _owner, address _target) public {\r\n        target = ICrowdsale(_target);\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive contribution and forward to the crowdsale\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     */\r\n    function () public payable {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint) {\r\n        target.contributeFor.value(msg.value)(_beneficiary);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * ICrowdsale\r\n *\r\n * Base crowdsale interface to manage the sale of \r\n * an ERC20 token\r\n *\r\n * #created 09/09/2017\r\n * #author Frank Bonnet\r\n */\r\ninterface ICrowdsale {\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the ended stage\r\n     *\r\n     * @return True if ended\r\n     */\r\n    function isEnded() public view returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) public view returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable;\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint);\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public;\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public;\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public;\r\n}\r\n\r\n\r\n/**\r\n * Crowdsale\r\n *\r\n * Abstract base crowdsale contract that manages the sale of \r\n * an ERC20 token\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Crowdsale is ICrowdsale, Ownership {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Deployed,\r\n        InProgress,\r\n        Ended\r\n    }\r\n\r\n    struct Balance {\r\n        uint eth;\r\n        uint tokens;\r\n        uint index;\r\n    }\r\n\r\n    struct Percentage {\r\n        uint eth;\r\n        uint tokens;\r\n        bool overwriteReleaseDate;\r\n        uint fixedReleaseDate;\r\n        uint index; \r\n    }\r\n\r\n    struct Payout {\r\n        uint percentage;\r\n        uint vestingPeriod;\r\n    }\r\n\r\n    struct Phase {\r\n        uint rate;\r\n        uint end;\r\n        uint bonusReleaseDate;\r\n        bool useVolumeMultiplier;\r\n    }\r\n\r\n    struct VolumeMultiplier {\r\n        uint rateMultiplier;\r\n        uint bonusReleaseDateMultiplier;\r\n    }\r\n\r\n    // Crowdsale details\r\n    uint public baseRate;\r\n    uint public minAmount; \r\n    uint public maxAmount; \r\n    uint public minAcceptedAmount;\r\n    uint public minAmountPresale; \r\n    uint public maxAmountPresale;\r\n    uint public minAcceptedAmountPresale;\r\n\r\n    // Company address\r\n    address public beneficiary; \r\n\r\n    // Denominators\r\n    uint internal percentageDenominator;\r\n    uint internal tokenDenominator;\r\n\r\n    // Crowdsale state\r\n    uint public start;\r\n    uint public presaleEnd;\r\n    uint public crowdsaleEnd;\r\n    uint public raised;\r\n    uint public allocatedEth;\r\n    uint public allocatedTokens;\r\n    Stages public stage;\r\n\r\n    // Token contract\r\n    IManagedToken public token;\r\n\r\n    // Invested balances\r\n    mapping (address => uint) private balances;\r\n\r\n    // Alocated balances\r\n    mapping (address => mapping(uint => Balance)) private allocated;\r\n    mapping(address => uint[]) private allocatedIndex;\r\n\r\n    // Stakeholders\r\n    mapping (address => Percentage) private stakeholderPercentages;\r\n    address[] private stakeholderPercentagesIndex;\r\n    Payout[] private stakeholdersPayouts;\r\n\r\n    // Crowdsale phases\r\n    Phase[] private phases;\r\n\r\n    // Volume multipliers\r\n    mapping (uint => VolumeMultiplier) private volumeMultipliers;\r\n    uint[] private volumeMultiplierThresholds;\r\n\r\n    \r\n    /**\r\n     * Throw if at stage other than current stage\r\n     * \r\n     * @param _stage expected stage to test for\r\n     */\r\n    modifier at_stage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Only after crowdsaleEnd plus `_time`\r\n     * \r\n     * @param _time Time to pass\r\n     */\r\n    modifier only_after(uint _time) {\r\n        require(now > crowdsaleEnd + _time);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Only after crowdsale\r\n     */\r\n    modifier only_after_crowdsale() {\r\n        require(now > crowdsaleEnd);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Throw if sender is not beneficiary\r\n     */\r\n    modifier only_beneficiary() {\r\n        require(beneficiary == msg.sender);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Start in the deploying stage\r\n     */\r\n    function Crowdsale() public {\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup the crowdsale\r\n     *\r\n     * @param _start The timestamp of the start date\r\n     * @param _token The token that is sold\r\n     * @param _tokenDenominator The token amount of decimals that the token uses\r\n     * @param _percentageDenominator The percision of percentages\r\n     * @param _minAmountPresale The min cap for the presale\r\n     * @param _maxAmountPresale The max cap for the presale\r\n     * @param _minAcceptedAmountPresale The lowest accepted amount during the presale phase\r\n     * @param _minAmount The min cap for the ICO\r\n     * @param _maxAmount The max cap for the ICO\r\n     * @param _minAcceptedAmount The lowest accepted amount during the ICO phase\r\n     */\r\n    function setup(uint _start, address _token, uint _tokenDenominator, uint _percentageDenominator, uint _minAmountPresale, uint _maxAmountPresale, uint _minAcceptedAmountPresale, uint _minAmount, uint _maxAmount, uint _minAcceptedAmount) public only_owner at_stage(Stages.Deploying) {\r\n        token = IManagedToken(_token);\r\n        tokenDenominator = _tokenDenominator;\r\n        percentageDenominator = _percentageDenominator;\r\n        start = _start;\r\n        minAmountPresale = _minAmountPresale;\r\n        maxAmountPresale = _maxAmountPresale;\r\n        minAcceptedAmountPresale = _minAcceptedAmountPresale;\r\n        minAmount = _minAmount;\r\n        maxAmount = _maxAmount;\r\n        minAcceptedAmount = _minAcceptedAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup rates and phases\r\n     *\r\n     * @param _baseRate The rate without bonus\r\n     * @param _phaseRates The rates for each phase\r\n     * @param _phasePeriods The periods that each phase lasts (first phase is the presale phase)\r\n     * @param _phaseBonusLockupPeriods The lockup period that each phase lasts\r\n     * @param _phaseUsesVolumeMultiplier Wheter or not volume bonusses are used in the respective phase\r\n     */\r\n    function setupPhases(uint _baseRate, uint[] _phaseRates, uint[] _phasePeriods, uint[] _phaseBonusLockupPeriods, bool[] _phaseUsesVolumeMultiplier) public only_owner at_stage(Stages.Deploying) {\r\n        baseRate = _baseRate;\r\n        presaleEnd = start + _phasePeriods[0]; // First phase is expected to be the presale phase\r\n        crowdsaleEnd = start; // Plus the sum of the rate phases\r\n\r\n        for (uint i = 0; i < _phaseRates.length; i++) {\r\n            crowdsaleEnd += _phasePeriods[i];\r\n            phases.push(Phase(_phaseRates[i], crowdsaleEnd, 0, _phaseUsesVolumeMultiplier[i]));\r\n        }\r\n\r\n        for (uint ii = 0; ii < _phaseRates.length; ii++) {\r\n            if (_phaseBonusLockupPeriods[ii] > 0) {\r\n                phases[ii].bonusReleaseDate = crowdsaleEnd + _phaseBonusLockupPeriods[ii];\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup stakeholders\r\n     *\r\n     * @param _stakeholders The addresses of the stakeholders (first stakeholder is the beneficiary)\r\n     * @param _stakeholderEthPercentages The eth percentages of the stakeholders\r\n     * @param _stakeholderTokenPercentages The token percentages of the stakeholders\r\n     * @param _stakeholderTokenPayoutOverwriteReleaseDates Wheter the vesting period is overwritten for the respective stakeholder\r\n     * @param _stakeholderTokenPayoutFixedReleaseDates The vesting period after which the whole percentage of the tokens is released to the respective stakeholder\r\n     * @param _stakeholderTokenPayoutPercentages The percentage of the tokens that is released at the respective date\r\n     * @param _stakeholderTokenPayoutVestingPeriods The vesting period after which the respective percentage of the tokens is released\r\n     */\r\n    function setupStakeholders(address[] _stakeholders, uint[] _stakeholderEthPercentages, uint[] _stakeholderTokenPercentages, bool[] _stakeholderTokenPayoutOverwriteReleaseDates, uint[] _stakeholderTokenPayoutFixedReleaseDates, uint[] _stakeholderTokenPayoutPercentages, uint[] _stakeholderTokenPayoutVestingPeriods) public only_owner at_stage(Stages.Deploying) {\r\n        beneficiary = _stakeholders[0]; // First stakeholder is expected to be the beneficiary\r\n        for (uint i = 0; i < _stakeholders.length; i++) {\r\n            stakeholderPercentagesIndex.push(_stakeholders[i]);\r\n            stakeholderPercentages[_stakeholders[i]] = Percentage(\r\n                _stakeholderEthPercentages[i], \r\n                _stakeholderTokenPercentages[i], \r\n                _stakeholderTokenPayoutOverwriteReleaseDates[i],\r\n                _stakeholderTokenPayoutFixedReleaseDates[i], i);\r\n        }\r\n\r\n        // Percentages add up to 100\r\n        for (uint ii = 0; ii < _stakeholderTokenPayoutPercentages.length; ii++) {\r\n            stakeholdersPayouts.push(Payout(_stakeholderTokenPayoutPercentages[ii], _stakeholderTokenPayoutVestingPeriods[ii]));\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Setup volume multipliers\r\n     *\r\n     * @param _volumeMultiplierRates The rates will be multiplied by this value (denominated by 4)\r\n     * @param _volumeMultiplierLockupPeriods The lockup periods will be multiplied by this value (denominated by 4)\r\n     * @param _volumeMultiplierThresholds The volume thresholds for each respective multiplier\r\n     */\r\n    function setupVolumeMultipliers(uint[] _volumeMultiplierRates, uint[] _volumeMultiplierLockupPeriods, uint[] _volumeMultiplierThresholds) public only_owner at_stage(Stages.Deploying) {\r\n        require(phases.length > 0);\r\n        volumeMultiplierThresholds = _volumeMultiplierThresholds;\r\n        for (uint i = 0; i < volumeMultiplierThresholds.length; i++) {\r\n            volumeMultipliers[volumeMultiplierThresholds[i]] = VolumeMultiplier(_volumeMultiplierRates[i], _volumeMultiplierLockupPeriods[i]);\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * After calling the deploy function the crowdsale\r\n     * rules become immutable \r\n     */\r\n    function deploy() public only_owner at_stage(Stages.Deploying) {\r\n        require(phases.length > 0);\r\n        require(stakeholderPercentagesIndex.length > 0);\r\n        stage = Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Prove that beneficiary is able to sign transactions \r\n     * and start the crowdsale\r\n     */\r\n    function confirmBeneficiary() public only_beneficiary at_stage(Stages.Deployed) {\r\n        stage = Stages.InProgress;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the presale phase\r\n     *\r\n     * @return True if in presale phase\r\n     */\r\n    function isInPresalePhase() public view returns (bool) {\r\n        return stage == Stages.InProgress && now >= start && now <= presaleEnd;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if the contract is currently in the ended stage\r\n     *\r\n     * @return True if ended\r\n     */\r\n    function isEnded() public view returns (bool) {\r\n        return stage == Stages.Ended;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_beneficiary` has a balance allocated\r\n     *\r\n     * @param _beneficiary The account that the balance is allocated for\r\n     * @param _releaseDate The date after which the balance can be withdrawn\r\n     * @return True if there is a balance that belongs to `_beneficiary`\r\n     */\r\n    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool) {\r\n        return allocatedIndex[_beneficiary].length > 0 && _releaseDate == allocatedIndex[_beneficiary][allocated[_beneficiary][_releaseDate].index];\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated token balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated token balance\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        uint sum = 0;\r\n        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\r\n            sum += allocated[_owner][allocatedIndex[_owner][i]].tokens;\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated eth balance of `_owner`\r\n     * \r\n     * @param _owner The address from which the allocated eth balance will be retrieved\r\n     * @return The allocated eth balance\r\n     */\r\n    function ethBalanceOf(address _owner) public view returns (uint) {\r\n        uint sum = 0;\r\n        for (uint i = 0; i < allocatedIndex[_owner].length; i++) {\r\n            sum += allocated[_owner][allocatedIndex[_owner][i]].eth;\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n\r\n    /** \r\n     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\r\n     * \r\n     * @param _owner The address from which the refundable balance will be retrieved\r\n     * @return The invested refundable balance\r\n     */\r\n    function refundableEthBalanceOf(address _owner) public view returns (uint) {\r\n        return now > crowdsaleEnd && raised < minAmount ? balances[_owner] : 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the current phase based on the current time\r\n     *\r\n     * @return The index of the current phase\r\n     */\r\n    function getCurrentPhase() public view returns (uint) {\r\n        for (uint i = 0; i < phases.length; i++) {\r\n            if (now <= phases[i].end) {\r\n                return i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return uint(-1); // Does not exist (underflow)\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the rate and bonus release date\r\n     *\r\n     * @param _phase The phase to use while determining the rate\r\n     * @param _volume The amount wei used to determin what volume multiplier to use\r\n     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\r\n     */\r\n    function getRate(uint _phase, uint _volume) public view returns (uint) {\r\n        uint rate = 0;\r\n        if (stage == Stages.InProgress && now >= start) {\r\n            Phase storage phase = phases[_phase];\r\n            rate = phase.rate;\r\n\r\n            // Find volume multiplier\r\n            if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\r\n                for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\r\n                    if (_volume >= volumeMultiplierThresholds[i - 1]) {\r\n                        VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\r\n                        rate += phase.rate * multiplier.rateMultiplier / percentageDenominator;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return rate;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get distribution data based on the current phase and \r\n     * the volume in wei that is being distributed\r\n     * \r\n     * @param _phase The current crowdsale phase\r\n     * @param _volume The amount wei used to determine what volume multiplier to use\r\n     * @return Volumes and corresponding release dates\r\n     */\r\n    function getDistributionData(uint _phase, uint _volume) internal view returns (uint[], uint[]) {\r\n        Phase storage phase = phases[_phase];\r\n        uint remainingVolume = _volume;\r\n\r\n        bool usingMultiplier = false;\r\n        uint[] memory volumes = new uint[](1);\r\n        uint[] memory releaseDates = new uint[](1);\r\n\r\n        // Find volume multipliers\r\n        if (phase.useVolumeMultiplier && volumeMultiplierThresholds.length > 0 && _volume >= volumeMultiplierThresholds[0]) {\r\n            uint phaseReleasePeriod = phase.bonusReleaseDate - crowdsaleEnd;\r\n            for (uint i = volumeMultiplierThresholds.length; i > 0; i--) {\r\n                if (_volume >= volumeMultiplierThresholds[i - 1]) {\r\n                    if (!usingMultiplier) {\r\n                        volumes = new uint[](i + 1);\r\n                        releaseDates = new uint[](i + 1);\r\n                        usingMultiplier = true;\r\n                    }\r\n\r\n                    VolumeMultiplier storage multiplier = volumeMultipliers[volumeMultiplierThresholds[i - 1]];\r\n                    uint releaseDate = phase.bonusReleaseDate + phaseReleasePeriod * multiplier.bonusReleaseDateMultiplier / percentageDenominator;\r\n                    uint volume = remainingVolume - volumeMultiplierThresholds[i - 1];\r\n\r\n                    // Store increment\r\n                    volumes[i] = volume;\r\n                    releaseDates[i] = releaseDate;\r\n\r\n                    remainingVolume -= volume;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store increment\r\n        volumes[0] = remainingVolume;\r\n        releaseDates[0] = phase.bonusReleaseDate;\r\n\r\n        return (volumes, releaseDates);\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert `_wei` to an amount in tokens using \r\n     * the `_rate`\r\n     *\r\n     * @param _wei amount of wei to convert\r\n     * @param _rate rate to use for the conversion\r\n     * @return Amount in tokens\r\n     */\r\n    function toTokens(uint _wei, uint _rate) public view returns (uint) {\r\n        return _wei * _rate * tokenDenominator / 1 ether;\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive Eth and issue tokens to the sender\r\n     * \r\n     * This function requires that msg.sender is not a contract. This is required because it's \r\n     * not possible for a contract to specify a gas amount when calling the (internal) send() \r\n     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\r\n     * \r\n     * Contracts can call the contribute() function instead\r\n     */\r\n    function () public payable {\r\n        require(msg.sender == tx.origin);\r\n        _handleTransaction(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to the sender\r\n     *\r\n     * @return The accepted ether amount\r\n     */\r\n    function contribute() public payable returns (uint) {\r\n        return _handleTransaction(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Receive ether and issue tokens to `_beneficiary`\r\n     *\r\n     * @param _beneficiary The account that receives the tokens\r\n     * @return The accepted ether amount\r\n     */\r\n    function contributeFor(address _beneficiary) public payable returns (uint) {\r\n        return _handleTransaction(_beneficiary, msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Function to end the crowdsale by setting \r\n     * the stage to Ended\r\n     */\r\n    function endCrowdsale() public at_stage(Stages.InProgress) {\r\n        require(now > crowdsaleEnd || raised >= maxAmount);\r\n        require(raised >= minAmount);\r\n        stage = Stages.Ended;\r\n\r\n        // Unlock token\r\n        if (!token.unlock()) {\r\n            revert();\r\n        }\r\n\r\n        // Allocate tokens (no allocation can be done after this period)\r\n        uint totalTokenSupply = IToken(token).totalSupply() + allocatedTokens;\r\n        for (uint i = 0; i < stakeholdersPayouts.length; i++) {\r\n            Payout storage p = stakeholdersPayouts[i];\r\n            _allocateStakeholdersTokens(totalTokenSupply * p.percentage / percentageDenominator, now + p.vestingPeriod);\r\n        }\r\n\r\n        // Allocate remaining ETH\r\n        _allocateStakeholdersEth(this.balance - allocatedEth, 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     */\r\n    function withdrawTokens() public {\r\n        withdrawTokensTo(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated tokens\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function withdrawTokensTo(address _beneficiary) public {\r\n        uint tokensToSend = 0;\r\n        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\r\n            uint releaseDate = allocatedIndex[msg.sender][i];\r\n            if (releaseDate <= now) {\r\n                Balance storage b = allocated[msg.sender][releaseDate];\r\n                tokensToSend += b.tokens;\r\n                b.tokens = 0;\r\n            }\r\n        }\r\n\r\n        if (tokensToSend > 0) {\r\n            allocatedTokens -= tokensToSend;\r\n            if (!token.issue(_beneficiary, tokensToSend)) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     */\r\n    function withdrawEther() public {\r\n        withdrawEtherTo(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw allocated ether\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function withdrawEtherTo(address _beneficiary) public {\r\n        uint ethToSend = 0;\r\n        for (uint i = 0; i < allocatedIndex[msg.sender].length; i++) {\r\n            uint releaseDate = allocatedIndex[msg.sender][i];\r\n            if (releaseDate <= now) {\r\n                Balance storage b = allocated[msg.sender][releaseDate];\r\n                ethToSend += b.eth;\r\n                b.eth = 0;\r\n            }\r\n        }\r\n\r\n        if (ethToSend > 0) {\r\n            allocatedEth -= ethToSend;\r\n            if (!_beneficiary.send(ethToSend)) {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     */\r\n    function refund() public only_after_crowdsale at_stage(Stages.InProgress) {\r\n        refundTo(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * Refund in the case of an unsuccessful crowdsale. The \r\n     * crowdsale is considered unsuccessful if minAmount was \r\n     * not raised before end of the crowdsale\r\n     *\r\n     * @param _beneficiary Address to send to\r\n     */\r\n    function refundTo(address _beneficiary) public only_after_crowdsale at_stage(Stages.InProgress) {\r\n        require(raised < minAmount);\r\n\r\n        uint receivedAmount = balances[msg.sender];\r\n        balances[msg.sender] = 0;\r\n\r\n        if (receivedAmount > 0 && !_beneficiary.send(receivedAmount)) {\r\n            balances[msg.sender] = receivedAmount;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe and clean-up mechanism\r\n     */\r\n    function destroy() public only_beneficiary only_after(2 years) {\r\n        selfdestruct(beneficiary);\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle incoming transaction\r\n     * \r\n     * @param _beneficiary Tokens are issued to this account\r\n     * @param _received The amount that was received\r\n     * @return The accepted ether amount\r\n     */\r\n    function _handleTransaction(address _beneficiary, uint _received) internal at_stage(Stages.InProgress) returns (uint) {\r\n        require(now >= start && now <= crowdsaleEnd);\r\n        require(isAcceptingContributions());\r\n        require(isAcceptedContributor(_beneficiary));\r\n\r\n        if (isInPresalePhase()) {\r\n            return _handlePresaleTransaction(\r\n                _beneficiary, _received);\r\n        } else {\r\n            return _handlePublicsaleTransaction(\r\n                _beneficiary, _received);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle incoming transaction during the presale phase\r\n     * \r\n     * @param _beneficiary Tokens are issued to this account\r\n     * @param _received The amount that was received\r\n     * @return The accepted ether amount\r\n     */\r\n    function _handlePresaleTransaction(address _beneficiary, uint _received) private returns (uint) {\r\n        require(_received >= minAcceptedAmountPresale);\r\n        require(raised < maxAmountPresale);\r\n\r\n        uint acceptedAmount;\r\n        if (raised + _received > maxAmountPresale) {\r\n            acceptedAmount = maxAmountPresale - raised;\r\n        } else {\r\n            acceptedAmount = _received;\r\n        }\r\n\r\n        raised += acceptedAmount;\r\n\r\n        // During the presale phase - Non refundable\r\n        _allocateStakeholdersEth(acceptedAmount, 0); \r\n\r\n        // Issue tokens\r\n        _distributeTokens(_beneficiary, _received, acceptedAmount);\r\n        return acceptedAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle incoming transaction during the publicsale phase\r\n     * \r\n     * @param _beneficiary Tokens are issued to this account\r\n     * @param _received The amount that was received\r\n     * @return The accepted ether amount\r\n     */\r\n    function _handlePublicsaleTransaction(address _beneficiary, uint _received) private returns (uint) {\r\n        require(_received >= minAcceptedAmount);\r\n        require(raised >= minAmountPresale);\r\n        require(raised < maxAmount);\r\n\r\n        uint acceptedAmount;\r\n        if (raised + _received > maxAmount) {\r\n            acceptedAmount = maxAmount - raised;\r\n        } else {\r\n            acceptedAmount = _received;\r\n        }\r\n\r\n        raised += acceptedAmount;\r\n        \r\n        // During the ICO phase - 100% refundable\r\n        balances[_beneficiary] += acceptedAmount; \r\n\r\n        // Issue tokens\r\n        _distributeTokens(_beneficiary, _received, acceptedAmount);\r\n        return acceptedAmount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Distribute tokens \r\n     *\r\n     * Tokens can be issued by instructing the token contract to create new tokens or by \r\n     * allocating tokens and instructing the token contract to create the tokens later\r\n     * \r\n     * @param _beneficiary Tokens are issued to this account\r\n     * @param _received The amount that was received\r\n     * @param _acceptedAmount The amount that was accepted\r\n     */\r\n    function _distributeTokens(address _beneficiary, uint _received, uint _acceptedAmount) private {\r\n        uint tokensToIssue = 0;\r\n        uint phase = getCurrentPhase();\r\n        var rate = getRate(phase, _acceptedAmount);\r\n        if (rate == 0) {\r\n            revert(); // Paused phase\r\n        }\r\n\r\n        // Volume multipliers\r\n        var (volumes, releaseDates) = getDistributionData(\r\n            phase, _acceptedAmount);\r\n        \r\n        // Allocate tokens\r\n        for (uint i = 0; i < volumes.length; i++) {\r\n            var tokensAtCurrentRate = toTokens(volumes[i], rate);\r\n            if (rate > baseRate && releaseDates[i] > now) {\r\n                uint bonusTokens = tokensAtCurrentRate * (rate - baseRate) / rate;\r\n                _allocateTokens(_beneficiary, bonusTokens, releaseDates[i]);\r\n\r\n                tokensToIssue += tokensAtCurrentRate - bonusTokens;\r\n            } else {\r\n                tokensToIssue += tokensAtCurrentRate;\r\n            }\r\n        }\r\n\r\n        // Issue tokens\r\n        if (tokensToIssue > 0 && !token.issue(_beneficiary, tokensToIssue)) {\r\n            revert();\r\n        }\r\n\r\n        // Refund due to max cap hit\r\n        if (_received - _acceptedAmount > 0 && !_beneficiary.send(_received - _acceptedAmount)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate ETH\r\n     *\r\n     * @param _beneficiary The account to alocate the eth for\r\n     * @param _amount The amount of ETH to allocate\r\n     * @param _releaseDate The date after which the eth can be withdrawn\r\n     */    \r\n    function _allocateEth(address _beneficiary, uint _amount, uint _releaseDate) internal {\r\n        if (hasBalance(_beneficiary, _releaseDate)) {\r\n            allocated[_beneficiary][_releaseDate].eth += _amount;\r\n        } else {\r\n            allocated[_beneficiary][_releaseDate] = Balance(\r\n                _amount, 0, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\r\n        }\r\n\r\n        allocatedEth += _amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate Tokens\r\n     *\r\n     * @param _beneficiary The account to allocate the tokens for\r\n     * @param _amount The amount of tokens to allocate\r\n     * @param _releaseDate The date after which the tokens can be withdrawn\r\n     */    \r\n    function _allocateTokens(address _beneficiary, uint _amount, uint _releaseDate) internal {\r\n        if (hasBalance(_beneficiary, _releaseDate)) {\r\n            allocated[_beneficiary][_releaseDate].tokens += _amount;\r\n        } else {\r\n            allocated[_beneficiary][_releaseDate] = Balance(\r\n                0, _amount, allocatedIndex[_beneficiary].push(_releaseDate) - 1);\r\n        }\r\n\r\n        allocatedTokens += _amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate ETH for stakeholders\r\n     *\r\n     * @param _amount The amount of ETH to allocate\r\n     * @param _releaseDate The date after which the eth can be withdrawn\r\n     */    \r\n    function _allocateStakeholdersEth(uint _amount, uint _releaseDate) internal {\r\n        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\r\n            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\r\n            if (p.eth > 0) {\r\n                _allocateEth(stakeholderPercentagesIndex[i], _amount * p.eth / percentageDenominator, _releaseDate);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allocate Tokens for stakeholders\r\n     *\r\n     * @param _amount The amount of tokens created\r\n     * @param _releaseDate The date after which the tokens can be withdrawn (unless overwitten)\r\n     */    \r\n    function _allocateStakeholdersTokens(uint _amount, uint _releaseDate) internal {\r\n        for (uint i = 0; i < stakeholderPercentagesIndex.length; i++) {\r\n            Percentage storage p = stakeholderPercentages[stakeholderPercentagesIndex[i]];\r\n            if (p.tokens > 0) {\r\n                _allocateTokens(\r\n                    stakeholderPercentagesIndex[i], \r\n                    _amount * p.tokens / percentageDenominator, \r\n                    p.overwriteReleaseDate ? p.fixedReleaseDate : _releaseDate);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the implementing contract to validate a \r\n     * contributing account\r\n     *\r\n     * @param _contributor Address that is being validated\r\n     * @return Wheter the contributor is accepted or not\r\n     */\r\n    function isAcceptedContributor(address _contributor) internal view returns (bool);\r\n\r\n\r\n    /**\r\n     * Allows the implementing contract to prevent the accepting \r\n     * of contributions\r\n     *\r\n     * @return Wheter contributions are accepted or not\r\n     */\r\n    function isAcceptingContributions() internal view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * MoxyOne Crowdsale\r\n *\r\n * Advancing the blockchain industry by creating seamless and secure debit card \r\n * and payment infrastructure for every company, project and ICO that issues cryptocurrency tokens. \r\n *\r\n * #created 06/01/2018\r\n * #author Frank Bonnet\r\n */\r\ncontract MoxyOneCrowdsale is Crowdsale, TokenRetriever, IPausable, IAuthenticationManager, IWingsAdapter {\r\n\r\n    // State\r\n    bool private paused;\r\n\r\n    // Authentication\r\n    IAuthenticator private authenticator;\r\n    bool private requireAuthentication;\r\n\r\n\r\n    /**\r\n     * Returns whether the implementing contract is \r\n     * currently paused or not\r\n     *\r\n     * @return Whether the paused state is active\r\n     */\r\n    function isPaused() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n\r\n    /**\r\n     * Change the state to paused\r\n     */\r\n    function pause() public only_owner {\r\n        paused = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Change the state to resume, undo the effects \r\n     * of calling pause\r\n     */\r\n    function resume() public only_owner {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Setup authentication\r\n     *\r\n     * @param _authenticator The address of the authenticator (whitelist)\r\n     * @param _requireAuthentication Wether the crowdale requires contributors to be authenticated\r\n     */\r\n    function setupAuthentication(address _authenticator, bool _requireAuthentication) public only_owner at_stage(Stages.Deploying) {\r\n        authenticator = IAuthenticator(_authenticator);\r\n        requireAuthentication = _requireAuthentication;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if authentication is enabled and false \r\n     * otherwise\r\n     *\r\n     * @return Whether the converter is currently authenticating or not\r\n     */\r\n    function isAuthenticating() public view returns (bool) {\r\n        return requireAuthentication;\r\n    }\r\n\r\n\r\n    /**\r\n     * Enable authentication\r\n     */\r\n    function enableAuthentication() public only_owner {\r\n        requireAuthentication = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Disable authentication\r\n     */\r\n    function disableAuthentication() public only_owner {\r\n        requireAuthentication = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Validate a contributing account\r\n     *\r\n     * @param _contributor Address that is being validated\r\n     * @return Wheter the contributor is accepted or not\r\n     */\r\n    function isAcceptedContributor(address _contributor) internal view returns (bool) {\r\n        return !requireAuthentication || authenticator.authenticate(_contributor);\r\n    }\r\n\r\n\r\n    /**\r\n     * Indicate if contributions are currently accepted\r\n     *\r\n     * @return Wheter contributions are accepted or not\r\n     */\r\n    function isAcceptingContributions() internal view returns (bool) {\r\n        return !paused;\r\n    }\r\n\r\n\r\n    /**\r\n     * Wings integration - Get the total raised amount of Ether\r\n     *\r\n     * Can only increased, means if you withdraw ETH from the wallet, should be not modified (you can use two fields \r\n     * to keep one with a total accumulated amount) amount of ETH in contract and totalCollected for total amount of ETH collected\r\n     *\r\n     * @return Total raised Ether amount\r\n     */\r\n    function totalCollected() public view returns (uint) {\r\n        return raised;\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner {\r\n        super.retrieveTokens(_tokenContract);\r\n\r\n        // Retrieve tokens from our token contract\r\n        ITokenRetriever(token).retrieveTokens(_tokenContract);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"allocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawEtherTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_phase\",\"type\":\"uint256\"},{\"name\":\"_volume\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"contributeFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_baseRate\",\"type\":\"uint256\"},{\"name\":\"_phaseRates\",\"type\":\"uint256[]\"},{\"name\":\"_phasePeriods\",\"type\":\"uint256[]\"},{\"name\":\"_phaseBonusLockupPeriods\",\"type\":\"uint256[]\"},{\"name\":\"_phaseUsesVolumeMultiplier\",\"type\":\"bool[]\"}],\"name\":\"setupPhases\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"toTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokenDenominator\",\"type\":\"uint256\"},{\"name\":\"_percentageDenominator\",\"type\":\"uint256\"},{\"name\":\"_minAmountPresale\",\"type\":\"uint256\"},{\"name\":\"_maxAmountPresale\",\"type\":\"uint256\"},{\"name\":\"_minAcceptedAmountPresale\",\"type\":\"uint256\"},{\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"name\":\"_minAcceptedAmount\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_authenticator\",\"type\":\"address\"},{\"name\":\"_requireAuthentication\",\"type\":\"bool\"}],\"name\":\"setupAuthentication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"refundTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"ethBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAcceptedAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeholders\",\"type\":\"address[]\"},{\"name\":\"_stakeholderEthPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutOverwriteReleaseDates\",\"type\":\"bool[]\"},{\"name\":\"_stakeholderTokenPayoutFixedReleaseDates\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutPercentages\",\"type\":\"uint256[]\"},{\"name\":\"_stakeholderTokenPayoutVestingPeriods\",\"type\":\"uint256[]\"}],\"name\":\"setupStakeholders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAuthenticating\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableAuthentication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"refundableEthBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_volumeMultiplierRates\",\"type\":\"uint256[]\"},{\"name\":\"_volumeMultiplierLockupPeriods\",\"type\":\"uint256[]\"},{\"name\":\"_volumeMultiplierThresholds\",\"type\":\"uint256[]\"}],\"name\":\"setupVolumeMultipliers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableAuthentication\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allocatedEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmountPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_releaseDate\",\"type\":\"uint256\"}],\"name\":\"hasBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawTokensTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"contribute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAcceptedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isInPresalePhase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "MoxyOneCrowdsale", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://13db2a51afc6b90418441279219bd95a35f2c2abd0d063eb492d9839a984c1d8"}]}