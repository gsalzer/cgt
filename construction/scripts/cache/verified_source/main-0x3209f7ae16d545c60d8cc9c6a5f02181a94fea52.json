{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.18;\r\n\r\ninterface ConversionRatesInterface {\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public;\r\n\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\r\n}\r\n\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\ncontract VolumeImbalanceRecorder is Withdrawable {\r\n\r\n    uint constant internal SLIDING_WINDOW_SIZE = 5;\r\n    uint constant internal POW_2_64 = 2 ** 64;\r\n\r\n    struct TokenControlInfo {\r\n        uint minimalRecordResolution; // can be roughly 1 cent\r\n        uint maxPerBlockImbalance; // in twei resolution\r\n        uint maxTotalImbalance; // max total imbalance (between rate updates)\r\n                            // before halting trade\r\n    }\r\n\r\n    mapping(address => TokenControlInfo) internal tokenControlInfo;\r\n\r\n    struct TokenImbalanceData {\r\n        int  lastBlockBuyUnitsImbalance;\r\n        uint lastBlock;\r\n\r\n        int  totalBuyUnitsImbalance;\r\n        uint lastRateUpdateBlock;\r\n    }\r\n\r\n    mapping(address => mapping(uint=>uint)) public tokenImbalanceData;\r\n\r\n    function VolumeImbalanceRecorder(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    function setTokenControlInfo(\r\n        ERC20 token,\r\n        uint minimalRecordResolution,\r\n        uint maxPerBlockImbalance,\r\n        uint maxTotalImbalance\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        tokenControlInfo[token] =\r\n            TokenControlInfo(\r\n                minimalRecordResolution,\r\n                maxPerBlockImbalance,\r\n                maxTotalImbalance\r\n            );\r\n    }\r\n\r\n    function getTokenControlInfo(ERC20 token) public view returns(uint, uint, uint) {\r\n        return (tokenControlInfo[token].minimalRecordResolution,\r\n                tokenControlInfo[token].maxPerBlockImbalance,\r\n                tokenControlInfo[token].maxTotalImbalance);\r\n    }\r\n\r\n    function addImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        internal\r\n    {\r\n        uint currentBlockIndex = currentBlock % SLIDING_WINDOW_SIZE;\r\n        int recordedBuyAmount = int(buyAmount / int(tokenControlInfo[token].minimalRecordResolution));\r\n\r\n        int prevImbalance = 0;\r\n\r\n        TokenImbalanceData memory currentBlockData =\r\n            decodeTokenImbalanceData(tokenImbalanceData[token][currentBlockIndex]);\r\n\r\n        // first scenario - this is not the first tx in the current block\r\n        if (currentBlockData.lastBlock == currentBlock) {\r\n            if (uint(currentBlockData.lastRateUpdateBlock) == rateUpdateBlock) {\r\n                // just increase imbalance\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.totalBuyUnitsImbalance += recordedBuyAmount;\r\n            } else {\r\n                // imbalance was changed in the middle of the block\r\n                prevImbalance = getImbalanceInRange(token, rateUpdateBlock, currentBlock);\r\n                currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n                currentBlockData.lastBlockBuyUnitsImbalance += recordedBuyAmount;\r\n                currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            }\r\n        } else {\r\n            // first tx in the current block\r\n            int currentBlockImbalance;\r\n            (prevImbalance, currentBlockImbalance) = getImbalanceSinceRateUpdate(token, rateUpdateBlock, currentBlock);\r\n\r\n            currentBlockData.lastBlockBuyUnitsImbalance = recordedBuyAmount;\r\n            currentBlockData.lastBlock = uint(currentBlock);\r\n            currentBlockData.lastRateUpdateBlock = uint(rateUpdateBlock);\r\n            currentBlockData.totalBuyUnitsImbalance = int(prevImbalance) + recordedBuyAmount;\r\n        }\r\n\r\n        tokenImbalanceData[token][currentBlockIndex] = encodeTokenImbalanceData(currentBlockData);\r\n    }\r\n\r\n    function setGarbageToVolumeRecorder(ERC20 token) internal {\r\n        for (uint i = 0; i < SLIDING_WINDOW_SIZE; i++) {\r\n            tokenImbalanceData[token][i] = 0x1;\r\n        }\r\n    }\r\n\r\n    function getImbalanceInRange(ERC20 token, uint startBlock, uint endBlock) internal view returns(int buyImbalance) {\r\n        // check the imbalance in the sliding window\r\n        require(startBlock <= endBlock);\r\n\r\n        buyImbalance = 0;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                buyImbalance += int(perBlockData.lastBlockBuyUnitsImbalance);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getImbalanceSinceRateUpdate(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int buyImbalance, int currentBlockImbalance)\r\n    {\r\n        buyImbalance = 0;\r\n        currentBlockImbalance = 0;\r\n        uint latestBlock = 0;\r\n        int imbalanceInRange = 0;\r\n        uint startBlock = rateUpdateBlock;\r\n        uint endBlock = currentBlock;\r\n\r\n        for (uint windowInd = 0; windowInd < SLIDING_WINDOW_SIZE; windowInd++) {\r\n            TokenImbalanceData memory perBlockData = decodeTokenImbalanceData(tokenImbalanceData[token][windowInd]);\r\n\r\n            if (perBlockData.lastBlock <= endBlock && perBlockData.lastBlock >= startBlock) {\r\n                imbalanceInRange += perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n\r\n            if (perBlockData.lastRateUpdateBlock != rateUpdateBlock) continue;\r\n            if (perBlockData.lastBlock < latestBlock) continue;\r\n\r\n            latestBlock = perBlockData.lastBlock;\r\n            buyImbalance = perBlockData.totalBuyUnitsImbalance;\r\n            if (uint(perBlockData.lastBlock) == currentBlock) {\r\n                currentBlockImbalance = perBlockData.lastBlockBuyUnitsImbalance;\r\n            }\r\n        }\r\n\r\n        if (buyImbalance == 0) {\r\n            buyImbalance = imbalanceInRange;\r\n        }\r\n    }\r\n\r\n    function getImbalance(ERC20 token, uint rateUpdateBlock, uint currentBlock)\r\n        internal view\r\n        returns(int totalImbalance, int currentBlockImbalance)\r\n    {\r\n\r\n        int resolution = int(tokenControlInfo[token].minimalRecordResolution);\r\n\r\n        (totalImbalance, currentBlockImbalance) =\r\n            getImbalanceSinceRateUpdate(\r\n                token,\r\n                rateUpdateBlock,\r\n                currentBlock);\r\n\r\n        totalImbalance *= resolution;\r\n        currentBlockImbalance *= resolution;\r\n    }\r\n\r\n    function getMaxPerBlockImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxPerBlockImbalance;\r\n    }\r\n\r\n    function getMaxTotalImbalance(ERC20 token) internal view returns(uint) {\r\n        return tokenControlInfo[token].maxTotalImbalance;\r\n    }\r\n\r\n    function encodeTokenImbalanceData(TokenImbalanceData data) internal pure returns(uint) {\r\n        // check for overflows\r\n        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastBlock < POW_2_64);\r\n        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\r\n        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\r\n        require(data.lastRateUpdateBlock < POW_2_64);\r\n\r\n        // do encoding\r\n        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\r\n        result |= data.lastBlock * POW_2_64;\r\n        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\r\n        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\r\n\r\n        return result;\r\n    }\r\n\r\n    function decodeTokenImbalanceData(uint input) internal pure returns(TokenImbalanceData) {\r\n        TokenImbalanceData memory data;\r\n\r\n        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\r\n        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\r\n        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\r\n        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\r\n\r\n        return data;\r\n    }\r\n}\r\n\r\ncontract ConversionRates is ConversionRatesInterface, VolumeImbalanceRecorder, Utils {\r\n\r\n    // bps - basic rate steps. one step is 1 / 10000 of the rate.\r\n    struct StepFunction {\r\n        int[] x; // quantity for each step. Quantity of each step includes previous steps.\r\n        int[] y; // rate change per quantity step  in bps.\r\n    }\r\n\r\n    struct TokenData {\r\n        bool listed;  // was added to reserve\r\n        bool enabled; // whether trade is enabled\r\n\r\n        // position in the compact data\r\n        uint compactDataArrayIndex;\r\n        uint compactDataFieldIndex;\r\n\r\n        // rate data. base and changes according to quantity and reserve balance.\r\n        // generally speaking. Sell rate is 1 / buy rate i.e. the buy in the other direction.\r\n        uint baseBuyRate;  // in PRECISION units. see KyberConstants\r\n        uint baseSellRate; // PRECISION units. without (sell / buy) spread it is 1 / baseBuyRate\r\n        StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\r\n        StepFunction sellRateQtyStepFunction;// in bps. higher the qua\r\n        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\r\n        StepFunction sellRateImbalanceStepFunction;\r\n    }\r\n\r\n    /*\r\n    this is the data for tokenRatesCompactData\r\n    but solidity compiler optimizer is sub-optimal, and cannot write this structure in a single storage write\r\n    so we represent it as bytes32 and do the byte tricks ourselves.\r\n    struct TokenRatesCompactData {\r\n        bytes14 buy;  // change buy rate of token from baseBuyRate in 10 bps\r\n        bytes14 sell; // change sell rate of token from baseSellRate in 10 bps\r\n\r\n        uint32 blockNumber;\r\n    } */\r\n    uint public validRateDurationInBlocks = 10; // rates are valid for this amount of blocks\r\n    ERC20[] internal listedTokens;\r\n    mapping(address=>TokenData) internal tokenData;\r\n    bytes32[] internal tokenRatesCompactData;\r\n    uint public numTokensInCurrentCompactData = 0;\r\n    address public reserveContract;\r\n    uint constant internal NUM_TOKENS_IN_COMPACT_DATA = 14;\r\n    uint constant internal BYTES_14_OFFSET = (2 ** (8 * NUM_TOKENS_IN_COMPACT_DATA));\r\n\r\n    function ConversionRates(address _admin) public VolumeImbalanceRecorder(_admin)\r\n        { } // solhint-disable-line no-empty-blocks\r\n\r\n    function addToken(ERC20 token) public onlyAdmin {\r\n\r\n        require(!tokenData[token].listed);\r\n        tokenData[token].listed = true;\r\n        listedTokens.push(token);\r\n\r\n        if (numTokensInCurrentCompactData == 0) {\r\n            tokenRatesCompactData.length++; // add new structure\r\n        }\r\n\r\n        tokenData[token].compactDataArrayIndex = tokenRatesCompactData.length - 1;\r\n        tokenData[token].compactDataFieldIndex = numTokensInCurrentCompactData;\r\n\r\n        numTokensInCurrentCompactData = (numTokensInCurrentCompactData + 1) % NUM_TOKENS_IN_COMPACT_DATA;\r\n\r\n        setGarbageToVolumeRecorder(token);\r\n\r\n        setDecimals(token);\r\n    }\r\n\r\n    function setCompactData(bytes14[] buy, bytes14[] sell, uint blockNumber, uint[] indices) public onlyOperator {\r\n\r\n        require(buy.length == sell.length);\r\n        require(indices.length == buy.length);\r\n        require(blockNumber <= 0xFFFFFFFF);\r\n\r\n        uint bytes14Offset = BYTES_14_OFFSET;\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            require(indices[i] < tokenRatesCompactData.length);\r\n            uint data = uint(buy[i]) | uint(sell[i]) * bytes14Offset | (blockNumber * (bytes14Offset * bytes14Offset));\r\n            tokenRatesCompactData[indices[i]] = bytes32(data);\r\n        }\r\n    }\r\n\r\n    function setBaseRate(\r\n        ERC20[] tokens,\r\n        uint[] baseBuy,\r\n        uint[] baseSell,\r\n        bytes14[] buy,\r\n        bytes14[] sell,\r\n        uint blockNumber,\r\n        uint[] indices\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(tokens.length == baseBuy.length);\r\n        require(tokens.length == baseSell.length);\r\n        require(sell.length == buy.length);\r\n        require(sell.length == indices.length);\r\n\r\n        for (uint ind = 0; ind < tokens.length; ind++) {\r\n            require(tokenData[tokens[ind]].listed);\r\n            tokenData[tokens[ind]].baseBuyRate = baseBuy[ind];\r\n            tokenData[tokens[ind]].baseSellRate = baseSell[ind];\r\n        }\r\n\r\n        setCompactData(buy, sell, blockNumber, indices);\r\n    }\r\n\r\n    function setQtyStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateQtyStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateQtyStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setImbalanceStepFunction(\r\n        ERC20 token,\r\n        int[] xBuy,\r\n        int[] yBuy,\r\n        int[] xSell,\r\n        int[] ySell\r\n    )\r\n        public\r\n        onlyOperator\r\n    {\r\n        require(xBuy.length == yBuy.length);\r\n        require(xSell.length == ySell.length);\r\n        require(tokenData[token].listed);\r\n\r\n        tokenData[token].buyRateImbalanceStepFunction = StepFunction(xBuy, yBuy);\r\n        tokenData[token].sellRateImbalanceStepFunction = StepFunction(xSell, ySell);\r\n    }\r\n\r\n    function setValidRateDurationInBlocks(uint duration) public onlyAdmin {\r\n        validRateDurationInBlocks = duration;\r\n    }\r\n\r\n    function enableTokenTrade(ERC20 token) public onlyAdmin {\r\n        require(tokenData[token].listed);\r\n        require(tokenControlInfo[token].minimalRecordResolution != 0);\r\n        tokenData[token].enabled = true;\r\n    }\r\n\r\n    function disableTokenTrade(ERC20 token) public onlyAlerter {\r\n        require(tokenData[token].listed);\r\n        tokenData[token].enabled = false;\r\n    }\r\n\r\n    function setReserveAddress(address reserve) public onlyAdmin {\r\n        reserveContract = reserve;\r\n    }\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public\r\n    {\r\n        require(msg.sender == reserveContract);\r\n\r\n        if (rateUpdateBlock == 0) rateUpdateBlock = getRateUpdateBlock(token);\r\n\r\n        return addImbalance(token, buyAmount, rateUpdateBlock, currentBlock);\r\n    }\r\n\r\n    /* solhint-disable function-max-lines */\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint) {\r\n        // check if trade is enabled\r\n        if (!tokenData[token].enabled) return 0;\r\n        if (tokenControlInfo[token].minimalRecordResolution == 0) return 0; // token control info not set\r\n\r\n        // get rate update block\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n\r\n        uint updateRateBlock = getLast4Bytes(compactData);\r\n        if (currentBlockNumber >= updateRateBlock + validRateDurationInBlocks) return 0; // rate is expired\r\n        // check imbalance\r\n        int totalImbalance;\r\n        int blockImbalance;\r\n        (totalImbalance, blockImbalance) = getImbalance(token, updateRateBlock, currentBlockNumber);\r\n\r\n        // calculate actual rate\r\n        int imbalanceQty;\r\n        int extraBps;\r\n        int8 rateUpdate;\r\n        uint rate;\r\n\r\n        if (buy) {\r\n            // start with base rate\r\n            rate = tokenData[token].baseBuyRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, true);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            qty = getTokenQty(token, rate, qty);\r\n            imbalanceQty = int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].buyRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        } else {\r\n            // start with base rate\r\n            rate = tokenData[token].baseSellRate;\r\n\r\n            // add rate update\r\n            rateUpdate = getRateByteFromCompactData(compactData, token, false);\r\n            extraBps = int(rateUpdate) * 10;\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // compute token qty\r\n            imbalanceQty = -1 * int(qty);\r\n            totalImbalance += imbalanceQty;\r\n\r\n            // add qty overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateQtyStepFunction, int(qty));\r\n            rate = addBps(rate, extraBps);\r\n\r\n            // add imbalance overhead\r\n            extraBps = executeStepFunction(tokenData[token].sellRateImbalanceStepFunction, totalImbalance);\r\n            rate = addBps(rate, extraBps);\r\n        }\r\n\r\n        if (abs(totalImbalance) >= getMaxTotalImbalance(token)) return 0;\r\n        if (abs(blockImbalance + imbalanceQty) >= getMaxPerBlockImbalance(token)) return 0;\r\n\r\n        return rate;\r\n    }\r\n    /* solhint-enable function-max-lines */\r\n\r\n    function getBasicRate(ERC20 token, bool buy) public view returns(uint) {\r\n        if (buy)\r\n            return tokenData[token].baseBuyRate;\r\n        else\r\n            return tokenData[token].baseSellRate;\r\n    }\r\n\r\n    function getCompactData(ERC20 token) public view returns(uint, uint, byte, byte) {\r\n        require(tokenData[token].listed);\r\n\r\n        uint arrayIndex = tokenData[token].compactDataArrayIndex;\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n\r\n        return (\r\n            arrayIndex,\r\n            fieldOffset,\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, true)),\r\n            byte(getRateByteFromCompactData(tokenRatesCompactData[arrayIndex], token, false))\r\n        );\r\n    }\r\n\r\n    function getTokenBasicData(ERC20 token) public view returns(bool, bool) {\r\n        return (tokenData[token].listed, tokenData[token].enabled);\r\n    }\r\n\r\n    /* solhint-disable code-complexity */\r\n    function getStepFunctionData(ERC20 token, uint command, uint param) public view returns(int) {\r\n        if (command == 0) return int(tokenData[token].buyRateQtyStepFunction.x.length);\r\n        if (command == 1) return tokenData[token].buyRateQtyStepFunction.x[param];\r\n        if (command == 2) return int(tokenData[token].buyRateQtyStepFunction.y.length);\r\n        if (command == 3) return tokenData[token].buyRateQtyStepFunction.y[param];\r\n\r\n        if (command == 4) return int(tokenData[token].sellRateQtyStepFunction.x.length);\r\n        if (command == 5) return tokenData[token].sellRateQtyStepFunction.x[param];\r\n        if (command == 6) return int(tokenData[token].sellRateQtyStepFunction.y.length);\r\n        if (command == 7) return tokenData[token].sellRateQtyStepFunction.y[param];\r\n\r\n        if (command == 8) return int(tokenData[token].buyRateImbalanceStepFunction.x.length);\r\n        if (command == 9) return tokenData[token].buyRateImbalanceStepFunction.x[param];\r\n        if (command == 10) return int(tokenData[token].buyRateImbalanceStepFunction.y.length);\r\n        if (command == 11) return tokenData[token].buyRateImbalanceStepFunction.y[param];\r\n\r\n        if (command == 12) return int(tokenData[token].sellRateImbalanceStepFunction.x.length);\r\n        if (command == 13) return tokenData[token].sellRateImbalanceStepFunction.x[param];\r\n        if (command == 14) return int(tokenData[token].sellRateImbalanceStepFunction.y.length);\r\n        if (command == 15) return tokenData[token].sellRateImbalanceStepFunction.y[param];\r\n\r\n        revert();\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getRateUpdateBlock(ERC20 token) public view returns(uint) {\r\n        bytes32 compactData = tokenRatesCompactData[tokenData[token].compactDataArrayIndex];\r\n        return getLast4Bytes(compactData);\r\n    }\r\n\r\n    function getListedTokens() public view returns(ERC20[]) {\r\n        return listedTokens;\r\n    }\r\n\r\n    function getTokenQty(ERC20 token, uint ethQty, uint rate) internal view returns(uint) {\r\n        uint dstDecimals = getDecimals(token);\r\n        uint srcDecimals = ETH_DECIMALS;\r\n\r\n        return calcDstQty(ethQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getLast4Bytes(bytes32 b) internal pure returns(uint) {\r\n        // cannot trust compiler with not turning bit operations into EXP opcode\r\n        return uint(b) / (BYTES_14_OFFSET * BYTES_14_OFFSET);\r\n    }\r\n\r\n    function getRateByteFromCompactData(bytes32 data, ERC20 token, bool buy) internal view returns(int8) {\r\n        uint fieldOffset = tokenData[token].compactDataFieldIndex;\r\n        uint byteOffset;\r\n        if (buy)\r\n            byteOffset = 32 - NUM_TOKENS_IN_COMPACT_DATA + fieldOffset;\r\n        else\r\n            byteOffset = 4 + fieldOffset;\r\n\r\n        return int8(data[byteOffset]);\r\n    }\r\n\r\n    function executeStepFunction(StepFunction f, int x) internal pure returns(int) {\r\n        uint len = f.y.length;\r\n        for (uint ind = 0; ind < len; ind++) {\r\n            if (x <= f.x[ind]) return f.y[ind];\r\n        }\r\n\r\n        return f.y[len-1];\r\n    }\r\n\r\n    function addBps(uint rate, int bps) internal pure returns(uint) {\r\n        uint maxBps = 100 * 100;\r\n        return (rate * uint(int(maxBps) + bps)) / maxBps;\r\n    }\r\n\r\n    function abs(int x) internal pure returns(uint) {\r\n        if (x < 0)\r\n            return uint(-1 * x);\r\n        else\r\n            return uint(x);\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"setReserveAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"disableTokenTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validRateDurationInBlocks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"},{\"name\":\"baseBuy\",\"type\":\"uint256[]\"},{\"name\":\"baseSell\",\"type\":\"uint256[]\"},{\"name\":\"buy\",\"type\":\"bytes14[]\"},{\"name\":\"sell\",\"type\":\"bytes14[]\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"indices\",\"type\":\"uint256[]\"}],\"name\":\"setBaseRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"enableTokenTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAlerter\",\"type\":\"address\"}],\"name\":\"addAlerter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numTokensInCurrentCompactData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"command\",\"type\":\"uint256\"},{\"name\":\"param\",\"type\":\"uint256\"}],\"name\":\"getStepFunctionData\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buy\",\"type\":\"bytes14[]\"},{\"name\":\"sell\",\"type\":\"bytes14[]\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"indices\",\"type\":\"uint256[]\"}],\"name\":\"setCompactData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setValidRateDurationInBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenBasicData\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAlerters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRateUpdateBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"xBuy\",\"type\":\"int256[]\"},{\"name\":\"yBuy\",\"type\":\"int256[]\"},{\"name\":\"xSell\",\"type\":\"int256[]\"},{\"name\":\"ySell\",\"type\":\"int256[]\"}],\"name\":\"setQtyStepFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenImbalanceData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"currentBlockNumber\",\"type\":\"uint256\"},{\"name\":\"buy\",\"type\":\"bool\"},{\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"xBuy\",\"type\":\"int256[]\"},{\"name\":\"yBuy\",\"type\":\"int256[]\"},{\"name\":\"xSell\",\"type\":\"int256[]\"},{\"name\":\"ySell\",\"type\":\"int256[]\"}],\"name\":\"setImbalanceStepFunction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"minimalRecordResolution\",\"type\":\"uint256\"},{\"name\":\"maxPerBlockImbalance\",\"type\":\"uint256\"},{\"name\":\"maxTotalImbalance\",\"type\":\"uint256\"}],\"name\":\"setTokenControlInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"buyAmount\",\"type\":\"int256\"},{\"name\":\"rateUpdateBlock\",\"type\":\"uint256\"},{\"name\":\"currentBlock\",\"type\":\"uint256\"}],\"name\":\"recordImbalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"buy\",\"type\":\"bool\"}],\"name\":\"getBasicRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getCompactData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes1\"},{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenControlInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAlerter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"AlerterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"}]", "ContractName": "ConversionRates", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000cd9d6bf405406d174ade190862491f0ac4c9e33", "Library": "", "SwarmSource": "bzzr://ce4ce7982c532c86ddaf92b7d2eee941a094200c20cc4203be76870f2b276a72"}]}