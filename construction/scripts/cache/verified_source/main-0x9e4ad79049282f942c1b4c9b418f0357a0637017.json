{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^ 0.4.17;\r\n\r\n/*\r\nOld contract: (2016-2017) 0x3F2D17ed39876c0864d321D8a533ba8080273EdE\r\n\r\n1. Transfer Ether to contract for get tokens\r\nThe exchange rate is calculated at the time of receipt of payment and is:\r\n\r\n_emissionPrice = this.balance / _totalSupply * 2\r\n\r\n2. Transfer tokens back to the contract for withdraw ETH \r\nin proportion to your share of the reserve fund (contract balance), the tokens themselves are destroyed (burned).\r\n\r\n_burnPrice = this.balance / _totalSupply\r\n\r\n*/\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths from OpenZeppelin\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 a, uint256 b) internal constant returns(uint256) {\r\n\t\tuint256 c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal constant returns(uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal constant returns(uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint256 a, uint256 b) internal constant returns(uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/issues/20\r\ncontract ERC20Interface {\r\n\tfunction totalSupply() public constant returns(uint256 totalSupplyReturn);\r\n\r\n\tfunction balanceOf(address _owner) public constant returns(uint256 balance);\r\n\r\n\tfunction transfer(address _to, uint256 _value) public returns(bool success);\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\r\n\r\n\tfunction approve(address _spender, uint256 _value) public returns(bool success);\r\n\r\n\tfunction allowance(address _owner, address _spender) public constant returns(uint256 remaining);\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract Noxon is ERC20Interface {\r\n\tusing SafeMath for uint;\r\n\r\n\tstring public constant symbol = \"NOXON\";\r\n\tstring public constant name = \"NOXON\";\r\n\tuint8 public constant decimals = 0; //warning! dividing rounds down, the remainder of the division is the profit of the contract\r\n\tuint256 _totalSupply = 0;\r\n\tuint256 _burnPrice;\r\n\tuint256 _emissionPrice;\r\n\tuint256 initialized;\r\n\t\r\n\tbool public emissionlocked = false;\r\n\t// Owner of this contract\r\n\taddress public owner;\r\n\taddress public manager;\r\n\r\n\t// Balances for each account\r\n\tmapping(address => uint256) balances;\r\n\r\n\t// Owner of account approves the transfer of an amount to another account\r\n\tmapping(address => mapping(address => uint256)) allowed;\r\n\r\n\t// Functions with this modifier can only be executed by the owner\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\taddress newOwner;\r\n\taddress newManager;\r\n\t// BK Ok - Only owner can assign new proposed owner\r\n\tfunction changeOwner(address _newOwner) public onlyOwner {\r\n\t\tnewOwner = _newOwner;\r\n\t}\r\n\r\n\t// BK Ok - Only new proposed owner can accept ownership \r\n\tfunction acceptOwnership() public {\r\n\t\tif (msg.sender == newOwner) {\r\n\t\t\towner = newOwner;\r\n\t\t\tnewOwner = address(0);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction changeManager(address _newManager) public onlyOwner {\r\n\t\tnewManager = _newManager;\r\n\t}\r\n\r\n\r\n\tfunction acceptManagership() public {\r\n\t\tif (msg.sender == newManager) {\r\n\t\t\tmanager = newManager;\r\n            newManager = address(0);\r\n\t\t}\r\n\t}\r\n\r\n\t// Constructor\r\n\t\r\n\tfunction Noxon() public {\r\n        require(_totalSupply == 0);\r\n\t\towner = msg.sender;\r\n\t\tmanager = owner;\r\n        \r\n\t}\r\n\tfunction NoxonInit() public payable onlyOwner returns (bool) {\r\n\t\trequire(_totalSupply == 0);\r\n\t\trequire(initialized == 0);\r\n\t\trequire(msg.value > 0);\r\n\t\tTransfer(0, msg.sender, 1);\r\n\t\tbalances[owner] = 1; //owner got 1 token\r\n\t\t_totalSupply = balances[owner];\r\n\t\t_burnPrice = msg.value;\r\n\t\t_emissionPrice = _burnPrice.mul(2);\r\n\t\tinitialized = block.timestamp;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//The owner can turn off accepting new ether\r\n\tfunction lockEmission() public onlyOwner {\r\n\t\temissionlocked = true;\r\n\t}\r\n\r\n\tfunction unlockEmission() public onlyOwner {\r\n\t\temissionlocked = false;\r\n\t}\r\n\r\n\tfunction totalSupply() public constant returns(uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\tfunction burnPrice() public constant returns(uint256) {\r\n\t\treturn _burnPrice;\r\n\t}\r\n\r\n\tfunction emissionPrice() public constant returns(uint256) {\r\n\t\treturn _emissionPrice;\r\n\t}\r\n\r\n\t// What is the balance of a particular account?\r\n\tfunction balanceOf(address _owner) public constant returns(uint256 balance) {\r\n\t\treturn balances[_owner];\r\n\t}\r\n\r\n\t// Transfer the balance from owner's account to another account\r\n\tfunction transfer(address _to, uint256 _amount) public returns(bool success) {\r\n\r\n\t\t// if you send TOKENS to the contract they will be burned and you will return part of Ether from smart contract\r\n\t\tif (_to == address(this)) {\r\n\t\t\treturn burnTokens(_amount);\r\n\t\t} else {\r\n\r\n\t\t\tif (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\r\n\t\t\t\tbalances[msg.sender] = balances[msg.sender].sub(_amount);\r\n\t\t\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\t\t\tTransfer(msg.sender, _to, _amount);\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tfunction burnTokens(uint256 _amount) private returns(bool success) {\r\n\r\n\t\t_burnPrice = getBurnPrice();\r\n\t\tuint256 _burnPriceTmp = _burnPrice;\r\n\r\n\t\tif (balances[msg.sender] >= _amount && _amount > 0) {\r\n\r\n\t\t\t// subtracts the amount from seller's balance and suply\r\n\t\t\tbalances[msg.sender] = balances[msg.sender].sub(_amount);\r\n\t\t\t_totalSupply = _totalSupply.sub(_amount);\r\n\r\n\t\t\t//do not allow sell last share (fear of dividing by zero)\r\n\t\t\tassert(_totalSupply >= 1);\r\n\r\n\t\t\t// sends ether to the seller\r\n\t\t\tmsg.sender.transfer(_amount.mul(_burnPrice));\r\n\r\n\t\t\t//check new burn price\r\n\t\t\t_burnPrice = getBurnPrice();\r\n\r\n\t\t\t//only growth required \r\n\t\t\tassert(_burnPrice >= _burnPriceTmp);\r\n\r\n\t\t\t//send event\r\n\t\t\tTokenBurned(msg.sender, _amount.mul(_burnPrice), _burnPrice, _amount);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tevent TokenBought(address indexed buyer, uint256 ethers, uint _emissionedPrice, uint amountOfTokens);\r\n\tevent TokenBurned(address indexed buyer, uint256 ethers, uint _burnedPrice, uint amountOfTokens);\r\n\r\n\tfunction () public payable {\r\n\t    //buy tokens\r\n\r\n\t\t//save tmp for double check in the end of function\r\n\t\t//_burnPrice never changes when someone buy tokens\r\n\t\tuint256 _burnPriceTmp = _burnPrice;\r\n\r\n\t\trequire(emissionlocked == false);\r\n\t\trequire(_burnPrice > 0 && _emissionPrice > _burnPrice);\r\n\t\trequire(msg.value > 0);\r\n\r\n\t\t// calculate the amount\r\n\t\tuint256 amount = msg.value / _emissionPrice;\r\n\r\n\t\t//check overflow\r\n\t\trequire(balances[msg.sender] + amount > balances[msg.sender]);\r\n\r\n\t\t// adds the amount to buyer's balance\r\n\t\tbalances[msg.sender] = balances[msg.sender].add(amount);\r\n\t\t_totalSupply = _totalSupply.add(amount);\r\n\r\n        uint mg = msg.value / 2;\r\n\t\t//send 50% to manager\r\n\t\tmanager.transfer(mg);\r\n\t\tTokenBought(msg.sender, msg.value, _emissionPrice, amount);\r\n\r\n\t\t//are prices unchanged?   \r\n\t\t_burnPrice = getBurnPrice();\r\n\t\t_emissionPrice = _burnPrice.mul(2);\r\n\r\n\t\t//\"only growth\"\r\n\t\tassert(_burnPrice >= _burnPriceTmp);\r\n\t}\r\n    \r\n\tfunction getBurnPrice() public returns(uint) {\r\n\t\treturn this.balance / _totalSupply;\r\n\t}\r\n\r\n\tevent EtherReserved(uint etherReserved);\r\n\t//add Ether to reserve fund without issue new tokens (prices will growth)\r\n\r\n\tfunction addToReserve() public payable returns(bool) {\r\n\t    uint256 _burnPriceTmp = _burnPrice;\r\n\t\tif (msg.value > 0) {\r\n\t\t\t_burnPrice = getBurnPrice();\r\n\t\t\t_emissionPrice = _burnPrice.mul(2);\r\n\t\t\tEtherReserved(msg.value);\r\n\t\t\t\r\n\t\t\t//\"only growth\" check \r\n\t\t    assert(_burnPrice >= _burnPriceTmp);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// Send _value amount of tokens from address _from to address _to\r\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\r\n\t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\r\n\t// fees in sub-currencies; the command should fail unless the _from account has\r\n\t// deliberately authorized the sender of the message via some mechanism; we propose\r\n\t// these standardized APIs for approval:\r\n\tfunction transferFrom(\r\n\t\taddress _from,\r\n\t\taddress _to,\r\n\t\tuint256 _amount\r\n\t) public returns(bool success) {\r\n\t\tif (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to] && _to != address(this) //not allow burn tockens from exhanges\r\n\t\t) {\r\n\t\t\tbalances[_from] = balances[_from].sub(_amount);\r\n\t\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n\t\t\tbalances[_to] = balances[_to].add(_amount);\r\n\t\t\tTransfer(_from, _to, _amount);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n\t// If this function is called again it overwrites the current allowance with _value.\r\n\tfunction approve(address _spender, uint256 _amount) public returns(bool success) {\r\n\t\tallowed[msg.sender][_spender] = _amount;\r\n\t\tApproval(msg.sender, _spender, _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\tfunction transferAnyERC20Token(address tokenAddress, uint amount)\r\n\tpublic\r\n\tonlyOwner returns(bool success) {\r\n\t\treturn ERC20Interface(tokenAddress).transfer(owner, amount);\r\n\t}\r\n\r\n\tfunction burnAll() external returns(bool) {\r\n\t\treturn burnTokens(balances[msg.sender]);\r\n\t}\r\n    \r\n    \r\n}\r\n\r\ncontract TestProcess {\r\n    Noxon main;\r\n    \r\n    function TestProcess() payable {\r\n        main = new Noxon();\r\n    }\r\n   \r\n    function () payable {\r\n        \r\n    }\r\n     \r\n    function init() returns (uint) {\r\n       \r\n        if (!main.NoxonInit.value(12)()) throw;    //init and set burn price as 12 and emission price to 24 \r\n        if (!main.call.value(24)()) revert(); //buy 1 token\r\n \r\n        assert(main.balanceOf(address(this)) == 2); \r\n        \r\n        if (main.call.value(23)()) revert(); //send small amount (must be twhrowed)\r\n        assert(main.balanceOf(address(this)) == 2); \r\n    }\r\n    \r\n    \r\n    \r\n    function test1() returns (uint) {\r\n        if (!main.call.value(26)()) revert(); //check floor round (26/24 must issue 1 token)\r\n        assert(main.balanceOf(address(this)) == 3); \r\n        assert(main.emissionPrice() == 24); //24.6 but round floor\r\n        return main.balance;\r\n    }\r\n    \r\n    function test2() returns (uint){\r\n        if (!main.call.value(40)()) revert(); //check floor round (40/24 must issue 1 token)\r\n        assert(main.balanceOf(address(this)) == 4); \r\n        //assert(main.emissionPrice() == 28);\r\n        //return main.burnPrice();\r\n    } \r\n    \r\n    function test3() {\r\n        if (!main.transfer(address(main),2)) revert();\r\n        assert(main.burnPrice() == 14);\r\n    } \r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getBurnPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockEmission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emissionlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockEmission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emissionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addToReserve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"NoxonInit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptManagership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_emissionedPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_burnedPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherReserved\",\"type\":\"uint256\"}],\"name\":\"EtherReserved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Noxon", "CompilerVersion": "v0.4.17+commit.bdeb9e52", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://0a6a24e71491b45dd4260f86aad5c6aaa95542453aa20126980a4c34295624dc"}]}