{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.21;\r\n\r\n/// @author Luis Freitas, Miguel Amaral (https://repop.world)\r\ncontract REPOPAccessControl {\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    bool public paused = false;\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract PullPayment {\r\n  mapping(address => uint) public payments;\r\n\r\n  function asyncSend(address dest, uint amount) internal {\r\n    payments[dest] += amount;\r\n  }\r\n\r\n  function withdrawPayments() external {\r\n    uint payment = payments[msg.sender];\r\n    payments[msg.sender] = 0;\r\n    if (!msg.sender.send(payment)) {\r\n      payments[msg.sender] = payment;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\r\ncontract ERC721 {\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function implementsERC721() public pure returns (bool);\r\n  function ownerOf(uint256 _tokenId) public view returns (address addr);\r\n  function takeOwnership(uint256 _tokenId) public;\r\n  function totalSupply() public view returns (uint256 total);\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 tokenId);\r\n  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\r\n  function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract MetadataContract{\r\n\r\n    function getMetadata(uint256 _tokenId) public view returns (bytes32[4] buffer, uint256 count) {\r\n        buffer[0] = \"https://meta.repop.world/\";\r\n        buffer[1] = uintToBytes(_tokenId);\r\n        count = 64;\r\n    }\r\n\r\n      function _memcpy(uint _dest, uint _src, uint _len) private view {\r\n\r\n        for(; _len >= 32; _len -= 32) {\r\n            assembly {\r\n                mstore(_dest, mload(_src))\r\n            }\r\n            _dest += 32;\r\n            _src += 32;\r\n        }\r\n\r\n        uint256 mask = 256 ** (32 - _len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(_src), not(mask))\r\n            let destpart := and(mload(_dest), mask)\r\n            mstore(_dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\r\n        var outputString = new string(_stringLength);\r\n        uint256 outputPtr;\r\n        uint256 bytesPtr;\r\n\r\n        assembly {\r\n            outputPtr := add(outputString, 32)\r\n            bytesPtr := _rawBytes\r\n        }\r\n\r\n        _memcpy(outputPtr, bytesPtr, _stringLength);\r\n\r\n        return outputString;\r\n    }\r\n\r\n    function getMetadataUrl(uint256 _tokenId) external view returns (string infoUrl) {\r\n        bytes32[4] memory buffer;\r\n        uint256 count;\r\n        (buffer, count) = getMetadata(_tokenId);\r\n\r\n        return _toString(buffer, count);\r\n    }\r\n\r\n    function uintToBytes(uint v) public view returns (bytes32 ret) {\r\n        if (v == 0) {\r\n            ret = '0';\r\n        }\r\n        else {\r\n            while (v > 0) {\r\n                ret = bytes32(uint(ret) / (2 ** 8));\r\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\r\n                v /= 10;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n\r\n/// @author Luis Freitas, Miguel Amaral (https://repop.world)\r\ncontract REPOPERC721 is ERC721, REPOPAccessControl{\r\n\r\n  MetadataContract public metadataContract;\r\n\r\n  bytes4 constant InterfaceSignature_ERC165 =\r\n      bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n  bytes4 constant InterfaceSignature_ERC721 =\r\n      bytes4(keccak256('name()')) ^\r\n      bytes4(keccak256('symbol()')) ^\r\n      bytes4(keccak256('totalSupply()')) ^\r\n      bytes4(keccak256('balanceOf(address)')) ^\r\n      bytes4(keccak256('ownerOf(uint256)')) ^\r\n      bytes4(keccak256('approve(address,uint256)')) ^\r\n      bytes4(keccak256('transfer(address,uint256)')) ^\r\n      bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n      bytes4(keccak256('tokensOfOwner(address)')) ^\r\n      bytes4(keccak256('tokenMetadata(uint256)'));\r\n\r\n    function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl) {\r\n      require(metadataContract != address(0));\r\n      require(_tokenId >= 0 && _tokenId <= pops.length);\r\n\r\n      return metadataContract.getMetadataUrl(_tokenId);\r\n    }\r\n\r\n    function setMetadataContractAddress(address contractAddress) public onlyCEO{\r\n      require(contractAddress != address(0));\r\n      metadataContract = MetadataContract(contractAddress);\r\n    }\r\n\r\n    string public constant name = \"REPOP WORLD\";\r\n    string public constant symbol = \"POP\";\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) public whenNotPaused{\r\n\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        popIndexToApproved[_tokenId] = _to;\r\n\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance){\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    function implementsERC721() public pure returns (bool){\r\n        return true;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\r\n        owner = popIndexToOwner[_tokenId];\r\n        require(owner != address(0));\r\n    }\r\n\r\n    function takeOwnership(uint256 _tokenId) public {\r\n        address currentOwner = ownerOf(_tokenId);\r\n        address newOwner = msg.sender;\r\n\r\n        require(_addressNotNull(newOwner));\r\n        require(_approved(newOwner, _tokenId));\r\n\r\n        _transfer(newOwner, _tokenId);\r\n        emit Transfer(currentOwner, newOwner, _tokenId);\r\n    }\r\n\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n        if (tokenCount == 0) {\r\n\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalPops = totalSupply();\r\n            uint256 resultIndex = 0;\r\n            uint256 popId;\r\n\r\n            for (popId = 1; popId <= totalPops; popId++) {\r\n                if (popIndexToOwner[popId] == _owner) {\r\n                    result[resultIndex] = popId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256 total) {\r\n        return pops.length;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId ) public whenNotPaused{\r\n      require(_owns(msg.sender, _tokenId));\r\n      require(_addressNotNull(_to));\r\n\r\n      _transfer(_to, _tokenId);\r\n\r\n      emit Transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused{\r\n        require(_owns(_from, _tokenId));\r\n        require(_approved(msg.sender, _tokenId));\r\n        require(_addressNotNull(_to));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n\r\n    function _addressNotNull(address _to) private pure returns (bool){\r\n        return _to != address(0);\r\n    }\r\n\r\n    function _approved(address _to, uint256 _tokenId) private view returns (bool) {\r\n        return popIndexToApproved[_tokenId] == _to;\r\n    }\r\n\r\n    function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\r\n        return claimant == popIndexToOwner[_tokenId];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenID) internal {\r\n        address owner = popIndexToOwner[_tokenID];\r\n        ownershipTokenCount[owner] = ownershipTokenCount[owner] - 1 ;\r\n        popIndexToApproved[_tokenID] = 0;\r\n        popIndexToOwner[_tokenID] = _to;\r\n        ownershipTokenCount[_to] = ownershipTokenCount[_to] + 1;\r\n    }\r\n\r\n    event Birth(address owner, uint256 popId, uint256 aParentId, uint256 bParentId, uint256 genes);\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n\r\n    struct Pop {\r\n      uint256 genes;\r\n      uint64 birthTime;\r\n      uint64 cooldownEndTimestamp;\r\n      uint32 aParentId;\r\n      uint32 bParentId;\r\n      bytes32 popName;\r\n      uint16 cooldownIndex;\r\n      uint16 generation;\r\n    }\r\n\r\n    uint32[14] public cooldowns = [\r\n        uint32(10 minutes),\r\n        uint32(20 minutes),\r\n        uint32(40 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(3 hours),\r\n        uint32(4 hours),\r\n        uint32(5 hours),\r\n        uint32(6 hours),\r\n        uint32(12 hours),\r\n        uint32(1 days),\r\n        uint32(3 days),\r\n        uint32(5 days),\r\n        uint32(7 days)\r\n    ];\r\n\r\n    Pop[] public pops;\r\n\r\n    mapping (uint256 => address) public popIndexToOwner;\r\n    mapping (address => uint256) public ownershipTokenCount;\r\n    mapping (uint256 => address) public popIndexToApproved;\r\n    mapping (uint256 => uint256) public genesToTokenId;\r\n\r\n    function getPop(uint256 _popId) public view\r\n                    returns (\r\n                                bool isReady,\r\n                                uint256 genes,\r\n                                uint64 birthTime,\r\n                                uint64 cooldownEndTimestamp,\r\n                                uint32 aParentId,\r\n                                uint32 bParentId,\r\n                                bytes32 popName,\r\n                                uint16 cooldownIndex,\r\n                                uint16 generation){\r\n        Pop memory pop = pops[_popId];\r\n        return(\r\n                isReady = (pop.cooldownEndTimestamp <= now),\r\n                pop.genes,\r\n                pop.birthTime,\r\n                pop.cooldownEndTimestamp,\r\n                pop.aParentId,\r\n                pop.bParentId,\r\n                pop.popName,\r\n                pop.cooldownIndex,\r\n                pop.generation);\r\n    }\r\n\r\n\r\n    function createNewPop(uint256 genes, string popName) public onlyCLevel whenNotPaused{\r\n        bytes32 name32 = stringToBytes32(popName);\r\n        uint256 index = pops.push(Pop(genes,uint64(now),1,0,0,name32,0,0)) -1;\r\n\r\n        emit Birth(msg.sender,index,0,0,genes);\r\n\r\n        genesToTokenId[genes] = index;\r\n\r\n        popIndexToOwner[index] = msg.sender;\r\n        ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;\r\n    }\r\n\r\n    function _triggerCooldown(Pop storage _pop) internal {\r\n        _pop.cooldownEndTimestamp = uint64(now + cooldowns[_pop.cooldownIndex]);\r\n    }\r\n\r\n    function stringToBytes32(string memory source) internal pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function setPopNameOriginal(uint256 popId, string newName) external onlyCLevel{\r\n      Pop storage pop = pops[popId];\r\n      require(pop.generation == 0);\r\n      bytes32 name32 = stringToBytes32(newName);\r\n      pop.popName = name32;\r\n    }\r\n\r\n    function setDNA(uint256 popId, uint256 newDna) external onlyCLevel{\r\n      require(_owns(msg.sender, popId));\r\n      Pop storage pop = pops[popId];\r\n      pop.genes = newDna;\r\n    }\r\n\r\n}\r\n\r\ncontract CarefulTransfer {\r\n    uint constant suggestedExtraGasToIncludeWithSends = 23000;\r\n\r\n    function carefulSendWithFixedGas(\r\n        address _toAddress,\r\n        uint _valueWei,\r\n        uint _extraGasIncluded\r\n    ) internal returns (bool success) {\r\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\r\n    }\r\n}\r\n\r\ncontract MoneyManager is PullPayment, CarefulTransfer, REPOPAccessControl {\r\n\r\n    function _repopTransaction(address _receiver, uint256 _amountWei, uint256 _marginPerThousandForDevelopers) internal {\r\n        uint256 commissionWei = (_amountWei * _marginPerThousandForDevelopers) / 1000;\r\n        uint256 compensationWei = _amountWei - commissionWei;\r\n\r\n        if( ! carefulSendWithFixedGas(_receiver,compensationWei,23000)) {\r\n            asyncSend(_receiver, compensationWei);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint amount) external onlyCFO {\r\n        require(amount < address(this).balance);\r\n        cfoAddress.transfer(amount);\r\n    }\r\n\r\n    function getBalance() public view returns (uint256 balance) {\r\n        return address(this).balance;\r\n    }\r\n}\r\n\r\nlibrary RoundMoneyNicely {\r\n    function roundMoneyDownNicely(uint _rawValueWei) internal pure\r\n    returns (uint nicerValueWei) {\r\n        if (_rawValueWei < 1 finney) {\r\n            return _rawValueWei;\r\n        } else if (_rawValueWei < 10 finney) {\r\n            return 10 szabo * (_rawValueWei / 10 szabo);\r\n        } else if (_rawValueWei < 100 finney) {\r\n            return 100 szabo * (_rawValueWei / 100 szabo);\r\n        } else if (_rawValueWei < 1 ether) {\r\n            return 1 finney * (_rawValueWei / 1 finney);\r\n        } else if (_rawValueWei < 10 ether) {\r\n            return 10 finney * (_rawValueWei / 10 finney);\r\n        } else if (_rawValueWei < 100 ether) {\r\n            return 100 finney * (_rawValueWei / 100 finney);\r\n        } else if (_rawValueWei < 1000 ether) {\r\n            return 1 ether * (_rawValueWei / 1 ether);\r\n        } else if (_rawValueWei < 10000 ether) {\r\n            return 10 ether * (_rawValueWei / 10 ether);\r\n        } else {\r\n            return _rawValueWei;\r\n        }\r\n    }\r\n\r\n    function roundMoneyUpToWholeFinney(uint _valueWei) pure internal\r\n    returns (uint valueFinney) {\r\n        return (1 finney + _valueWei - 1 wei) / 1 finney;\r\n    }\r\n}\r\n\r\ncontract AuctionManager is MoneyManager {\r\n    event Bid(address bidder, uint256 bid, uint256 auctionId);\r\n    event NewAuction( uint256 itemForAuctionID, uint256 durationSeconds, address seller);\r\n    event NewAuctionWinner(address highestBidder, uint256 auctionId);\r\n\r\n    struct Auction{\r\n        uint auctionStart;\r\n        uint auctionEnd;\r\n        uint highestBid;\r\n        address highestBidder;\r\n        bool ended;\r\n    }\r\n\r\n    bool public isAuctionManager = true;\r\n    uint256 private marginPerThousandForDevelopers = 50;\r\n    uint256 private percentageBidIncrease = 33;\r\n    uint256 private auctionsStartBid = 0.1 ether;\r\n    address private auctionsStartAddress;\r\n\r\n    mapping (uint256 => uint256) public _itemID2auctionID;\r\n    mapping (uint256 => uint256) public _auctionID2itemID;\r\n    Auction[] public _auctionsArray;\r\n\r\n    ERC721 public nonFungibleContract;\r\n\r\n    function AuctionManager() public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n\r\n        auctionsStartAddress = msg.sender;\r\n        _auctionsArray.push(Auction(0,0,0,0,false));\r\n    }\r\n\r\n    function setERCContract(address candidateAddress) public onlyCEO {\r\n        ERC721 candidateContract = ERC721(candidateAddress);\r\n\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function getERCContractAddress() public view returns (address) {\r\n        return address(nonFungibleContract);\r\n    }\r\n\r\n    function getAllActiveAuctions()  external view returns (uint256[] popsIDs,uint256[] auctionsIDs,uint256[] sellingPrices, address[] highestBidders, bool[] canBeEnded){\r\n\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_auctionsArray.length);\r\n        uint256[] memory toReturnAuctionsIDs = new uint256[](_auctionsArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_auctionsArray.length);\r\n        address[] memory toReturnSellerAddress = new address[](_auctionsArray.length);\r\n        bool[] memory toReturnCanBeEnded = new bool[](_auctionsArray.length);\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _auctionsArray.length; i++){\r\n            uint256 popId = _auctionID2itemID[i];\r\n            uint256 price = requiredBid(i);\r\n\r\n            if(_auctionsArray[i].ended == false){\r\n                toReturnPopsIDs[index] = popId;\r\n                toReturnAuctionsIDs[index] = i;\r\n                toReturnSellingPrices[index] = price;\r\n                toReturnSellerAddress[index] = _auctionsArray[i].highestBidder;\r\n                toReturnCanBeEnded[index] = _auctionsArray[i].auctionEnd < now;\r\n                index++;\r\n            }\r\n        }\r\n        return (toReturnPopsIDs,toReturnAuctionsIDs,toReturnSellingPrices,toReturnSellerAddress,toReturnCanBeEnded);\r\n    }\r\n\r\n    function getAllAuctions()  external view returns (uint256[] popsIDs,uint256[] auctionsIDs,uint256[] sellingPrices){\r\n\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_auctionsArray.length);\r\n        uint256[] memory toReturnAuctionsIDs = new uint256[](_auctionsArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_auctionsArray.length);\r\n\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _auctionsArray.length; i++){\r\n            uint256 popId = _auctionID2itemID[i];\r\n            uint256 price = requiredBid(i);\r\n            toReturnPopsIDs[index] = popId;\r\n            toReturnAuctionsIDs[index] = i;\r\n            toReturnSellingPrices[index] = price;\r\n            index++;\r\n        }\r\n        return (toReturnPopsIDs,toReturnAuctionsIDs,toReturnSellingPrices);\r\n    }\r\n\r\n\r\n    function createAuction(uint256 _itemForAuctionID, uint256 _auctionDurationSeconds, address _seller) public {\r\n        require(msg.sender == getERCContractAddress());\r\n        require(_auctionDurationSeconds >= 20 seconds);\r\n        require(_auctionDurationSeconds < 45 days);\r\n        require(_itemForAuctionID != 0);\r\n        require(_seller != 0);\r\n\r\n        _takeOwnershipOfTokenFrom(_itemForAuctionID,_seller);\r\n\r\n        uint256 auctionEnd = SafeMath.add(now,_auctionDurationSeconds);\r\n        uint256 auctionID = _itemID2auctionID[_itemForAuctionID];\r\n        if(auctionID == 0){\r\n            uint256 index = _auctionsArray.push(Auction(now, auctionEnd, 0, _seller, false)) - 1;\r\n            _itemID2auctionID[_itemForAuctionID] = index;\r\n            _auctionID2itemID[index] = _itemForAuctionID;\r\n        } else {\r\n            Auction storage previousAuction = _auctionsArray[auctionID];\r\n            require(previousAuction.ended == true);\r\n            previousAuction.auctionStart = now;\r\n            previousAuction.auctionEnd = auctionEnd;\r\n            previousAuction.highestBidder = _seller;\r\n            previousAuction.highestBid = 0;\r\n            previousAuction.ended = false;\r\n        }\r\n        emit NewAuction(_itemForAuctionID, _auctionDurationSeconds, _seller);\r\n    }\r\n\r\n    function bid(uint auctionID) public payable whenNotPaused{\r\n        require(auctionID != 0);\r\n        Auction storage auction = _auctionsArray[auctionID];\r\n        require(auction.ended == false);\r\n        require(auction.auctionEnd >= now);\r\n        uint claimBidPrice = requiredBid(auctionID);\r\n        uint256 bidValue = msg.value;\r\n        require(bidValue >= claimBidPrice);\r\n        address previousHighestBidder = auction.highestBidder;\r\n        auction.highestBid = msg.value;\r\n        auction.highestBidder = msg.sender;\r\n        _repopTransaction(previousHighestBidder, msg.value, marginPerThousandForDevelopers);\r\n        emit Bid(msg.sender, msg.value, auctionID);\r\n    }\r\n\r\n    function endAuction(uint auctionID) public{\r\n        require(auctionID != 0);\r\n        Auction storage auction = _auctionsArray[auctionID];\r\n        require(auction.ended == false);\r\n        require(auction.auctionEnd < now);\r\n        auction.ended = true;\r\n        nonFungibleContract.transfer(auction.highestBidder, _auctionID2itemID[auctionID]);\r\n        emit NewAuctionWinner(auction.highestBidder, auctionID);\r\n    }\r\n\r\n    function requiredBid(uint _auctionID) constant public returns (uint256 amountToOutBid) {\r\n        require(_auctionID != 0);\r\n        Auction memory auction = _auctionsArray[_auctionID];\r\n        if(auction.highestBid == 0){\r\n            return auctionsStartBid;\r\n        } else {\r\n            uint256 amountRequiredToOutBid = (auction.highestBid * (100 + percentageBidIncrease)) / 100;\r\n            amountRequiredToOutBid = RoundMoneyNicely.roundMoneyDownNicely(amountRequiredToOutBid);\r\n            return amountRequiredToOutBid;\r\n        }\r\n    }\r\n\r\n    function getAuction(uint _itemForAuctionID) external constant returns (uint256 itemID, uint256 auctionStart, uint256 auctionEnd, address highestBidder, uint256 highestBid, bool ended){\r\n        require(_itemForAuctionID != 0);\r\n        Auction memory auction = _auctionsArray[_itemID2auctionID[_itemForAuctionID]];\r\n        if(auction.highestBidder != 0) {\r\n            itemID = _itemForAuctionID;\r\n            auctionStart =  auction.auctionStart;\r\n            auctionEnd =    auction.auctionEnd;\r\n            highestBidder = auction.highestBidder;\r\n            highestBid =    auction.highestBid;\r\n            ended =         auction.ended;\r\n            return(itemID,auctionStart,auctionEnd,highestBidder,highestBid,ended);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function getAuctionStartBid() public view returns(uint256){\r\n      return auctionsStartBid;\r\n    }\r\n\r\n    function setAuctionStartBid(uint256 _auctionStartBid) public onlyCLevel{\r\n      auctionsStartBid = _auctionStartBid;\r\n    }\r\n\r\n    function _addressNotNull(address _to) private pure returns (bool){\r\n        return _to != address(0);\r\n    }\r\n\r\n\r\n    function _takeOwnershipOfToken(uint256 _itemForAuctionID) internal {\r\n\r\n        nonFungibleContract.takeOwnership(_itemForAuctionID);\r\n    }\r\n\r\n    function _takeOwnershipOfTokenFrom(uint256 _itemForAuctionID, address previousOwner) internal {\r\n        nonFungibleContract.transferFrom(previousOwner,this,_itemForAuctionID);\r\n    }\r\n}\r\n\r\ncontract MarketManager is MoneyManager {\r\n    event PopPurchased(address seller, address buyer, uint256 popId, uint256 sellingPrice);\r\n    event PopCancelSale(address popOwner, uint256 popId);\r\n    event PopChangedPrice(address popOwner, uint256 popId, uint256 newPrice);\r\n\r\n    struct Sale {\r\n        uint256 sellingPrice;\r\n\r\n        address seller;\r\n    }\r\n\r\n    bool public isMarketManager = true;\r\n    uint256 private marginPerThousandForDevelopers = 50;\r\n    uint256 private MAX_SELLING_PRICE = 100000 ether;\r\n    mapping (uint256 => uint256) public _itemID2saleID;\r\n    mapping (uint256 => uint256) public _saleID2itemID;\r\n    Sale[] public _salesArray;\r\n    ERC721 public nonFungibleContract;\r\n\r\n    function MarketManager() public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n        _salesArray.push(Sale(0,0));\r\n        _itemID2saleID[0] = 0;\r\n        _saleID2itemID[0] = 0;\r\n    }\r\n\r\n    function setERCContract(address candidateAddress) public onlyCEO {\r\n        require(candidateAddress != address(0));\r\n        ERC721 candidateContract = ERC721(candidateAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function getERCContractAddress() public view returns (address) {\r\n        return address(nonFungibleContract);\r\n    }\r\n\r\n    function getAllActiveSales()  external view returns (uint256[] popsIDs,uint256[] sellingPrices,address[] sellerAddresses){\r\n\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_salesArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_salesArray.length);\r\n        address[] memory toReturnSellerAddress = new address[](_salesArray.length);\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _salesArray.length; i++){\r\n            uint256 popId = _saleID2itemID[i];\r\n            uint256 price = _salesArray[i].sellingPrice;\r\n            address seller = _salesArray[i].seller;\r\n\r\n            if(seller != 0){\r\n                toReturnSellerAddress[index] = seller;\r\n                toReturnPopsIDs[index] = popId;\r\n                toReturnSellingPrices[index] = price;\r\n                index++;\r\n            }\r\n        }\r\n        return (toReturnPopsIDs,toReturnSellingPrices,toReturnSellerAddress);\r\n    }\r\n\r\n    function getAllSalesByAddress(address addr)  external view returns (uint256[] popsIDs,uint256[] sellingPrices,address[] sellerAddresses){\r\n\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_salesArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_salesArray.length);\r\n        address[] memory toReturnSellerAddress = new address[](_salesArray.length);\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _salesArray.length; i++){\r\n            uint256 popId = _saleID2itemID[i];\r\n            uint256 price = _salesArray[i].sellingPrice;\r\n            address seller = _salesArray[i].seller;\r\n\r\n            if(seller == addr){\r\n                toReturnSellerAddress[index] = seller;\r\n                toReturnPopsIDs[index] = popId;\r\n                toReturnSellingPrices[index] = price;\r\n                index++;\r\n            }\r\n        }\r\n        return (toReturnPopsIDs,toReturnSellingPrices,toReturnSellerAddress);\r\n    }\r\n\r\n    function purchasePop(uint256 _popId) public payable whenNotPaused{\r\n        uint256 saleID = _itemID2saleID[_popId];\r\n        require(saleID != 0);\r\n        Sale storage sale = _salesArray[saleID];\r\n        address popOwner = sale.seller;\r\n        require(popOwner != 0);\r\n        address newOwner = msg.sender;\r\n        uint256 sellingPrice = sale.sellingPrice;\r\n        require(popOwner != newOwner);\r\n        require(_addressNotNull(newOwner));\r\n        require(msg.value == sellingPrice);\r\n        sale.seller = 0;\r\n        nonFungibleContract.transfer(newOwner,_popId);\r\n        _repopTransaction(popOwner, msg.value, marginPerThousandForDevelopers);\r\n        emit PopPurchased(popOwner, msg.sender, _popId, msg.value);\r\n    }\r\n\r\n    function sellerOf(uint _popId) public view returns (address) {\r\n        uint256 saleID = _itemID2saleID[_popId];\r\n        Sale memory sale = _salesArray[saleID];\r\n        return sale.seller;\r\n    }\r\n\r\n    function sellPop(address seller, uint256 _popId, uint256 _sellingPrice) public whenNotPaused{\r\n        require(_sellingPrice < MAX_SELLING_PRICE);\r\n        require(msg.sender == getERCContractAddress());\r\n        require(_sellingPrice > 0);\r\n        _takeOwnershipOfTokenFrom(_popId,seller);\r\n        uint256 saleID = _itemID2saleID[_popId];\r\n        if(saleID == 0) {\r\n            uint256  index = _salesArray.push(Sale(_sellingPrice,seller)) - 1;\r\n            _itemID2saleID[_popId] = index;\r\n            _saleID2itemID[index] = _popId;\r\n        } else {\r\n            Sale storage sale = _salesArray[saleID];\r\n            require(sale.seller == 0);\r\n            sale.seller = seller;\r\n            sale.sellingPrice = _sellingPrice;\r\n        }\r\n    }\r\n\r\n    function cancelSellPop(uint256 _popId) public {\r\n        Sale storage sale = _salesArray[_itemID2saleID[_popId]];\r\n        require(sale.seller == msg.sender);\r\n        sale.seller = 0;\r\n        nonFungibleContract.transfer(msg.sender,_popId);\r\n\r\n        emit PopCancelSale(msg.sender, _popId);\r\n    }\r\n\r\n    function changeSellPOPPrice(uint256 _popId, uint256 _newSellingValue) public whenNotPaused{\r\n      require(_newSellingValue < MAX_SELLING_PRICE);\r\n      require(_newSellingValue > 0);\r\n      Sale storage sale = _salesArray[_itemID2saleID[_popId]];\r\n      require(sale.seller == msg.sender);\r\n      sale.sellingPrice = _newSellingValue;\r\n      emit PopChangedPrice(msg.sender, _popId, _newSellingValue);\r\n    }\r\n\r\n    function _addressNotNull(address _to) private pure returns (bool){\r\n        return _to != address(0);\r\n    }\r\n\r\n    function _takeOwnershipOfToken(uint256 _itemForAuctionID) internal {\r\n        nonFungibleContract.takeOwnership(_itemForAuctionID);\r\n    }\r\n\r\n    function _takeOwnershipOfTokenFrom(uint256 _itemForAuctionID, address previousOwner) internal {\r\n        nonFungibleContract.transferFrom(previousOwner,this,_itemForAuctionID);\r\n    }\r\n}\r\n\r\ncontract CloningInterface{\r\n  function isGeneScience() public pure returns (bool);\r\n  function mixGenes(uint256 genes1, uint256 genes2) public returns (uint256);\r\n}\r\n\r\ncontract GenesMarket is MoneyManager {\r\n    event GenesCancelSale(address popOwner, uint256 popId);\r\n    event GenesPurchased(address buyer, address popOwner, uint256 popId, uint256 amount, uint256 price);\r\n    event GenesChangedPrice(address popOwner, uint256 popId, uint256 newPrice);\r\n\r\n    struct GeneForSale {\r\n            uint256 sellingPrice;\r\n            address currentOwner;\r\n    }\r\n\r\n    mapping (uint256 => uint256) public _itemID2geneSaleID;\r\n    mapping (uint256 => uint256) public _geneSaleID2itemID;\r\n    GeneForSale[] public _genesForSaleArray;\r\n    uint256 marginPerThousandForDevelopers = 50;\r\n    uint256 MAX_SELLING_PRICE = 10000 ether;\r\n\r\n    mapping(address => mapping (uint256 => uint256)) _genesOwned;\r\n    mapping(address => uint256[]) _ownedGenesPopsId;\r\n    bool public isGenesMarket = true;\r\n\r\n    function GenesMarket() public {\r\n        ceoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n        _genesForSaleArray.push(GeneForSale(0,0));\r\n    }\r\n\r\n    ERC721 public nonFungibleContract;\r\n    function setERCContract(address candidateAddress) public onlyCEO() {\r\n        ERC721 candidateContract = ERC721(candidateAddress);\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n    function getERCContractAddress() public view returns (address) {\r\n        return address(nonFungibleContract);\r\n    }\r\n\r\n    function startSellingGenes(uint256 _popId, uint256 _sellingPrice, address _seller) public {\r\n        require(_sellingPrice < MAX_SELLING_PRICE);\r\n        require(msg.sender == getERCContractAddress());\r\n        require(_sellingPrice > 0);\r\n        _takeOwnershipOfTokenFrom(_popId,_seller);\r\n        uint256 geneSaleID = _itemID2geneSaleID[_popId];\r\n        if(geneSaleID == 0){\r\n\r\n            uint256 index = _genesForSaleArray.push(GeneForSale(_sellingPrice,_seller)) - 1;\r\n            _itemID2geneSaleID[_popId] = index;\r\n            _geneSaleID2itemID[index] = _popId;\r\n\r\n        }else {\r\n            GeneForSale storage previousSale = _genesForSaleArray[geneSaleID];\r\n            previousSale.sellingPrice = _sellingPrice;\r\n            previousSale.currentOwner = _seller;\r\n        }\r\n    }\r\n\r\n    function stopSellingGenes(uint _popId) public {\r\n        uint256 geneSaleID = _itemID2geneSaleID[_popId];\r\n        require(geneSaleID != 0);\r\n        GeneForSale storage gene = _genesForSaleArray[geneSaleID];\r\n        require(msg.sender == gene.currentOwner);\r\n        require(gene.sellingPrice != 0);\r\n        gene.sellingPrice = 0;\r\n        nonFungibleContract.transfer(gene.currentOwner, _popId);\r\n\r\n        emit GenesCancelSale(msg.sender, _popId);\r\n    }\r\n\r\n\r\n    function sellerOf(uint _popId) public view returns (address) {\r\n        uint256 geneSaleID = _itemID2geneSaleID[_popId];\r\n        GeneForSale memory gene = _genesForSaleArray[geneSaleID];\r\n        if(gene.sellingPrice != 0) {\r\n            return gene.currentOwner;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function useBottle(address _user, uint _popId) external whenNotPaused {\r\n        require(msg.sender == getERCContractAddress());\r\n        require(_genesOwned[_user][_popId] > 0);\r\n        _genesOwned[_user][_popId] = _genesOwned[_user][_popId] - 1;\r\n    }\r\n\r\n\r\n    function purchaseGenes(uint256 _popId, uint256 _amountGenes, bool update) public payable whenNotPaused{\r\n        require(_amountGenes > 0);\r\n        uint256 geneSaleID = _itemID2geneSaleID[_popId];\r\n        GeneForSale memory gene = _genesForSaleArray[geneSaleID];\r\n        require(gene.sellingPrice != 0);\r\n        address popOwner = gene.currentOwner;\r\n        address genesReceiver = msg.sender;\r\n        uint256 sellingPrice = gene.sellingPrice;\r\n        require(popOwner != genesReceiver);\r\n        require(msg.value == SafeMath.mul(sellingPrice, _amountGenes));\r\n        if( update && _genesOwned[msg.sender][_popId] == 0) {\r\n            _ownedGenesPopsId[msg.sender].push(_popId);\r\n        }\r\n        _genesOwned[msg.sender][_popId] = _genesOwned[msg.sender][_popId] + _amountGenes;\r\n        _repopTransaction(popOwner, msg.value, marginPerThousandForDevelopers);\r\n        emit GenesPurchased(msg.sender, popOwner, _popId, _amountGenes, msg.value);\r\n    }\r\n\r\n    function getGenesForSale() public view returns (uint[] popIDs, uint[] sellingPrices, uint[] geneSaleIDs, address[] sellers){\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_genesForSaleArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_genesForSaleArray.length);\r\n        uint256[] memory toReturnGeneSaleID = new uint256[](_genesForSaleArray.length);\r\n        address[] memory toReturnSellers = new address[](_genesForSaleArray.length);\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _genesForSaleArray.length; i++){\r\n            uint256 popId = _geneSaleID2itemID[i];\r\n            uint256 price = _genesForSaleArray[i].sellingPrice;\r\n\r\n            if(price != 0){\r\n                toReturnGeneSaleID[index] = i;\r\n                toReturnPopsIDs[index] = popId;\r\n                toReturnSellingPrices[index] = price;\r\n                toReturnSellers[index] = _genesForSaleArray[i].currentOwner;\r\n                index++;\r\n            }\r\n        }\r\n        return (toReturnPopsIDs,toReturnSellingPrices,toReturnGeneSaleID, toReturnSellers);\r\n    }\r\n\r\n    function getGenesForSaleBySeller(address seller) public view returns (uint[] popIDs, uint[] sellingPrices, uint[] geneSaleIDs, address[] sellers){\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_genesForSaleArray.length);\r\n        uint256[] memory toReturnSellingPrices = new uint256[](_genesForSaleArray.length);\r\n        uint256[] memory toReturnGeneSaleID = new uint256[](_genesForSaleArray.length);\r\n        address[] memory toReturnSellers = new address[](_genesForSaleArray.length);\r\n        uint256 index = 0;\r\n\r\n        for(uint256 i = 1; i < _genesForSaleArray.length; i++){\r\n            uint256 popId = _geneSaleID2itemID[i];\r\n            uint256 price = _genesForSaleArray[i].sellingPrice;\r\n\r\n            if(price != 0){\r\n              if(_genesForSaleArray[i].currentOwner == seller){\r\n                toReturnGeneSaleID[index] = i;\r\n                toReturnPopsIDs[index] = popId;\r\n                toReturnSellingPrices[index] = price;\r\n                toReturnSellers[index] = _genesForSaleArray[i].currentOwner;\r\n                index++;\r\n              }\r\n            }\r\n        }\r\n        return (toReturnPopsIDs,toReturnSellingPrices,toReturnGeneSaleID, toReturnSellers);\r\n    }\r\n\r\n    function getAmountOfGene(uint _popId) public view returns (uint amount){\r\n        return _genesOwned[msg.sender][_popId];\r\n    }\r\n\r\n    function getMyGenes() public view returns (uint[] popIDs, uint[] amount) {\r\n        uint256[] memory toReturnPopsIDs = new uint256[](_ownedGenesPopsId[msg.sender].length);\r\n        uint256[] memory toReturnAmount = new uint256[](_ownedGenesPopsId[msg.sender].length);\r\n\r\n        for(uint256 i = 0; i < _ownedGenesPopsId[msg.sender].length; i++) {\r\n            toReturnPopsIDs[i] = _ownedGenesPopsId[msg.sender][i];\r\n            toReturnAmount[i] = _genesOwned[msg.sender][_ownedGenesPopsId[msg.sender][i]];\r\n        }\r\n        return (toReturnPopsIDs,toReturnAmount);\r\n    }\r\n\r\n    function changeSellGenesPrice(uint256 _popId, uint256 _newSellingValue) public whenNotPaused{\r\n      require(_newSellingValue < MAX_SELLING_PRICE);\r\n      require(_newSellingValue > 0);\r\n      uint256 geneSaleID = _itemID2geneSaleID[_popId];\r\n      require(geneSaleID != 0);\r\n\r\n      GeneForSale storage gene = _genesForSaleArray[geneSaleID];\r\n\r\n      require(msg.sender == gene.currentOwner);\r\n      require(gene.sellingPrice != 0);\r\n\r\n      gene.sellingPrice = _newSellingValue;\r\n\r\n      emit GenesChangedPrice(msg.sender, _popId, _newSellingValue);\r\n    }\r\n\r\n    function _takeOwnershipOfTokenFrom(uint256 _popId, address previousOwner) internal {\r\n        nonFungibleContract.transferFrom(previousOwner,this,_popId);\r\n    }\r\n}\r\n\r\ncontract REPOPCore is REPOPERC721, MoneyManager{\r\n    uint256 public refresherFee = 0.01 ether;\r\n    AuctionManager public auctionManager;\r\n    MarketManager public marketManager;\r\n    GenesMarket public genesMarket;\r\n    CloningInterface public geneScience;\r\n\r\n    event CloneWithTwoPops(address creator, uint256 cloneId, uint256 aParentId, uint256 bParentId);\r\n    event CloneWithPopAndBottle(address creator, uint256 cloneId, uint256 popId, uint256 bottleId);\r\n    event SellingPop(address seller, uint256 popId, uint256 price);\r\n    event SellingGenes(address seller, uint256 popId, uint256 price);\r\n    event ChangedPopName(address owner, uint256 popId, bytes32 newName);\r\n    event CooldownRemoval(uint256 popId, address owner, uint256 paidFee);\r\n\r\n    function REPOPCore() public{\r\n\r\n      ceoAddress = msg.sender;\r\n      cooAddress = msg.sender;\r\n      cfoAddress = msg.sender;\r\n\r\n      createNewPop(0x0, \"Satoshi Nakamoto\");\r\n    }\r\n\r\n    function createNewAuction(uint256 _itemForAuctionID, uint256 _auctionDurationSeconds) public onlyCLevel{\r\n        approve(address(auctionManager),_itemForAuctionID);\r\n        auctionManager.createAuction(_itemForAuctionID,_auctionDurationSeconds,msg.sender);\r\n    }\r\n\r\n    function setAuctionManagerAddress(address _address) external onlyCEO {\r\n        AuctionManager candidateContract = AuctionManager(_address);\r\n\r\n\r\n        require(candidateContract.isAuctionManager());\r\n\r\n\r\n        auctionManager = candidateContract;\r\n    }\r\n\r\n    function getAuctionManagerAddress() public view returns (address) {\r\n        return address(auctionManager);\r\n    }\r\n\r\n    function setMarketManagerAddress(address _address) external onlyCEO {\r\n        MarketManager candidateContract = MarketManager(_address);\r\n        require(candidateContract.isMarketManager());\r\n        marketManager = candidateContract;\r\n    }\r\n\r\n    function getMarketManagerAddress() public view returns (address) {\r\n        return address(marketManager);\r\n    }\r\n\r\n    function setGeneScienceAddress(address _address) external onlyCEO {\r\n      CloningInterface candidateContract = CloningInterface(_address);\r\n      require(candidateContract.isGeneScience());\r\n      geneScience = candidateContract;\r\n    }\r\n\r\n    function getGeneScienceAddress() public view returns (address) {\r\n        return address(geneScience);\r\n    }\r\n\r\n    function setGenesMarketAddress(address _address) external onlyCEO {\r\n      GenesMarket candidateContract = GenesMarket(_address);\r\n      require(candidateContract.isGenesMarket());\r\n      genesMarket = candidateContract;\r\n    }\r\n\r\n    function getGenesMarketAddress() public view returns (address) {\r\n        return address(genesMarket);\r\n    }\r\n\r\n    function sellPop(uint256 _popId, uint256 _price) public {\r\n        Pop storage pop = pops[_popId];\r\n        require(pop.cooldownEndTimestamp <= now);\r\n        approve(address(marketManager),_popId);\r\n        marketManager.sellPop(msg.sender,_popId,_price);\r\n        emit SellingPop(msg.sender, _popId, _price);\r\n    }\r\n\r\n    function sellGenes(uint256 _popId, uint256 _price) public {\r\n        require(_popId > 0);\r\n        approve(address(genesMarket),_popId);\r\n        genesMarket.startSellingGenes(_popId,_price,msg.sender);\r\n        emit SellingGenes(msg.sender, _popId, _price);\r\n    }\r\n\r\n    function getOwnerInAnyPlatformById(uint256 popId) public view returns (address){\r\n      if(ownerOf(popId) == address(marketManager)){\r\n        return marketManager.sellerOf(popId);\r\n      }\r\n      else if(ownerOf(popId) == address(genesMarket)){\r\n        return genesMarket.sellerOf(popId);\r\n      }\r\n      else if(ownerOf(popId) == address(auctionManager)){\r\n        return ceoAddress;\r\n      }\r\n      else{\r\n        return ownerOf(popId);\r\n      }\r\n      return 0x0;\r\n    }\r\n\r\n    function setPopName(uint256 popId, string newName) external {\r\n      require(_ownerOfPopInAnyPlatform(popId));\r\n      Pop storage pop = pops[popId];\r\n      require(pop.generation > 0);\r\n      bytes32 name32 = stringToBytes32(newName);\r\n      pop.popName = name32;\r\n      emit ChangedPopName(msg.sender, popId, name32);\r\n    }\r\n\r\n    function removeCooldown(uint256 popId)\r\n      external\r\n      payable\r\n      {\r\n        require(_ownerOfPopInAnyPlatform(popId));\r\n        require(msg.value >= refresherFee);\r\n        Pop storage pop = pops[popId];\r\n        pop.cooldownEndTimestamp = 1;\r\n        emit CooldownRemoval(popId, msg.sender, refresherFee);\r\n      }\r\n\r\n    function _ownerOfPopInAnyPlatform(uint _popId) internal view returns (bool) {\r\n      return ownerOf(_popId) == msg.sender || genesMarket.sellerOf(_popId) == msg.sender || marketManager.sellerOf(_popId) == msg.sender;\r\n    }\r\n\r\n    function getOwnershipForCloning(uint _popId) internal view returns (bool) {\r\n        return ownerOf(_popId) == msg.sender || genesMarket.sellerOf(_popId) == msg.sender;\r\n    }\r\n\r\n    function changeRefresherFee(uint256 _newFee) public onlyCLevel{\r\n        refresherFee = _newFee;\r\n    }\r\n\r\n    function cloneWithTwoPops(uint256 _aParentId, uint256 _bParentId)\r\n      external\r\n      whenNotPaused\r\n      returns (uint256)\r\n      {\r\n        require(_aParentId > 0);\r\n        require(_bParentId > 0);\r\n        require(getOwnershipForCloning(_aParentId));\r\n        require(getOwnershipForCloning(_bParentId));\r\n        Pop storage aParent = pops[_aParentId];\r\n\r\n        Pop storage bParent = pops[_bParentId];\r\n\r\n        require(aParent.genes != bParent.genes);\r\n        require(aParent.cooldownEndTimestamp <= now);\r\n        require(bParent.cooldownEndTimestamp <= now);\r\n\r\n        uint16 parentGen = aParent.generation;\r\n        if (bParent.generation > aParent.generation) {\r\n            parentGen = bParent.generation;\r\n        }\r\n\r\n        uint16 cooldownIndex = parentGen + 1;\r\n        if (cooldownIndex > 13) {\r\n            cooldownIndex = 13;\r\n        }\r\n\r\n        uint256 childGenes = geneScience.mixGenes(aParent.genes, bParent.genes);\r\n\r\n        _triggerCooldown(aParent);\r\n        _triggerCooldown(bParent);\r\n\r\n        uint256 index = pops.push(Pop(childGenes,uint64(now), 1, uint32(_aParentId), uint32(_bParentId), 0, cooldownIndex, parentGen + 1)) -1;\r\n\r\n        popIndexToOwner[index] = msg.sender;\r\n        ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;\r\n\r\n        emit CloneWithTwoPops(msg.sender, index, _aParentId, _bParentId);\r\n        emit Birth(msg.sender, index, _aParentId, _bParentId,childGenes);\r\n\r\n        return index;\r\n    }\r\n\r\n    function cloneWithPopAndBottle(uint256 _aParentId, uint256 _bParentId_bottle)\r\n        external\r\n        whenNotPaused\r\n        returns (uint256)\r\n        {\r\n          require(_aParentId > 0);\r\n          require(getOwnershipForCloning(_aParentId));\r\n          Pop storage aParent = pops[_aParentId];\r\n          Pop memory bParent = pops[_bParentId_bottle];\r\n\r\n          require(aParent.genes != bParent.genes);\r\n          require(aParent.cooldownEndTimestamp <= now);\r\n\r\n          uint16 parentGen = aParent.generation;\r\n          if (bParent.generation > aParent.generation) {\r\n              parentGen = bParent.generation;\r\n          }\r\n\r\n          uint16 cooldownIndex = parentGen + 1;\r\n          if (cooldownIndex > 13) {\r\n              cooldownIndex = 13;\r\n          }\r\n\r\n          genesMarket.useBottle(msg.sender, _bParentId_bottle);\r\n\r\n          uint256 childGenes = geneScience.mixGenes(aParent.genes, bParent.genes);\r\n\r\n          _triggerCooldown(aParent);\r\n\r\n          uint256 index = pops.push(Pop(childGenes,uint64(now), 1, uint32(_aParentId), uint32(_bParentId_bottle), 0, cooldownIndex, parentGen + 1)) -1;\r\n\r\n          popIndexToOwner[index] = msg.sender;\r\n          ownershipTokenCount[msg.sender] = ownershipTokenCount[msg.sender]+1;\r\n\r\n          emit CloneWithPopAndBottle(msg.sender, index, _aParentId, _bParentId_bottle);\r\n          emit Birth(msg.sender, index, _aParentId, _bParentId_bottle, childGenes);\r\n\r\n          return index;\r\n        }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"},{\"name\":\"_newSellingValue\",\"type\":\"uint256\"}],\"name\":\"changeSellGenesPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"candidateAddress\",\"type\":\"address\"}],\"name\":\"setERCContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"}],\"name\":\"stopSellingGenes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"}],\"name\":\"getAmountOfGene\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_popId\",\"type\":\"uint256\"}],\"name\":\"useBottle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"getGenesForSaleBySeller\",\"outputs\":[{\"name\":\"popIDs\",\"type\":\"uint256[]\"},{\"name\":\"sellingPrices\",\"type\":\"uint256[]\"},{\"name\":\"geneSaleIDs\",\"type\":\"uint256[]\"},{\"name\":\"sellers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyGenes\",\"outputs\":[{\"name\":\"popIDs\",\"type\":\"uint256[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getERCContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isGenesMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"},{\"name\":\"_sellingPrice\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"startSellingGenes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"},{\"name\":\"_amountGenes\",\"type\":\"uint256\"},{\"name\":\"update\",\"type\":\"bool\"}],\"name\":\"purchaseGenes\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_geneSaleID2itemID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGenesForSale\",\"outputs\":[{\"name\":\"popIDs\",\"type\":\"uint256[]\"},{\"name\":\"sellingPrices\",\"type\":\"uint256[]\"},{\"name\":\"geneSaleIDs\",\"type\":\"uint256[]\"},{\"name\":\"sellers\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_popId\",\"type\":\"uint256\"}],\"name\":\"sellerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_itemID2geneSaleID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_genesForSaleArray\",\"outputs\":[{\"name\":\"sellingPrice\",\"type\":\"uint256\"},{\"name\":\"currentOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"popOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"popId\",\"type\":\"uint256\"}],\"name\":\"GenesCancelSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"popOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"popId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GenesPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"popOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"popId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"GenesChangedPrice\",\"type\":\"event\"}]", "ContractName": "GenesMarket", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://517910ead418fd504e35b97fdd9587cd4de9da732805f6e0559eab86865d652c"}]}