{"status": "1", "message": "OK", "result": [{"SourceCode": "//                       , ; ,   .-'\"\"\"'-.   , ; ,\r\n//                       \\\\|/  .'          '.  \\|//\r\n//                        \\-;-/   ()   ()   \\-;-/\r\n//                        // ;               ; \\\\\r\n//                       //__; :.         .; ;__\\\\\r\n//                      `-----\\'.'-.....-'.'/-----'\r\n//                             '.'.-.-,_.'.'\r\n//                               '(  (..-'\r\n//                                 '-'\r\n//  ROULETH \r\n//\r\n//  Play the Roulette on ethereum blockchain !\r\n//  (or become a member of Rouleth's Decentralized Organisation  and contribute to the bankroll.) \r\n//\r\n//\r\n//\r\n//   check latest contract address version on the current website interface\r\n//   V 2\r\n//\r\n//\r\n//\r\n\r\ncontract Rouleth\r\n{\r\n    //Game and Global Variables, Structure of gambles\r\n    address developer;\r\n    uint8 blockDelay; //nb of blocks to wait before spin\r\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\r\n    uint256 maxGamble; //max gamble value manually set by config\r\n    uint256 minGamble; //min gamble value manually set by config\r\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\r\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\r\n    uint casinoStatisticalLimit; //ratio payroll and max win\r\n    //Current gamble value possibly lower than limit auto\r\n    uint256 currentMaxGamble; \r\n    //Gambles\r\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \r\n    struct Gamble\r\n    {\r\n\taddress player;\r\n        bool spinned; //Was the rouleth spinned ?\r\n\tbool win;\r\n\t//Possible bet types\r\n        BetTypes betType;\r\n\tuint8 input; //stores number, color, dozen or oddeven\r\n\tuint256 wager;\r\n\tuint256 blockNumber; //block of bet\r\n\tuint256 blockSpinned; //block of spin\r\n        uint8 wheelResult;\r\n    }\r\n    Gamble[] private gambles;\r\n    uint totalGambles; \r\n    //Tracking progress of players\r\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\r\n    //records current status of player\r\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \r\n\r\n\r\n    //**********************************************\r\n    //        Management & Config FUNCTIONS        //\r\n    //**********************************************\r\n\r\n    function  Rouleth() private //creation settings\r\n    { \r\n        developer = msg.sender;\r\n        blockDelay=1; //indicates which block after bet will be used for RNG\r\n\tblockExpiration=200; //delay after which gamble expires\r\n        minGamble=50 finney; //configurable min bet\r\n        maxGamble=500 finney; //configurable max bet\r\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\r\n        casinoStatisticalLimit=100; //we are targeting at least 400\r\n    }\r\n    \r\n    modifier onlyDeveloper() \r\n    {\r\n\tif (msg.sender!=developer) throw;\r\n\t_\r\n    }\r\n    \r\n    function changeDeveloper_only_Dev(address new_dev)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tdeveloper=new_dev;\r\n    }\r\n\r\n    //Prevents accidental sending of Eth when you shouldn't\r\n    modifier noEthSent()\r\n    {\r\n        if (msg.value>0) \r\n\t{\r\n\t    throw;\r\n\t}\r\n        _\r\n    }\r\n\r\n\r\n    //Activate, Deactivate Betting\r\n    enum States{active, inactive} States private contract_state;\r\n    \r\n    function disableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.inactive;\r\n    }\r\n\r\n\r\n    function enableBetting_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        contract_state=States.active;\r\n\r\n    }\r\n    \r\n    modifier onlyActive()\r\n    {\r\n        if (contract_state==States.inactive) throw;\r\n        _\r\n    }\r\n\r\n\r\n\r\n    //Change some settings within safety bounds\r\n    function changeSettings_only_Dev(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint16 newMaxInvestor, uint256 newMinInvestment,uint256 newMaxInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\r\n\r\n        // changes the statistical multiplier that guarantees the long run casino survival\r\n        if (newCasinoStatLimit<100) throw;\r\n        casinoStatisticalLimit=newCasinoStatLimit;\r\n        //Max number of bets per block to prevent miner cheating\r\n        maxBetsPerBlock=newMaxBetsBlock;\r\n        //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\r\n        if (newMaxGamble<newMinGamble) throw;  \r\n\telse { maxGamble=newMaxGamble; }\r\n        //Min Bet\r\n        if (newMinGamble<0) throw; \r\n\telse { minGamble=newMinGamble; }\r\n        //MAX NB of DAO members (can only increase (within bounds) or stay equal)\r\n        //this number of members can only increase after 25k spins on Rouleth\r\n        //refuse change of max number of members if less than 25k spins played\r\n        if (newMaxInvestor!=setting_maxInvestors && gambles.length<25000) throw;\r\n        if ( newMaxInvestor<setting_maxInvestors \r\n             || newMaxInvestor>investors.length) throw;\r\n        else { setting_maxInvestors=newMaxInvestor;}\r\n        //computes the results of the vote of the VIP members, fees to apply to new members\r\n        computeResultVoteExtraInvestFeesRate();\r\n        if (newMaxInvestment<newMinInvestment) throw;\r\n        //MIN INVEST : \r\n        setting_minInvestment=newMinInvestment;\r\n        //MAX INVEST : \r\n        setting_maxInvestment=newMaxInvestment;\r\n        //Invest LOCK PERIOD\r\n\t//1 year max\r\n\t//can also serve as a failsafe to shutdown withdraws for a period\r\n        if (setting_lockPeriod>360 days) throw; \r\n        setting_lockPeriod=newLockPeriod;\r\n        //Delay before spin :\r\n\tblockDelay=newBlockDelay;\r\n\tif (newBlockExpiration<blockDelay+20) throw;\r\n\tblockExpiration=newBlockExpiration;\r\n        updateMaxBet();\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    //                 Nicknames FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //User set nickname\r\n    mapping (address => string) nicknames;\r\n    function setNickname(string name) \r\n    noEthSent\r\n    {\r\n        if (bytes(name).length >= 2 && bytes(name).length <= 30)\r\n            nicknames[msg.sender] = name;\r\n    }\r\n    function getNickname(address _address) constant returns(string _name) {\r\n        _name = nicknames[_address];\r\n    }\r\n\r\n    \r\n    //**********************************************\r\n    //                 BETTING FUNCTIONS                    //\r\n    //**********************************************\r\n\r\n    //***//basic betting without Mist or contract call\r\n    //activates when the player only sends eth to the contract\r\n    //without specifying any type of bet.\r\n    function () \r\n    {\r\n\t//defaut bet : bet on red\r\n\tbetOnColor(true,false);\r\n    } \r\n\r\n    //Admin function that\r\n    //recalculates max bet\r\n    //updated after each bet and change of bankroll\r\n    function updateMaxBet() private\r\n    {\r\n\t//check that setting is still within safety bounds\r\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \r\n\t{ \r\n\t    currentMaxGamble=maxGamble;\r\n        }\r\n\telse\r\n\t{ \r\n\t    currentMaxGamble = payroll/(casinoStatisticalLimit*35);\r\n\t}\r\n    }\r\n\r\n\r\n    //***//Guarantees that gamble is under max bet and above min.\r\n    // returns bet value\r\n    function checkBetValue() private returns(uint256 playerBetValue)\r\n    {\r\n        if (msg.value < minGamble) throw;\r\n\tif (msg.value > currentMaxGamble) //if above max, send difference back\r\n\t{\r\n            playerBetValue=currentMaxGamble;\r\n\t}\r\n        else\r\n        { playerBetValue=msg.value; }\r\n        return;\r\n    }\r\n\r\n\r\n    //check number of bets in block (to prevent miner cheating)\r\n    modifier checkNbBetsCurrentBlock()\r\n    {\r\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\r\n        else nbBetsCurrentBlock=0;\r\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\r\n        _\r\n    }\r\n\r\n\r\n    //Function record bet called by all others betting functions\r\n    function placeBet(BetTypes betType_, uint8 input_) private\r\n    {\r\n\t// Before we record, we may have to spin the past bet if the croupier bot \r\n\t// is down for some reason or if the player played again too quickly.\r\n\t// This would fail though if the player tries too play to quickly (in consecutive block).\r\n\t// gambles should be spaced by at least a block\r\n\t// the croupier bot should spin within 2 blocks (~30 secs) after your bet.\r\n\t// if the bet expires it is added to casino profit, otherwise it would be a way to cheat\r\n\tif (playerStatus[msg.sender]!=Status.waitingForBet)\r\n\t{\r\n            SpinTheWheel(msg.sender);\r\n\t}\r\n        //Once this is done, we can record the new bet\r\n\tplayerStatus[msg.sender]=Status.waitingForSpin;\r\n\tgambleIndex[msg.sender]=gambles.length;\r\n        totalGambles++;\r\n        //adapts wager to casino limits\r\n        uint256 betValue = checkBetValue();\r\n\tgambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\r\n\t//refund excess bet (at last step vs re-entry)\r\n        if (betValue<msg.value) \r\n        {\r\n \t    if (msg.sender.send(msg.value-betValue)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //***//bet on Number\t\r\n    function betOnNumber(uint8 numberChosen)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        //check that number chosen is valid and records bet\r\n        if (numberChosen>36) throw;\r\n        placeBet(BetTypes.number, numberChosen);\r\n    }\r\n\r\n    //***// function betOnColor\r\n    //bet type : color\r\n    //input : 0 for red\r\n    //input : 1 for black\r\n    function betOnColor(bool Red, bool Black)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Red) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Black) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.color, input);\r\n    }\r\n\r\n    //***// function betOnLow_High\r\n    //bet type : lowhigh\r\n    //input : 0 for low\r\n    //input : 1 for low\r\n    function betOnLowHigh(bool Low, bool High)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Low) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (High) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.lowhigh, input);\r\n    }\r\n\r\n    //***// function betOnOddEven\r\n    //bet type : parity\r\n    //input : 0 for even\r\n    //input : 1 for odd\r\n    function betOnOddEven(bool Odd, bool Even)\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    {\r\n        uint8 count;\r\n        uint8 input;\r\n        if (Even) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Odd) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(BetTypes.parity, input);\r\n    }\r\n\r\n\r\n    //***// function betOnDozen\r\n    //     //bet type : dozen\r\n    //     //input : 0 for first dozen\r\n    //     //input : 1 for second dozen\r\n    //     //input : 2 for third dozen\r\n    function betOnDozen(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\r\n    }\r\n\r\n\r\n    // //***// function betOnColumn\r\n    //     //bet type : column\r\n    //     //input : 0 for first column\r\n    //     //input : 1 for second column\r\n    //     //input : 2 for third column\r\n    function betOnColumn(bool First, bool Second, bool Third)\r\n    {\r\n        betOnColumnOrDozen(First, Second, Third, BetTypes.column);\r\n    }\r\n\r\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\r\n    onlyActive\r\n    checkNbBetsCurrentBlock\r\n    { \r\n        uint8 count;\r\n        uint8 input;\r\n        if (First) \r\n        { \r\n            count+=1; \r\n            input=0;\r\n        }\r\n        if (Second) \r\n        {\r\n            count+=1; \r\n            input=1;\r\n        }\r\n        if (Third) \r\n        {\r\n            count+=1; \r\n            input=2;\r\n        }\r\n        if (count!=1) throw;\r\n        placeBet(bet, input);\r\n    }\r\n\r\n\r\n    //**********************************************\r\n    // Spin The Wheel & Check Result FUNCTIONS//\r\n    //**********************************************\r\n\r\n    event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n    event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId);\r\n\r\n    //***//function to spin callable\r\n    // no eth allowed\r\n    function spinTheWheel(address spin_for_player)\r\n    noEthSent\r\n    {\r\n        SpinTheWheel(spin_for_player);\r\n    }\r\n\r\n\r\n    function SpinTheWheel(address playerSpinned) private\r\n    {\r\n        if (playerSpinned==0)\r\n\t{\r\n\t    playerSpinned=msg.sender;         //if no index spins for the sender\r\n\t}\r\n\r\n\t//check that player has to spin\r\n        if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\r\n        //redundent double check : check that gamble has not been spinned already\r\n        if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\r\n        //check that the player waited for the delay before spin\r\n        //and also that the bet is not expired\r\n\tuint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\r\n        //too early to spin\r\n\tif (block.number<=playerblock+blockDelay) throw;\r\n        //too late, bet expired, player lost\r\n        else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\r\n\t//spin !\r\n        else\r\n\t{\r\n\t    uint8 wheelResult;\r\n            //Spin the wheel, \r\n            bytes32 blockHash= block.blockhash(playerblock+blockDelay);\r\n            //security check that the Hash is not empty\r\n            if (blockHash==0) throw;\r\n\t    // generate the hash for RNG from the blockHash and the player's address\r\n            bytes32 shaPlayer = sha3(playerSpinned, blockHash);\r\n\t    // get the final wheel result\r\n\t    wheelResult = uint8(uint256(shaPlayer)%37);\r\n            //check result against bet and pay if win\r\n\t    checkBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\r\n\t}\r\n    }\r\n    \r\n\r\n    //CHECK BETS FUNCTIONS private\r\n    function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        BetTypes betType=gambles[gambleIndex[player]].betType;\r\n        //bet on Number\r\n        if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\r\n\telse if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\r\n        else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\r\n        updateMaxBet();  //at the end, update the Max possible bet\r\n    }\r\n\r\n    // function solve Bet once result is determined : sends to winner, adds loss to profit\r\n    function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        //Update status and record spinned\r\n        playerStatus[player]=Status.waitingForBet;\r\n        gambles[gambleIndex[player]].wheelResult=result;\r\n        gambles[gambleIndex[player]].spinned=true;\r\n        gambles[gambleIndex[player]].blockSpinned=block.number;\r\n\tuint bet_v = gambles[gambleIndex[player]].wager;\r\n\t\r\n        if (win)\r\n        {\r\n\t    gambles[gambleIndex[player]].win=true;\r\n\t    uint win_v = (multiplier-1)*bet_v;\r\n            lossSinceChange+=win_v;\r\n            Win(player, result, win_v, blockHash, shaPlayer, gambleIndex[player]);\r\n            //send win!\r\n\t    //safe send vs potential callstack overflowed spins\r\n            if (player.send(win_v+bet_v)==false) throw;\r\n        }\r\n        else\r\n        {\r\n\t    Loss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player]);\r\n            profitSinceChange+=bet_v-1;\r\n            //send 1 wei to confirm spin if loss\r\n            if (player.send(1)==false) throw;\r\n        }\r\n\r\n    }\r\n\r\n    // checkbeton number(input)\r\n    // bet type : number\r\n    // input : chosen number\r\n    function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result==gambles[gambleIndex[player]].input)\r\n\t{\r\n            win=true;  \r\n        }\r\n        solveBet(player, result,win,36, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    // checkbet on oddeven\r\n    // bet type : parity\r\n    // input : 0 for even, 1 for odd\r\n    function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result%2==gambles[gambleIndex[player]].input && result!=0)\r\n\t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n    \r\n    // checkbet on lowhigh\r\n    // bet type : lowhigh\r\n    // input : 0 low, 1 high\r\n    function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n\tif (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\r\n\t\t\t   || (result>18 && gambles[gambleIndex[player]].input==1)\r\n\t\t\t ) )\r\n\t{\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on color\r\n    // bet type : color\r\n    // input : 0 red, 1 black\r\n    uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\r\n    function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool red;\r\n        //check if red\r\n        for (uint8 k; k<18; k++)\r\n        { \r\n            if (red_list[k]==result) \r\n            { \r\n                red=true; \r\n                break;\r\n            }\r\n        }\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && red)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,2, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on dozen\r\n    // bet type : dozen\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    { \r\n        bool win;\r\n        //win on first dozen\r\n     \tif ( result!=0 &&\r\n             ( (result<13 && gambles[gambleIndex[player]].input==0)\r\n     \t       ||\r\n               (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\r\n               ||\r\n               (result>24 && gambles[gambleIndex[player]].input==2) ) )\r\n     \t{\r\n            win=true;                \r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n    // checkbet on column\r\n    // bet type : column\r\n    // input : 0 first, 1 second, 2 third\r\n    function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\r\n    {\r\n        bool win;\r\n        //win\r\n        if ( result!=0\r\n             && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \r\n                  || ( gambles[gambleIndex[player]].input==1 && result%3==2)\r\n                  || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\r\n        {\r\n            win=true;\r\n        }\r\n        solveBet(player,result,win,3, blockHash, shaPlayer);\r\n    }\r\n\r\n\r\n    //D.A.O. FUNCTIONS\r\n\r\n\r\n    //total casino payroll\r\n    uint256 payroll;\r\n    //Profit Loss since last investor change\r\n    uint256 profitSinceChange;\r\n    uint256 lossSinceChange;\r\n    //DAO members struct array (hard capped to 777 members (77 VIP + 700 extra members) )\r\n    struct Investor\r\n    {\r\n\taddress investor;\r\n\tuint256 time;\r\n    }\t\r\n    \r\n    Investor[777] private investors; //array of 777 elements (max Rouleth's members nb.)\r\n    uint16 setting_maxInvestors = 77; //Initially restricted to 77 VIP Members\r\n    //Balances of the DAO members\r\n    mapping (address=>uint256) balance; \r\n    //lockPeriod\r\n    //minimum membership time\r\n    uint256 setting_lockPeriod=30 days ;\r\n    uint256 setting_minInvestment=100 ether; //min amount to send when using \"invest()\"\r\n    uint256 setting_maxInvestment=200 ether; //max amount to send when using \"invest()\"\r\n    \r\n    event newInvest(address player, uint invest_v, uint net_invest_v);\r\n\r\n\r\n    //Become a DAO member.\r\n    function invest()\r\n    {\r\n        // update balances before altering the shares            \r\n        updateBalances();\r\n        uint256 netInvest;\r\n        uint excess;\r\n        // reset the open position counter to values out of bounds\r\n        // =999 if full\r\n        uint16 openPosition=999;\r\n        bool alreadyInvestor;\r\n        // loop over array to find if already member, \r\n        // and record a potential openPosition\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        { \r\n            // captures an index of an open position\r\n            if (investors[k].investor==0) openPosition=k; \r\n            // captures if already a member \r\n            else if (investors[k].investor==msg.sender)\r\n            {\r\n                alreadyInvestor=true;\r\n                break;\r\n            }\r\n        }\r\n        //new Member\r\n        if (!alreadyInvestor)\r\n        {\r\n            // check that more than min is sent (variable setting)\r\n            if (msg.value<setting_minInvestment) throw;\r\n            // check that less than max is sent (variable setting)\r\n            // otherwise refund\r\n            if (msg.value>setting_maxInvestment)\r\n            {\r\n                excess=msg.value-setting_maxInvestment;\r\n  \t\tnetInvest=setting_maxInvestment;\r\n            }\r\n\t    else\r\n\t    {\r\n\t\tnetInvest=msg.value;\r\n\t    }\r\n            //members can't become a VIP member after the initial period\r\n            if (setting_maxInvestors >77 && openPosition<77) throw;\r\n            //case : array not full, record new member\r\n            else if (openPosition!=999) investors[openPosition]=Investor(msg.sender, now);\r\n            //case : array full\r\n            else\r\n            {\r\n                throw;\r\n            }\r\n        }\r\n        //already a member\r\n        else\r\n        {\r\n            netInvest=msg.value;\r\n            //is already above the max balance allowed or is sending\r\n\t    // too much refuse additional invest\r\n            if (balance[msg.sender]+msg.value>setting_maxInvestment)\r\n            {\r\n                throw;\r\n            }\r\n\t    // this additionnal amount should be of at least 1/5 of \"setting_minInvestment\" (vs spam)\r\n\t    if (msg.value<setting_minInvestment/5) throw;\r\n        }\r\n\r\n        // add to balance of member and to bankroll\r\n        // 10% of initial 77 VIP members investment is allocated to\r\n        // game developement provider chosen by Rouleth DAO\r\n\t// 90% to bankroll\r\n        //share that will be allocated to game dev\r\n        uint256 developmentAllocation;\r\n        developmentAllocation=10*netInvest/100; \r\n        netInvest-=developmentAllocation;\r\n        //send game development allocation to Rouleth DAO or tech provider\r\n        if (developer.send(developmentAllocation)==false) throw;\r\n\r\n\t// Apply extra entry fee once casino has been opened to extra members\r\n\t// that fee will be shared between the VIP members and represents the increment of\r\n\t// market value of their shares in Rouleth to outsiders\r\n\t// warning if a VIP adds to its initial invest after the casino has been opened to \r\n\t// extra members he will pay have to pay this fee.\r\n        if (setting_maxInvestors>77)\r\n        {\r\n            // % of extra member's investment that rewards VIP funders\r\n            // Starts at 100%\r\n            // is set by a vote and computed when settings are changed\r\n            // to allow more investors\r\n            uint256 entryExtraCost=voted_extraInvestFeesRate*netInvest/100;\r\n            // add to VIP profit (to be shared by later call by dev.)\r\n            profitVIP += entryExtraCost;\r\n            netInvest-=entryExtraCost;\r\n        }\r\n        newInvest(msg.sender, msg.value, netInvest);//event log\r\n        balance[msg.sender]+=netInvest; //add to balance\r\n        payroll+=netInvest; //add to bankroll\r\n        updateMaxBet();\r\n        //refund potential excess\r\n        if (excess>0) \r\n        {\r\n            if (msg.sender.send(excess)==false) throw;\r\n        }\r\n    }\r\n\r\n\r\n    //Allows to transfer your DAO account to another address\r\n    //target should not be currently a DAO member of rouleth\r\n    //enter twice the address to make sure you make no mistake.\r\n    //this can't be reversed if you don't own the target account\r\n    function transferInvestorAccount(address newInvestorAccountOwner, address newInvestorAccountOwner_confirm)\r\n    noEthSent\r\n    {\r\n        if (newInvestorAccountOwner!=newInvestorAccountOwner_confirm) throw;\r\n        if (newInvestorAccountOwner==0) throw;\r\n        //retrieve investor ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n\t    //new address cant be of a current investor\r\n            if (investors[k].investor==newInvestorAccountOwner) throw;\r\n\r\n\t    //retrieve investor id\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n\telse\r\n\t    //accept and execute change of address\r\n\t    //votes on entryFeesRate are not transfered\r\n\t    //new address should vote again\r\n\t{\r\n\t    balance[newInvestorAccountOwner]=balance[msg.sender];\r\n\t    balance[msg.sender]=0;\r\n            investors[investorID].investor=newInvestorAccountOwner;\r\n\t}\r\n    }\r\n    \r\n    //***// Withdraw function (only after lockPeriod)\r\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\r\n    // if your withdraw brings your balance under the min required,\r\n    // your balance is fully withdrawn\r\n    event withdraw(address player, uint withdraw_v);\r\n    \r\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\r\n    noEthSent\r\n    {\r\n\t//vs spam withdraw min 1/10 of min\r\n\tif (amountToWithdrawInWei!=0 && amountToWithdrawInWei<setting_minInvestment/10) throw;\r\n        //before withdraw, update balances with the Profit and Loss sinceChange\r\n        updateBalances();\r\n\t//check that amount requested is authorized  \r\n\tif (amountToWithdrawInWei>balance[msg.sender]) throw;\r\n        //retrieve member ID\r\n        uint16 investorID=999;\r\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\r\n        {\r\n            if (investors[k].investor==msg.sender)\r\n            {\r\n                investorID=k;\r\n                break;\r\n            }\r\n        }\r\n        if (investorID==999) throw; //stop if not a member\r\n        //check if investment lock period is over\r\n        if (investors[investorID].time+setting_lockPeriod>now) throw;\r\n        //if balance left after withdraw is still above min accept partial withdraw\r\n        if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\r\n        {\r\n            balance[msg.sender]-=amountToWithdrawInWei;\r\n            payroll-=amountToWithdrawInWei;\r\n            //send amount to investor (with security if transaction fails)\r\n            if (msg.sender.send(amountToWithdrawInWei)==false) throw;\r\n\t    withdraw(msg.sender, amountToWithdrawInWei);\r\n        }\r\n        else\r\n            //if amountToWithdraw=0 : user wants full withdraw\r\n            //if balance after withdraw is < min invest, withdraw all and delete member\r\n        {\r\n            //send amount to member (with security if transaction fails)\r\n            uint256 fullAmount=balance[msg.sender];\r\n            payroll-=fullAmount;\r\n            balance[msg.sender]=0;\r\n\r\n\t    //delete member\r\n            delete investors[investorID];\r\n            if (msg.sender.send(fullAmount)==false) throw;\r\n   \t    withdraw(msg.sender, fullAmount);\r\n        }\r\n        updateMaxBet();\r\n    }\r\n\r\n    //***// updates balances with Profit Losses when there is a withdraw/deposit\r\n    // can be called by dev for accounting when there are no more changes\r\n    function manualUpdateBalances_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n\tupdateBalances();\r\n    }\r\n    function updateBalances() private\r\n    {\r\n        //split Profits\r\n        uint256 profitToSplit;\r\n        uint256 lossToSplit;\r\n        if (profitSinceChange==0 && lossSinceChange==0)\r\n        { return; }\r\n        \r\n        else\r\n        {\r\n            // Case : Global profit (more win than losses)\r\n            // 20% fees for game development on global profit (if profit>loss)\r\n            if (profitSinceChange>lossSinceChange)\r\n            {\r\n                profitToSplit=profitSinceChange-lossSinceChange;\r\n                uint256 developerFees=profitToSplit*20/100;\r\n                profitToSplit-=developerFees;\r\n                if (developer.send(developerFees)==false) throw;\r\n            }\r\n            else\r\n            {\r\n                lossToSplit=lossSinceChange-profitSinceChange;\r\n            }\r\n            \r\n            //share the loss and profits between all DAO members \r\n            //(proportionnaly. to each one's balance)\r\n\r\n            uint totalShared;\r\n            for (uint16 k=0; k<setting_maxInvestors; k++)\r\n            {\r\n                address inv=investors[k].investor;\r\n                if (inv==0) continue;\r\n                else\r\n                {\r\n                    if (profitToSplit!=0) \r\n                    {\r\n                        uint profitShare=(profitToSplit*balance[inv])/payroll;\r\n                        balance[inv]+=profitShare;\r\n                        totalShared+=profitShare;\r\n                    }\r\n                    else if (lossToSplit!=0) \r\n                    {\r\n                        uint lossShare=(lossToSplit*balance[inv])/payroll;\r\n                        balance[inv]-=lossShare;\r\n                        totalShared+=lossShare;\r\n                        \r\n                    }\r\n                }\r\n            }\r\n            // update bankroll\r\n\t    // and handle potential very small left overs from integer div.\r\n            if (profitToSplit !=0) \r\n            {\r\n\t\tpayroll+=profitToSplit;\r\n\t\tbalance[developer]+=profitToSplit-totalShared;\r\n            }\r\n            else if (lossToSplit !=0) \r\n            {\r\n\t\tpayroll-=lossToSplit;\r\n\t\tbalance[developer]-=lossToSplit-totalShared;\r\n            }\r\n            profitSinceChange=0; //reset Profit;\r\n            lossSinceChange=0; //reset Loss ;\r\n        }\r\n    }\r\n    \r\n\r\n    //VIP Voting on Extra Invest Fees Rate\r\n    //mapping records 100 - vote\r\n    mapping (address=>uint) hundredminus_extraInvestFeesRate;\r\n    // max fee is 99%\r\n    // a fee of 100% indicates that the VIP has never voted.\r\n    function voteOnNewEntryFees_only_VIP(uint8 extraInvestFeesRate_0_to_99)\r\n    noEthSent\r\n    {\r\n        if (extraInvestFeesRate_0_to_99<1 || extraInvestFeesRate_0_to_99>99) throw;\r\n        hundredminus_extraInvestFeesRate[msg.sender]=100-extraInvestFeesRate_0_to_99;\r\n    }\r\n\r\n    uint256 payrollVIP;\r\n    uint256 voted_extraInvestFeesRate;\r\n    function computeResultVoteExtraInvestFeesRate() private\r\n    {\r\n        payrollVIP=0;\r\n        voted_extraInvestFeesRate=0;\r\n        //compute total payroll of the VIPs\r\n        //compute vote results among VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                //don't count vote if the VIP never voted\r\n                if (hundredminus_extraInvestFeesRate[investors[k].investor]==0) continue;\r\n                else\r\n                {\r\n                    payrollVIP+=balance[investors[k].investor];\r\n                    voted_extraInvestFeesRate+=hundredminus_extraInvestFeesRate[investors[k].investor]*balance[investors[k].investor];\r\n                }\r\n            }\r\n        }\r\n\t//compute final result\r\n\t    if (payrollVIP!=0)\r\n\t    {\r\n            voted_extraInvestFeesRate=100-voted_extraInvestFeesRate/payrollVIP;\r\n     \t    }\r\n    }\r\n\r\n\r\n    //Split the profits of the VIP members on extra members' contribution\r\n    uint profitVIP;\r\n    function splitProfitVIP_only_Dev()\r\n    noEthSent\r\n    onlyDeveloper\r\n    {\r\n        payrollVIP=0;\r\n        //compute total payroll of the VIPs\r\n        for (uint8 k=0; k<77; k++)\r\n        {\r\n            if (investors[k].investor==0) continue;\r\n            else\r\n            {\r\n                payrollVIP+=balance[investors[k].investor];\r\n            }\r\n        }\r\n        //split the profits of the VIP members on extra member's contribution\r\n\tuint totalSplit;\r\n        for (uint8 i=0; i<77; i++)\r\n        {\r\n            if (investors[i].investor==0) continue;\r\n            else\r\n            {\r\n\t\tuint toSplit=balance[investors[i].investor]*profitVIP/payrollVIP;\r\n                balance[investors[i].investor]+=toSplit;\r\n\t\ttotalSplit+=toSplit;\r\n            }\r\n        }\r\n\t//take care of Integer Div remainders, and add to bankroll\r\n\tbalance[developer]+=profitVIP-totalSplit;\r\n\tpayroll+=profitVIP;\r\n\t//reset var profitVIP\r\n        profitVIP=0;\r\n    }\r\n\r\n    \r\n    //INFORMATION FUNCTIONS\r\n    function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances, uint profit_VIP_since_update_balances)\r\n    {\r\n        profit_since_update_balances=profitSinceChange;\r\n        loss_since_update_balances=lossSinceChange;\r\n        profit_VIP_since_update_balances=profitVIP;\t\r\n        return;\r\n    }\r\n\r\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\r\n    {\r\n        balanceInWei=balance[investor];\r\n        return;\r\n    }\r\n\r\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\r\n    {\r\n        investor=investors[index].investor;\r\n        endLockPeriod=investors[index].time+setting_lockPeriod;\r\n        return;\r\n    }\r\n    \r\n    function investmentEntryInfos() constant returns(uint current_max_nb_of_investors, uint investLockPeriod, uint voted_Fees_Rate_on_extra_investments)\r\n    {\r\n    \tinvestLockPeriod=setting_lockPeriod;\r\n    \tvoted_Fees_Rate_on_extra_investments=voted_extraInvestFeesRate;\r\n    \tcurrent_max_nb_of_investors=setting_maxInvestors;\r\n    \treturn;\r\n    }\r\n    \r\n    function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\r\n    {\r\n    \tmaxBet=currentMaxGamble;\r\n    \tblockDelayBeforeSpin=blockDelay;\r\n    \treturn ;\r\n    }\r\n\r\n    function getTotalGambles() constant returns(uint _totalGambles)\r\n    {\r\n        _totalGambles=totalGambles;\r\n    \treturn ;\r\n    }\r\n    \r\n    function getPayroll() constant returns(uint payroll_at_last_update_balances)\r\n    {\r\n        payroll_at_last_update_balances=payroll;\r\n    \treturn ;\r\n    }\r\n\r\n    \r\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\r\n    {\r\n        player_status=playerStatus[player];\r\n        bettype=gambles[gambleIndex[player]].betType;\r\n        input=gambles[gambleIndex[player]].input;\r\n        value=gambles[gambleIndex[player]].wager;\r\n        result=gambles[gambleIndex[player]].wheelResult;\r\n        wheelspinned=gambles[gambleIndex[player]].spinned;\r\n        win=gambles[gambleIndex[player]].win;\r\n        blockNb=gambles[gambleIndex[player]].blockNumber;\r\n        blockSpin=gambles[gambleIndex[player]].blockSpinned;\r\n    \tgambleID=gambleIndex[player];\r\n    \treturn;\r\n    }\r\n    \r\n    function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\r\n    {\r\n        player=gambles[index].player;\r\n        bettype=gambles[index].betType;\r\n        input=gambles[index].input;\r\n        value=gambles[index].wager;\r\n        result=gambles[index].wheelResult;\r\n        wheelspinned=gambles[index].spinned;\r\n        win=gambles[index].win;\r\n    \tblockNb=gambles[index].blockNumber;\r\n        blockSpin=gambles[index].blockSpinned;\r\n    \treturn;\r\n    }\r\n\r\n} //end of contract", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setNickname\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToWithdrawInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawInvestment\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"manualUpdateBalances_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkProfitLossSinceInvestorChange\",\"outputs\":[{\"name\":\"profit_since_update_balances\",\"type\":\"uint256\"},{\"name\":\"loss_since_update_balances\",\"type\":\"uint256\"},{\"name\":\"profit_VIP_since_update_balances\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"extraInvestFeesRate_0_to_99\",\"type\":\"uint8\"}],\"name\":\"voteOnNewEntryFees_only_VIP\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newInvestorAccountOwner\",\"type\":\"address\"},{\"name\":\"newInvestorAccountOwner_confirm\",\"type\":\"address\"}],\"name\":\"transferInvestorAccount\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalGambles\",\"outputs\":[{\"name\":\"_totalGambles\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBetting_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Red\",\"type\":\"bool\"},{\"name\":\"Black\",\"type\":\"bool\"}],\"name\":\"betOnColor\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentEntryInfos\",\"outputs\":[{\"name\":\"current_max_nb_of_investors\",\"type\":\"uint256\"},{\"name\":\"investLockPeriod\",\"type\":\"uint256\"},{\"name\":\"voted_Fees_Rate_on_extra_investments\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkMyBet\",\"outputs\":[{\"name\":\"player_status\",\"type\":\"uint8\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"},{\"name\":\"gambleID\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorList\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"endLockPeriod\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBetting_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_dev\",\"type\":\"address\"}],\"name\":\"changeDeveloper_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"blockDelayBeforeSpin\",\"type\":\"uint8\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPayroll\",\"outputs\":[{\"name\":\"payroll_at_last_update_balances\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getNickname\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Low\",\"type\":\"bool\"},{\"name\":\"High\",\"type\":\"bool\"}],\"name\":\"betOnLowHigh\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numberChosen\",\"type\":\"uint8\"}],\"name\":\"betOnNumber\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"Odd\",\"type\":\"bool\"},{\"name\":\"Even\",\"type\":\"bool\"}],\"name\":\"betOnOddEven\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"splitProfitVIP_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGamblesList\",\"outputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"bettype\",\"type\":\"uint8\"},{\"name\":\"input\",\"type\":\"uint8\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"wheelspinned\",\"type\":\"bool\"},{\"name\":\"win\",\"type\":\"bool\"},{\"name\":\"blockNb\",\"type\":\"uint256\"},{\"name\":\"blockSpin\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnDozen\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCasinoStatLimit\",\"type\":\"uint256\"},{\"name\":\"newMaxBetsBlock\",\"type\":\"uint256\"},{\"name\":\"newMinGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxGamble\",\"type\":\"uint256\"},{\"name\":\"newMaxInvestor\",\"type\":\"uint16\"},{\"name\":\"newMinInvestment\",\"type\":\"uint256\"},{\"name\":\"newMaxInvestment\",\"type\":\"uint256\"},{\"name\":\"newLockPeriod\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"},{\"name\":\"newBlockExpiration\",\"type\":\"uint8\"}],\"name\":\"changeSettings_only_Dev\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"First\",\"type\":\"bool\"},{\"name\":\"Second\",\"type\":\"bool\"},{\"name\":\"Third\",\"type\":\"bool\"}],\"name\":\"betOnColumn\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spin_for_player\",\"type\":\"address\"}],\"name\":\"spinTheWheel\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"checkInvestorBalance\",\"outputs\":[{\"name\":\"balanceInWei\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_won\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"}],\"name\":\"Win\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value_loss\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sha3Player\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"}],\"name\":\"Loss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invest_v\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"net_invest_v\",\"type\":\"uint256\"}],\"name\":\"newInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdraw_v\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"type\":\"event\"}]", "ContractName": "Rouleth", "CompilerVersion": "v0.3.5-2016-07-01-48238c9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}