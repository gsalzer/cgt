{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.4;\r\n\r\ncontract Reward{\r\n    \r\n    function reward(uint32[] rewardsDistribution, address[] winners) payable{\r\n        \r\n        if(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward\r\n\t\t\tthrow;\r\n\t\t}\r\n\t\t//ensure rewardsDistribution give always something and do not give more to a lower scoring player\r\n\t\tuint32 prev = 0;\r\n\t\tfor(uint8 i = 0; i < rewardsDistribution.length; i++){\r\n\t\t\tif(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){\r\n\t\t\t\tthrow;\r\n\t\t\t}\r\n\t\t\tprev = rewardsDistribution[i];\r\n\t\t}\r\n\t\t\r\n        uint8 numWinners = uint8(rewardsDistribution.length);\r\n\r\n\t\tif(numWinners > uint8(winners.length)){\r\n\t\t\tnumWinners = uint8(winners.length);\r\n\t\t}\r\n\t\t\r\n        uint forJack = msg.value;\r\n\t\tuint64 total = 0;\r\n\t\tfor(uint8 j=0; j<numWinners; j++){ // distribute all the winning even if there is not enought winners\r\n\t\t\ttotal += rewardsDistribution[j];\r\n\t\t}\r\n\t\tfor(uint8 k=0; k<numWinners; k++){\r\n\t\t\tuint value = (msg.value * rewardsDistribution[k]) / total;\r\n\t\t\tif(winners[k].send(value)){ // skip winner if fail to send but still use next distribution index\r\n\t\t\t\tforJack = forJack - value;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(forJack > 0){\r\n\t\t    if(!msg.sender.send(forJack)){\r\n\t\t        throw;\r\n\t\t    } \r\n\t\t}\r\n\t\t\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"rewardsDistribution\",\"type\":\"uint32[]\"},{\"name\":\"winners\",\"type\":\"address[]\"}],\"name\":\"reward\",\"outputs\":[],\"payable\":true,\"type\":\"function\"}]", "ContractName": "Reward", "CompilerVersion": "v0.4.4+commit.4633f3de", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}