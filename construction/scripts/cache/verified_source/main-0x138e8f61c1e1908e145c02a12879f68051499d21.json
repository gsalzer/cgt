{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n/**\r\n *\r\n * @author  <newtwist@protonmail.com>\r\n *\r\n * Version B\r\n *\r\n * Overview:\r\n * This is an implimentation of a `burnable` token. The tokens do not pay any dividends; however if/when tokens\r\n * are `burned`, the burner gets a share of whatever funds the contract owns at that time. No provision is made\r\n * for how tokens are sold; all tokens are initially credited to the contract owner. There is a provision to\r\n * establish a single `restricted` account. The restricted account can own tokens, but cannot transfer them or\r\n * burn them until after a certain date. . There is also a function to burn tokens without getting paid. This is\r\n * useful, for example, if the sale-contract/owner wants to reduce the supply of tokens.\r\n *\r\n */\r\n\r\n/*\r\n    Overflow protected math functions\r\n*/\r\ncontract SafeMath {\r\n    /**\r\n        constructor\r\n    */\r\n    function SafeMath() {\r\n    }\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n\r\n//Burnable Token interface\r\n\r\n// Token standard API\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ncontract iERC20Token {\r\n  function totalSupply() constant returns (uint supply);\r\n  function balanceOf( address who ) constant returns (uint value);\r\n  function allowance( address owner, address spender ) constant returns (uint remaining);\r\n\r\n  function transfer( address to, uint value) returns (bool ok);\r\n  function transferFrom( address from, address to, uint value) returns (bool ok);\r\n  function approve( address spender, uint value ) returns (bool ok);\r\n\r\n  event Transfer( address indexed from, address indexed to, uint value);\r\n  event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract iBurnableToken is iERC20Token {\r\n  function burnTokens(uint _burnCount) public;\r\n  function unPaidBurnTokens(uint _burnCount) public;\r\n}\r\n\r\ncontract BurnableToken is iBurnableToken, SafeMath {\r\n\r\n  event PaymentEvent(address indexed from, uint amount);\r\n  event TransferEvent(address indexed from, address indexed to, uint amount);\r\n  event ApprovalEvent(address indexed from, address indexed to, uint amount);\r\n  event BurnEvent(address indexed from, uint count, uint value);\r\n\r\n  string  public symbol;\r\n  string  public name;\r\n  bool    public isLocked;\r\n  uint    public decimals;\r\n  uint    public restrictUntil;                              //vesting for developer tokens\r\n  uint           tokenSupply;                                //can never be increased; but tokens can be burned\r\n  address public owner;\r\n  address public restrictedAcct;                             //no transfers from this addr during vest time\r\n  mapping (address => uint) balances;\r\n  mapping (address => mapping (address => uint)) approvals;  //transfer approvals, from -> to\r\n\r\n\r\n  modifier ownerOnly {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier unlockedOnly {\r\n    require(!isLocked);\r\n    _;\r\n  }\r\n\r\n  modifier preventRestricted {\r\n    require((msg.sender != restrictedAcct) || (now >= restrictUntil));\r\n    _;\r\n  }\r\n\r\n\r\n  //\r\n  //constructor\r\n  //\r\n  function BurnableToken() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  //\r\n  // ERC-20\r\n  //\r\n\r\n  function totalSupply() public constant returns (uint supply) { supply = tokenSupply; }\r\n\r\n  function transfer(address _to, uint _value) public preventRestricted returns (bool success) {\r\n    //if token supply was not limited then we would prevent wrap:\r\n    //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to])\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      TransferEvent(msg.sender, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n    //if token supply was not limited then we would prevent wrap:\r\n    //if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to])\r\n    if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_from] -= _value;\r\n      balances[_to] += _value;\r\n      approvals[_from][msg.sender] -= _value;\r\n      TransferEvent(_from, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n\r\n  function balanceOf(address _owner) public constant returns (uint balance) {\r\n    balance = balances[_owner];\r\n  }\r\n\r\n\r\n  function approve(address _spender, uint _value) public preventRestricted returns (bool success) {\r\n    approvals[msg.sender][_spender] = _value;\r\n    ApprovalEvent(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n    return approvals[_owner][_spender];\r\n  }\r\n\r\n\r\n  //\r\n  // END ERC20\r\n  //\r\n\r\n\r\n  //\r\n  // default payable function.\r\n  //\r\n  function () payable {\r\n    PaymentEvent(msg.sender, msg.value);\r\n  }\r\n\r\n  function initTokenSupply(uint _tokenSupply) public ownerOnly {\r\n    require(tokenSupply == 0);\r\n    tokenSupply = _tokenSupply;\r\n    balances[owner] = tokenSupply;\r\n  }\r\n\r\n  function setName(string _name, string _symbol, uint _decimals) public ownerOnly {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n\r\n  function lock() public ownerOnly {\r\n    isLocked = true;\r\n  }\r\n\r\n  function setRestrictedAcct(address _restrictedAcct, uint _restrictUntil) public ownerOnly unlockedOnly {\r\n    restrictedAcct = _restrictedAcct;\r\n    restrictUntil = _restrictUntil;\r\n  }\r\n\r\n  function tokenValue() constant public returns (uint value) {\r\n    value = this.balance / tokenSupply;\r\n  }\r\n\r\n  function valueOf(address _owner) constant public returns (uint value) {\r\n    value = this.balance * balances[_owner] / tokenSupply;\r\n  }\r\n\r\n  function burnTokens(uint _burnCount) public preventRestricted {\r\n    if (balances[msg.sender] >= _burnCount && _burnCount > 0) {\r\n      uint _value = this.balance * _burnCount / tokenSupply;\r\n      tokenSupply -= _burnCount;\r\n      balances[msg.sender] -= _burnCount;\r\n      msg.sender.transfer(_value);\r\n      BurnEvent(msg.sender, _burnCount, _value);\r\n    }\r\n  }\r\n\r\n  function unPaidBurnTokens(uint _burnCount) public preventRestricted {\r\n    if (balances[msg.sender] >= _burnCount && _burnCount > 0) {\r\n      tokenSupply -= _burnCount;\r\n      balances[msg.sender] -= _burnCount;\r\n      BurnEvent(msg.sender, _burnCount, 0);\r\n    }\r\n  }\r\n\r\n  //for debug\r\n  //only available before the contract is locked\r\n  function haraKiri() ownerOnly unlockedOnly {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnCount\",\"type\":\"uint256\"}],\"name\":\"unPaidBurnTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenValue\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_burnCount\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"valueOf\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"haraKiri\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restrictedAcct\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_restrictedAcct\",\"type\":\"address\"},{\"name\":\"_restrictUntil\",\"type\":\"uint256\"}],\"name\":\"setRestrictedAcct\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenSupply\",\"type\":\"uint256\"}],\"name\":\"initTokenSupply\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApprovalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BurnEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "BurnableToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://c1d23cb271efece41c0ba0b1bfce447d1f6d52e7f61fdd1a3ed047f3f2946e23"}]}