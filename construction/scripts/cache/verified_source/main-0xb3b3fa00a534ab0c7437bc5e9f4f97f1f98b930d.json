{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n\r\ncontract Coinevents {\r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    event onBuy (\r\n        address playerAddress,\r\n        uint256 begin,\r\n        uint256 end,\r\n        uint256 round,\r\n        bytes32 playerName\r\n    );\r\n    // fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    // settle the contract\r\n    event onSettle(\r\n        uint256 rid,\r\n        uint256 ticketsout,\r\n        address winner,\r\n        uint256 luckynum,\r\n        uint256 jackpot\r\n    );\r\n    // settle the contract\r\n    event onActivate(\r\n        uint256 rid\r\n    );\r\n}\r\n\r\n\r\ncontract LuckyCoin is Coinevents{\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    \r\n    //**************** game settings ****************\r\n     string constant public name = \"LuckyCoin Super\";\r\n     string constant public symbol = \"LuckyCoin\";\r\n     uint256 constant private rndGap_ = 2 hours;                // round timer starts at this\r\n     //uint256 constant private rndGap_ = 5 minutes;\r\n\r\n     uint256 ticketstotal_ = 1500;       // ticket total amonuts\r\n     uint256 grouptotal_ = 250;    // ticketstotal_ divend to six parts\r\n     //uint ticketprice_ = 0.005 ether;   // current ticket init price\r\n     uint256 jackpot = 10 ether;\r\n     uint256 public rID_= 0;      // current round id number / total rounds that have happened\r\n     uint256 _headtickets = 500;  // head of 500, distributes valuet\r\n     bool public activated_ = false;\r\n     \r\n     //address community_addr = 0x2b5006d3dce09dafec33bfd08ebec9327f1612d8;    // community addr\r\n     //address prize_addr = 0x2b5006d3dce09dafec33bfd08ebec9327f1612d8;        // prize addr\r\n \r\n     \r\n     address community_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E;    // community addr\r\n     address prize_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E;        // prize addr\r\n     address activate_addr2 = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E;    // activate addr2\r\n     address activate_addr1 = 0x6C7DFE3c255a098Ea031f334436DD50345cFC737;    // activate addr1\r\n     PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xc87a693dbba31aefb9457683b7d245dad756db88);\r\n\r\n    //**************** ROUND DATA ****************\r\n    mapping (uint256 => Coindatasets.Round) public round_;   // (rID => data) round data\r\n    \r\n    //**************** PLAYER DATA ****************\r\n    event LogbuyNums(address addr, uint begin, uint end);\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => Coindatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own)\r\n    \r\n    //**************** ORDER DATA ****************\r\n    mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders;  // (rid=>pid=group=>ticketnum)\r\n    \r\n    constructor() public{\r\n        //round_[rID_].jackpot = 10 ether;\r\n    }\r\n    \r\n    // callback function\r\n    function ()\r\n        payable\r\n    {\r\n        // fllows addresses only can activate the game\r\n        if (\r\n            msg.sender == activate_addr2 || msg.sender == activate_addr1\r\n        ){\r\n           activate();\r\n        }else if(msg.value > 0){ //bet order\r\n            // fetch player id\r\n            address _addr = msg.sender;\r\n            uint256 _codeLength;\r\n            require(tx.origin == msg.sender, \"sorry humans only origin\");\r\n            assembly {_codeLength := extcodesize(_addr)}\r\n            require(_codeLength == 0, \"sorry humans only=================\");\r\n\r\n            determinePID();\r\n            uint256 _pID = pIDxAddr_[msg.sender];\r\n            uint256 _ticketprice = getBuyPrice();\r\n            require(_ticketprice > 0);\r\n            uint256 _tickets = msg.value / _ticketprice;\r\n            require(_tickets > 0);\r\n            // buy tickets\r\n            require(activated_ == true, \"its not ready yet.  contact administrators\");\r\n            require(_tickets <= ticketstotal_ - round_[rID_].tickets);\r\n            buyTicket(_pID, plyr_[_pID].laff, _tickets);\r\n        }\r\n\r\n    }\r\n\r\n    //  purchase value limit   \r\n    modifier isWithinLimits(uint256 _eth, uint256 _tickets) {\r\n        uint256 _ticketprice = getBuyPrice();\r\n        require(_eth >= _tickets * _ticketprice);\r\n        require(_eth <= 100000000000000000000000);\r\n        _;    \r\n    }\r\n    \r\n    modifier isTicketsLimits(uint256 _tickets){\r\n        require(_tickets <= ticketstotal_ - round_[rID_].tickets);\r\n        _;\r\n    }\r\n    \r\n    modifier isActivated(){\r\n        require(activated_, \"not activate\");\r\n        _;\r\n    }\r\n    \r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        require(tx.origin == msg.sender, \"sorry humans only origin\");\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only=================\");\r\n        _;\r\n    }\r\n    \r\n    function buyXid(uint _tickets, uint256 _affCode)\r\n          isHuman()\r\n          isWithinLimits(msg.value, _tickets)\r\n          isTicketsLimits(_tickets)\r\n          isActivated\r\n          public \r\n          payable\r\n    {\r\n       // set up our tx event data and determine if player is new or not\r\n        //Coindatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        determinePID();\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == 0 || _affCode == _pID)\r\n        {\r\n            // use last stored affiliate code \r\n            _affCode = plyr_[_pID].laff;\r\n            \r\n        // if affiliate code was given & its not the same as previously stored \r\n        } else if (_affCode != plyr_[_pID].laff) {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        \r\n        buyTicket(_pID, _affCode, _tickets);      \r\n    }\r\n    \r\n    function buyXaddr(uint _tickets, address _affCode) \r\n          isHuman()\r\n          isWithinLimits(msg.value, _tickets)\r\n          isTicketsLimits(_tickets)\r\n          isActivated\r\n          public \r\n          payable \r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        //Coindatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        // determine if player is new or not\r\n        determinePID();\r\n        \r\n        uint256 _affID;\r\n         \r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender]; \r\n        \r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        buyTicket(_pID, _affID, _tickets);\r\n    }\r\n    \r\n    function buyXname(uint _tickets, bytes32 _affCode)\r\n          isHuman()\r\n          isWithinLimits(msg.value, _tickets)\r\n          isTicketsLimits(_tickets)\r\n          isActivated\r\n          public \r\n          payable\r\n    {\r\n        // set up our tx event data and determine if player is new or not\r\n        //Coindatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        determinePID();\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = plyr_[_pID].laff;\r\n        \r\n        // if affiliate code was given\r\n        } else {\r\n            // get affiliate ID from aff Code\r\n            _affID = pIDxName_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored\r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        buyTicket(_pID, _affID, _tickets);\r\n    }\r\n    \r\n    function reLoadXaddr(uint256 _tickets, address _affCode)\r\n        isHuman()\r\n        isActivated\r\n        isTicketsLimits(_tickets)\r\n        public\r\n    {\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == address(0) || _affCode == msg.sender){\r\n            _affID = plyr_[_pID].laff;\r\n        }\r\n        else{\r\n           // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        reloadTickets(_pID, _affID, _tickets);\r\n    }\r\n    \r\n        \r\n    function reLoadXname(uint256 _tickets, bytes32 _affCode)\r\n        isHuman()\r\n        isActivated\r\n        isTicketsLimits(_tickets)\r\n        public\r\n    {\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name){\r\n            _affID = plyr_[_pID].laff;\r\n        }\r\n        else{\r\n           // get affiliate ID from aff Code \r\n             _affID = pIDxName_[_affCode];\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        reloadTickets(_pID, _affID, _tickets);\r\n    }\r\n    \r\n    function reloadTickets(uint256 _pID, uint256 _affID, uint256 _tickets)\r\n        isActivated\r\n        private\r\n    {\r\n        //************** ******************\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        // grab time\r\n        uint256 _now = now;\r\n        // if round is active\r\n        if (_now > round_[_rID].start && _now < round_[_rID].end && round_[_rID].ended == false){\r\n            // call ticket\r\n            uint256 _eth = getBuyPrice().mul(_tickets);\r\n            \r\n            //plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            reloadEarnings(_pID, _eth);\r\n            \r\n            ticket(_pID, _rID, _tickets, _affID, _eth);\r\n            if (round_[_rID].tickets == ticketstotal_){\r\n                round_[_rID].ended = true;\r\n                round_[_rID].end = now;\r\n                endRound();\r\n            }\r\n            \r\n        }else if (_now > round_[_rID].end && round_[_rID].ended == false){\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            //endRound();\r\n            bool autopurchase = endRound();\r\n            // put eth in players vault\r\n            if (autopurchase){\r\n                ticket(_pID, rID_, _tickets, _affID, msg.value);\r\n            }else{\r\n                plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function withdraw() \r\n        isHuman()\r\n        public\r\n    {\r\n        // setup local rID \r\n        //uint256 _rID = rID_;\r\n        // grab time\r\n        uint256 _now = now;\r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        // check to see if round has ended and no one has run round end yet\r\n        \r\n        _eth = withdrawEarnings(_pID);\r\n        if (_eth > 0){\r\n            plyr_[_pID].addr.transfer(_eth);\r\n            emit Coinevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n\r\n    function reloadEarnings(uint256 _pID, uint256 _eth)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateTicketVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        require(_earnings >= _eth, \"earnings too lower\");\r\n\r\n        if (plyr_[_pID].gen >= _eth) {\r\n            plyr_[_pID].gen = plyr_[_pID].gen.sub(_eth);\r\n            return;\r\n        }else{\r\n            _eth = _eth.sub(plyr_[_pID].gen);\r\n            plyr_[_pID].gen = 0;\r\n        }\r\n        \r\n        if (plyr_[_pID].aff >= _eth){\r\n            plyr_[_pID].aff = plyr_[_pID].aff.sub(_eth);\r\n            return;\r\n        }else{\r\n            _eth = _eth.sub(plyr_[_pID].aff);\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n        \r\n        plyr_[_pID].win = plyr_[_pID].win.sub(_eth);\r\n\r\n    }\r\n    \r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateTicketVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;  // winner\r\n            plyr_[_pID].gen = 0;  //ticket valuet\r\n            plyr_[_pID].aff = 0;  // aff player\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    // aquire buy ticket price\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        return round_[rID_].jackpot.mul(150) / 100 / 1500;\r\n    }\r\n    \r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.  determines how to handle \r\n     * incoming eth depending on if we are in an active round or not\r\n    */\r\n    function buyTicket( uint256 _pID, uint256 _affID, uint256 _tickets) \r\n         private\r\n    {\r\n        //************** ******************\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].start && _now < round_[_rID].end){\r\n            // call ticket\r\n            ticket(_pID, _rID, _tickets, _affID, msg.value);\r\n            if (round_[_rID].tickets == ticketstotal_){\r\n                round_[_rID].ended = true;\r\n                round_[_rID].end = now;\r\n                endRound();\r\n            }\r\n        }else if (_now > round_[_rID].end && round_[_rID].ended == false){\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            //_eventData_ = endRound(_eventData_);\r\n            bool autopurchase = endRound();\r\n            // put eth in players vault\r\n            if (autopurchase){\r\n                ticket(_pID, _rID, _tickets, _affID, msg.value);\r\n            }else{\r\n                plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n            }\r\n            //plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n        //ticket(_pID, _rID, _tickets, _affID, msg.value);\r\n    }\r\n    \r\n    function ticket(uint256 _pID, uint256 _rID, uint256 _tickets, uint256 _affID, uint256 _eth)\r\n        private\r\n    {\r\n         // if player is new to round\r\n        if (plyrRnds_[_pID][rID_].tickets == 0){\r\n            managePlayer(_pID);\r\n            round_[rID_].playernums += 1;\r\n            plyrRnds_[_affID][rID_].affnums += 1;\r\n        }\r\n\r\n        // ********** buy ticket *************\r\n        uint tickets = round_[rID_].tickets;\r\n        uint groups = (tickets + _tickets  - 1) / grouptotal_ - tickets / grouptotal_;\r\n        uint offset = tickets / grouptotal_;\r\n       \r\n        if (groups == 0){\r\n            if (((tickets + _tickets) % grouptotal_) == 0){\r\n                orders[rID_][_pID][offset] = calulateXticket(orders[rID_][_pID][offset], grouptotal_, tickets % grouptotal_);\r\n            }else{\r\n                orders[rID_][_pID][offset] = calulateXticket(orders[rID_][_pID][offset], (tickets + _tickets) % grouptotal_, tickets % grouptotal_);\r\n            }\r\n        }else{\r\n            for(uint256 i = 0; i < groups + 1; i++){\r\n                if (i == 0){\r\n                     orders[rID_][_pID][offset+i] = calulateXticket(orders[rID_][_pID][offset + i], grouptotal_, tickets % grouptotal_);\r\n                }\r\n                if (i > 0 && i < groups){\r\n                    orders[rID_][_pID][offset + i] = calulateXticket(orders[rID_][_pID][offset + i], grouptotal_, 0);\r\n                }\r\n                if (i == groups){\r\n                    if (((tickets + _tickets) % grouptotal_) == 0){\r\n                        orders[rID_][_pID][offset + i] = calulateXticket(orders[rID_][_pID][offset + i], grouptotal_, 0);\r\n                    }else{\r\n                        orders[rID_][_pID][offset + i] = calulateXticket(orders[rID_][_pID][offset + i], (tickets + _tickets) % grouptotal_, 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (round_[rID_].tickets < _headtickets){\r\n            if (_tickets.add(round_[rID_].tickets) <= _headtickets){\r\n                plyrRnds_[_pID][rID_].luckytickets = _tickets.add(plyrRnds_[_pID][rID_].luckytickets);\r\n            }\r\n            else{\r\n                plyrRnds_[_pID][rID_].luckytickets = (_headtickets - round_[rID_].tickets).add(plyrRnds_[_pID][rID_].luckytickets); \r\n            }\r\n        }\r\n        // set up purchase tickets\r\n        round_[rID_].tickets = _tickets.add(round_[rID_].tickets);\r\n        plyrRnds_[_pID][rID_].tickets = _tickets.add(plyrRnds_[_pID][rID_].tickets);\r\n        plyrRnds_[_pID][rID_].eth = _eth.add(plyrRnds_[_pID][rID_].eth);\r\n        round_[rID_].blocknum = block.number;\r\n       \r\n        // distributes valuet\r\n        distributeVault(_pID, rID_, _affID, _eth, _tickets);\r\n        // order event log\r\n        //emit onBuy(msg.sender, tickets+1, tickets +_tickets,_rID, _eth, plyr_[_pID].name);\r\n        emit Coinevents.onBuy(msg.sender, tickets+1, tickets +_tickets,rID_, plyr_[_pID].name);\r\n    }\r\n\r\n    function distributeVault(uint256 _pID, uint256 _rID, uint256 _affID, uint256 _eth, uint256 _tickets)\r\n        private\r\n    {    \r\n         // distributes gen\r\n         uint256 _gen = 0;\r\n         uint256 _genvault = 0;\r\n         uint256 ticketprice_ = getBuyPrice();\r\n         if (round_[_rID].tickets > _headtickets){\r\n             if (round_[_rID].tickets.sub(_tickets) > _headtickets){\r\n                 _gen = _tickets;\r\n                 //plyrRnds_[_pID][_rID].luckytickets = \r\n             }else{\r\n                 _gen = round_[_rID].tickets.sub(_headtickets);\r\n             }\r\n         }\r\n         \r\n         if (_gen > 0){\r\n             //_genvault = (((_gen / _tickets).mul(_eth)).mul(20)) / 100;   // 20 % to gen tickets\r\n             _genvault = ((ticketprice_ * _gen).mul(20)) / 100;\r\n             round_[_rID].mask = _genvault.add(round_[_rID].mask);   // update mask\r\n         }\r\n         \r\n         uint256 _aff = _eth / 10;  //to================10%(aff)\r\n         uint256 _com = _eth / 20;  //to================5%(community)\r\n         uint256 _found = _eth.mul(32) / 100;\r\n         round_[_rID].found = _found.add(round_[_rID].found);  //to============prize found\r\n         if (_affID != 0){\r\n             plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n             community_addr.transfer(_com);\r\n         }else{\r\n             _com = _com.add(_aff);\r\n             community_addr.transfer(_com);\r\n         }\r\n         // ============to perhaps next round pool\r\n         uint256 _nextpot = _eth.sub(_genvault);\r\n         if (_affID != 0){\r\n             _nextpot = _nextpot.sub(_aff);\r\n         }\r\n         _nextpot = _nextpot.sub(_com);\r\n         _nextpot = _nextpot.sub(_found);\r\n         round_[_rID].nextpot = _nextpot.add(round_[_rID].nextpot);  // next round pool\r\n    }\r\n    \r\n    \r\n    function calulateXticket(uint256 _target, uint256 _start, uint256 _end) pure private returns(uint256){\r\n        return _target ^ (2 ** _start - 2 ** _end); \r\n    }\r\n    \r\n    function endRound() \r\n        private\r\n        returns(bool)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        uint256 prize_callback = 0;\r\n        round_[_rID].lucknum = randNums();\r\n        bool autopurchase = false;\r\n        \r\n        // 1. if win\r\n        if (round_[_rID].tickets >= round_[_rID].lucknum){\r\n           // community_addr.transfer(round_[_rID].income.sub(_com).sub(_gen));\r\n            // need administrators take in 10 ETH activate next round\r\n            prize_callback = round_[_rID].found.add(round_[_rID].nextpot);\r\n            if (prize_callback > 0) {\r\n                prize_addr.transfer(prize_callback);\r\n                activated_ = false;   // need administrators to activate\r\n                emit onSettle(_rID, round_[_rID].tickets, address(0), round_[_rID].lucknum, round_[_rID].jackpot);\r\n            }\r\n        }else{ \r\n            // 2. if nobody win\r\n            // directly start next round\r\n            prize_callback = round_[_rID].found;\r\n            if (prize_callback > 0) {\r\n                prize_addr.transfer(prize_callback);\r\n            }\r\n            rID_ ++;\r\n            _rID ++;\r\n            round_[_rID].start = now;\r\n            round_[_rID].end = now.add(rndGap_);\r\n            round_[_rID].jackpot = round_[_rID-1].jackpot.add(round_[_rID-1].nextpot);\r\n            autopurchase = true;\r\n            emit onSettle(_rID-1, round_[_rID-1].tickets, address(0), round_[_rID-1].lucknum, round_[_rID-1].jackpot);\r\n        }\r\n        return autopurchase;\r\n\r\n    }\r\n \r\n     /**\r\n     * @dev moves any unmasked earnings to ticket vault.  updates earnings\r\n     */   \r\n     // _pID: player pid _rIDlast: last roundid\r\n    function updateTicketVault(uint256 _pID, uint256 _rIDlast) private{\r\n        \r\n         uint256 _gen = (plyrRnds_[_pID][_rIDlast].luckytickets.mul(round_[_rIDlast].mask / _headtickets)).sub(plyrRnds_[_pID][_rIDlast].mask);\r\n         \r\n         uint256 _jackpot = 0;\r\n         if (judgeWin(_rIDlast, _pID) && address(round_[_rIDlast].winner) == 0) {\r\n             _jackpot = round_[_rIDlast].jackpot;\r\n             round_[_rIDlast].winner = msg.sender;\r\n         }\r\n         plyr_[_pID].gen = _gen.add(plyr_[_pID].gen);     // ticket valuet\r\n         plyr_[_pID].win = _jackpot.add(plyr_[_pID].win); // player win\r\n         plyrRnds_[_pID][_rIDlast].mask = plyrRnds_[_pID][_rIDlast].mask.add(_gen);\r\n    }\r\n    \r\n    \r\n    function managePlayer(uint256 _pID)\r\n        private\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateTicketVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n\r\n    }\r\n    //==============================================================================\r\n    //     _ _ | _   | _ _|_ _  _ _  .\r\n    //    (_(_||(_|_||(_| | (_)| _\\  .\r\n    //==============================================================================\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update ticket)\r\n     * @return earnings in wei format\r\n     */\r\n     //\u8ba1\u7b97\u6bcf\u8f6e\u4e2dpid\u524d500ticket\u7684\u5206\u7ea2\r\n    function calcTicketEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {   // per round ticket valuet\r\n        return (plyrRnds_[_pID][_rIDlast].luckytickets.mul(round_[_rIDlast].mask / _headtickets)).sub(plyrRnds_[_pID][_rIDlast].mask);\r\n    }\r\n    \r\n    //====================/=========================================================\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs \r\n     * have time to set things up on the web end                            **/\r\n    \r\n    function activate()\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        // can only be ran once\r\n        require(\r\n            msg.sender == activate_addr2 ||msg.sender == activate_addr1);\r\n        \r\n        require(activated_ == false, \"LuckyCoin already activated\");\r\n        //uint256 _jackpot = 10 ether;\r\n        require(msg.value == jackpot, \"activate game need 10 ether\");\r\n        \r\n        if (rID_ != 0) {\r\n            require(round_[rID_].tickets >= round_[rID_].lucknum, \"nobody win\");\r\n        }\r\n        //activate the contract \r\n        activated_ = true;\r\n        //lets start first round\r\n        rID_ ++;\r\n        round_[rID_].start = now;\r\n        round_[rID_].end = now + rndGap_;\r\n        round_[rID_].jackpot = msg.value;\r\n        emit onActivate(rID_);\r\n    }\r\n    \r\n    /**\r\n\t * @dev receives name/player info from names contract \r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    \r\n//==============================PLAYER==========================================    \r\n    /**\r\n     * @dev receives entire player name list \r\n     */\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name)\r\n        external\r\n    {\r\n        require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */        \r\n    function determinePID()\r\n        private\r\n        //returns (Coindatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // if player is new to this version of luckycoin\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract \r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n            \r\n            // set up player account \r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            \r\n            if (_name != \"\")\r\n            {\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            \r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            \r\n            // set the new player bool to true\r\n            //_eventData_.compressedData = _eventData_.compressedData + 1;\r\n        } \r\n        //return (_eventData_);\r\n    }\r\n    \r\n    // only support Name by name\r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit Coinevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        // fire event\r\n        emit Coinevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    /**\r\n     * @dev returns time left.  dont spam this, you'll ddos yourself from your node \r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n    */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_[_rID].end){\r\n            return( (round_[_rID].end).sub(_now) );\r\n        }\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    function getCurrentRoundInfo() \r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bool)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        return \r\n        (\r\n            rID_,\r\n            round_[_rID].tickets,\r\n            round_[_rID].start,\r\n            round_[_rID].end,\r\n            round_[_rID].jackpot,\r\n            round_[_rID].nextpot,\r\n            round_[_rID].lucknum,\r\n            round_[_rID].mask,\r\n            round_[_rID].playernums,\r\n            round_[_rID].winner,\r\n            round_[_rID].ended\r\n        );\r\n    }\r\n    \r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        uint256 _lrnd =  plyr_[_pID].lrnd;\r\n        uint256 _jackpot = 0;\r\n        if (judgeWin(_lrnd, _pID) && address(round_[_lrnd].winner) == 0){\r\n            _jackpot = round_[_lrnd].jackpot;\r\n        }\r\n        \r\n        return\r\n        (\r\n            _pID,                               //0\r\n            plyr_[_pID].name,                   //1\r\n            plyrRnds_[_pID][_rID].tickets,      //2\r\n            plyr_[_pID].win.add(_jackpot),                    //3\r\n            plyr_[_pID].gen.add(calcTicketEarnings(_pID, _lrnd)),  //4\r\n            plyr_[_pID].aff,                    //5\r\n            plyrRnds_[_pID][_rID].eth,           //6\r\n            plyrRnds_[_pID][_rID].affnums        // 7\r\n        );\r\n    }\r\n\r\n    // generate a number between 1-1500 \r\n    function randNums() public view returns(uint256) {\r\n        return uint256(keccak256(block.difficulty, now, block.coinbase)) % ticketstotal_ + 1;\r\n    }\r\n    \r\n    // search user if win\r\n    function judgeWin(uint256 _rid, uint256 _pID)private view returns(bool){\r\n        uint256 _group = (round_[_rid].lucknum -1) / grouptotal_;\r\n        uint256 _temp = round_[_rid].lucknum % grouptotal_;\r\n        if (_temp == 0){\r\n            _temp = grouptotal_;\r\n        }\r\n\r\n        if (orders[_rid][_pID][_group] & (2 **(_temp-1)) == 2 **(_temp-1)){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // search the tickets owns\r\n    function searchtickets()public view returns(uint256, uint256, uint256, uint256,uint256, uint256){\r\n         uint256 _pID = pIDxAddr_[msg.sender];\r\n         return (\r\n             orders[rID_][_pID][0],\r\n             orders[rID_][_pID][1],\r\n             orders[rID_][_pID][2],\r\n             orders[rID_][_pID][3],\r\n             orders[rID_][_pID][4],\r\n             orders[rID_][_pID][5]\r\n            );\r\n     }\r\n     // search the tickets by address\r\n    function searchTicketsXaddr(address addr) public view returns(uint256, uint256, uint256, uint256,uint256, uint256){\r\n        uint256 _pID = pIDxAddr_[addr];\r\n        return (\r\n             orders[rID_][_pID][0],\r\n             orders[rID_][_pID][1],\r\n             orders[rID_][_pID][2],\r\n             orders[rID_][_pID][3],\r\n             orders[rID_][_pID][4],\r\n             orders[rID_][_pID][5]\r\n            );\r\n     }\r\n}\r\n\r\n\r\nlibrary Coindatasets {\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    \r\n     struct Round {\r\n        uint256 tickets; // already purchase ticket\r\n        bool ended;     // has round end function been ran\r\n        uint256 jackpot;    // eth to pot, perhaps next round pot\r\n        uint256 start;   // time round started\r\n        uint256 end;    // time ends/ended\r\n        address winner;  //win address\r\n        uint256 mask;   // global mask\r\n        uint256 found; // jackpot found\r\n        uint256 lucknum;  // win num\r\n        uint256 nextpot;  // next pot\r\n        uint256 blocknum; // current blocknum\r\n        uint256 playernums; // playernums\r\n      }\r\n      \r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n        uint256 luckytickets;  // head 500 will acquire distributes vault\r\n    }\r\n    \r\n    struct PotSplit {\r\n        uint256 community;    // % of pot thats paid to key holders of current round\r\n        uint256 gen;    // % of pot thats paid to tickets holders\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    \r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round\r\n        uint256 tickets;   // tickets\r\n        uint256 mask;  // player mask,\r\n        uint256 affnums;\r\n        uint256 luckytickets; // player luckytickets\r\n    }\r\n}\r\n\r\n\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n\r\n\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"searchtickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"tickets\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"found\",\"type\":\"uint256\"},{\"name\":\"lucknum\",\"type\":\"uint256\"},{\"name\":\"nextpot\",\"type\":\"uint256\"},{\"name\":\"blocknum\",\"type\":\"uint256\"},{\"name\":\"playernums\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"reLoadXaddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"tickets\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"affnums\",\"type\":\"uint256\"},{\"name\":\"luckytickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"searchTicketsXaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"randNums\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tickets\",\"type\":\"uint256\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"reLoadXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"luckytickets\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"begin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"LogbuyNums\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"begin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"}],\"name\":\"onBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ticketsout\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"luckynum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"onSettle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"onActivate\",\"type\":\"event\"}]", "ContractName": "LuckyCoin", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://dacb375c730cf46d347eac5c4f7f697b994121583d295a6d3f266c4566ffe562"}]}