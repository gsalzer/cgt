{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n/**\r\n * @title Ownership interface\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IOwnership {\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() constant returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title Ownership\r\n *\r\n * Perminent ownership\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract Ownership is IOwnership {\r\n\r\n    // Owner\r\n    address internal owner;\r\n\r\n\r\n    /**\r\n     * The publisher is the inital owner\r\n     */\r\n    function Ownership() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * Access is restricted to the current owner\r\n     */\r\n    modifier only_owner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` is the current owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) public constant returns (bool) {\r\n        return _account == owner;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the current owner\r\n     *\r\n     * @return address The current owner\r\n     */\r\n    function getOwner() public constant returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Transferable ownership interface\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITransferableOwnership {\r\n    \r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner);\r\n}\r\n\r\n\r\n/**\r\n * @title Transferable ownership\r\n *\r\n * Enhances ownership by allowing the current owner to \r\n * transfer ownership to a new owner\r\n *\r\n * #created 01/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TransferableOwnership is ITransferableOwnership, Ownership {\r\n\r\n\r\n    /**\r\n     * Transfer ownership to `_newOwner`\r\n     *\r\n     * @param _newOwner The address of the account that will become the new owner \r\n     */\r\n    function transferOwnership(address _newOwner) public only_owner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Multi-owned interface\r\n *\r\n * Interface that allows multiple owners\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IMultiOwned {\r\n\r\n    /**\r\n     * Returns true if `_account` is an owner\r\n     *\r\n     * @param _account The address to test against\r\n     */\r\n    function isOwner(address _account) constant returns (bool);\r\n\r\n\r\n    /**\r\n     * Returns the amount of owners\r\n     *\r\n     * @return The amount of owners\r\n     */\r\n    function getOwnerCount() constant returns (uint);\r\n\r\n\r\n    /**\r\n     * Gets the owner at `_index`\r\n     *\r\n     * @param _index The index of the owner\r\n     * @return The address of the owner found at `_index`\r\n     */\r\n    function getOwnerAt(uint _index) constant returns (address);\r\n\r\n\r\n     /**\r\n     * Adds `_account` as a new owner\r\n     *\r\n     * @param _account The account to add as an owner\r\n     */\r\n    function addOwner(address _account);\r\n\r\n\r\n    /**\r\n     * Removes `_account` as an owner\r\n     *\r\n     * @param _account The account to remove as an owner\r\n     */\r\n    function removeOwner(address _account);\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve interface\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract);\r\n}\r\n\r\n\r\n/**\r\n * @title Token retrieve\r\n *\r\n * Allows tokens to be retrieved from a contract\r\n *\r\n * #created 18/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenRetriever is ITokenRetriever {\r\n\r\n    /**\r\n     * Extracts tokens from the contract\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public {\r\n        IToken tokenInstance = IToken(_tokenContract);\r\n        uint tokenBalance = tokenInstance.balanceOf(this);\r\n        if (tokenBalance > 0) {\r\n            tokenInstance.transfer(msg.sender, tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Token observer interface\r\n *\r\n * Allows a token smart-contract to notify observers \r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract ITokenObserver {\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value);\r\n}\r\n\r\n\r\n/**\r\n * @title Abstract token observer\r\n *\r\n * Allows observers to be notified by an observed token smart-contract\r\n * when tokens are received\r\n *\r\n * #created 09/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract TokenObserver is ITokenObserver {\r\n\r\n    /**\r\n     * Called by the observed token smart-contract in order \r\n     * to notify the token observer when tokens are received\r\n     *\r\n     * @param _from The address that the tokens where send from\r\n     * @param _value The amount of tokens that was received\r\n     */\r\n    function notifyTokensReceived(address _from, uint _value) public {\r\n        onTokensReceived(msg.sender, _from, _value);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler\r\n     * \r\n     * Called by `_token` when a token amount is received\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal;\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 compatible token interface\r\n *\r\n * - Implements ERC 20 Token standard\r\n * - Implements short address attack fix\r\n *\r\n * #created 29/09/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract IToken { \r\n\r\n    /** \r\n     * Get the total supply of tokens\r\n     * \r\n     * @return The total supply\r\n     */\r\n    function totalSupply() constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Get balance of `_owner` \r\n     * \r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) constant returns (uint);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `msg.sender`\r\n     * \r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * \r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * \r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint _value) returns (bool);\r\n\r\n\r\n    /** \r\n     * Get the amount of remaining tokens that `_spender` is allowed to spend from `_owner`\r\n     * \r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) constant returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title Dcorp Proxy\r\n *\r\n * Serves as a placeholder for the Dcorp funds, allowing the community the ability to vote on the acceptance of the VC platform,\r\n * and the transfer of token ownership. This mechanism is in place to allow the unlocking of the original DRP token, and to allow token \r\n * holders to convert to DRPU or DRPS.\r\n\r\n * This proxy is deployed upon receiving the Ether that is currently held by the DRP Crowdsale contract.\r\n *\r\n * #created 16/10/2017\r\n * #author Frank Bonnet\r\n */\r\ncontract DcorpProxy is TokenObserver, TransferableOwnership, TokenRetriever {\r\n\r\n    enum Stages {\r\n        Deploying,\r\n        Deployed,\r\n        Executed\r\n    }\r\n\r\n    struct Balance {\r\n        uint drps;\r\n        uint drpu;\r\n        uint index;\r\n    }\r\n\r\n    struct Vote {\r\n        uint datetime;\r\n        bool support;\r\n        uint index;\r\n    }\r\n\r\n    struct Proposal {\r\n        uint createdTimestamp;\r\n        uint supportingWeight;\r\n        uint rejectingWeight;\r\n        mapping(address => Vote) votes;\r\n        address[] voteIndex;\r\n        uint index;\r\n    }\r\n\r\n    // State\r\n    Stages private stage;\r\n\r\n    // Settings\r\n    uint private constant VOTING_DURATION = 7 days;\r\n    uint private constant MIN_QUORUM = 5; // 5%\r\n\r\n    // Alocated balances\r\n    mapping (address => Balance) private allocated;\r\n    address[] private allocatedIndex;\r\n\r\n    // Proposals\r\n    mapping(address => Proposal) private proposals;\r\n    address[] private proposalIndex;\r\n\r\n    // Tokens\r\n    IToken private drpsToken;\r\n    IToken private drpuToken;\r\n\r\n    // Crowdsale\r\n    address private drpCrowdsale;\r\n    uint public drpCrowdsaleRecordedBalance;\r\n\r\n\r\n    /**\r\n     * Require that the proxy is in `_stage` \r\n     */\r\n    modifier only_at_stage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require `_token` to be one of the drp tokens\r\n     *\r\n     * @param _token The address to test against\r\n     */\r\n    modifier only_accepted_token(address _token) {\r\n        require(_token == address(drpsToken) || _token == address(drpuToken));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that `_token` is not one of the drp tokens\r\n     *\r\n     * @param _token The address to test against\r\n     */\r\n    modifier not_accepted_token(address _token) {\r\n        require(_token != address(drpsToken) && _token != address(drpuToken));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that sender has more than zero tokens \r\n     */\r\n    modifier only_token_holder() {\r\n        require(allocated[msg.sender].drps > 0 || allocated[msg.sender].drpu > 0);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require `_proposedAddress` to have been proposed already\r\n     *\r\n     * @param _proposedAddress Address that needs to be proposed\r\n     */\r\n    modifier only_proposed(address _proposedAddress) {\r\n        require(isProposed(_proposedAddress));\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the voting period for the proposal has\r\n     * not yet ended\r\n     *\r\n     * @param _proposedAddress Address that was proposed\r\n     */\r\n    modifier only_during_voting_period(address _proposedAddress) {\r\n        require(now <= proposals[_proposedAddress].createdTimestamp + VOTING_DURATION);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the voting period for the proposal has ended\r\n     *\r\n     * @param _proposedAddress Address that was proposed\r\n     */\r\n    modifier only_after_voting_period(address _proposedAddress) {\r\n        require(now > proposals[_proposedAddress].createdTimestamp + VOTING_DURATION);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Require that the proposal is supported\r\n     *\r\n     * @param _proposedAddress Address that was proposed\r\n     */\r\n    modifier only_when_supported(address _proposedAddress) {\r\n        require(isSupported(_proposedAddress, false));\r\n        _;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Construct the proxy\r\n     *\r\n     * @param _drpsToken The new security token\r\n     * @param _drpuToken The new utility token\r\n     * @param _drpCrowdsale Proxy accepts and requires ether from the crowdsale\r\n     */\r\n    function DcorpProxy(address _drpsToken, address _drpuToken, address _drpCrowdsale) {\r\n        drpsToken = IToken(_drpsToken);\r\n        drpuToken = IToken(_drpuToken);\r\n        drpCrowdsale = _drpCrowdsale;\r\n        drpCrowdsaleRecordedBalance = _drpCrowdsale.balance;\r\n        stage = Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the proxy is being deployed\r\n     *\r\n     * @return Whether the proxy is in the deploying stage\r\n     */\r\n    function isDeploying() public constant returns (bool) {\r\n        return stage == Stages.Deploying;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether the proxy is deployed. The proxy is deployed \r\n     * when it receives Ether from the drp crowdsale contract\r\n     *\r\n     * @return Whether the proxy is deployed\r\n     */\r\n    function isDeployed() public constant returns (bool) {\r\n        return stage == Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns whether a proposal, and with it the proxy itself, is \r\n     * already executed or not\r\n     *\r\n     * @return Whether the proxy is executed\r\n     */\r\n    function isExecuted() public constant returns (bool) {\r\n        return stage == Stages.Executed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Accept eth from the crowdsale while deploying\r\n     */\r\n    function () public payable only_at_stage(Stages.Deploying) {\r\n        require(msg.sender == drpCrowdsale);\r\n    }\r\n\r\n\r\n    /**\r\n     * Deploy the proxy\r\n     */\r\n    function deploy() only_owner only_at_stage(Stages.Deploying) {\r\n        require(this.balance >= drpCrowdsaleRecordedBalance);\r\n        stage = Stages.Deployed;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the combined total supply of all drp tokens\r\n     *\r\n     * @return The combined total drp supply\r\n     */\r\n    function getTotalSupply() public constant returns (uint) {\r\n        uint sum = 0; \r\n        sum += drpsToken.totalSupply();\r\n        sum += drpuToken.totalSupply();\r\n        return sum;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_owner` has a balance allocated\r\n     *\r\n     * @param _owner The account that the balance is allocated for\r\n     * @return True if there is a balance that belongs to `_owner`\r\n     */\r\n    function hasBalance(address _owner) public constant returns (bool) {\r\n        return allocatedIndex.length > 0 && _owner == allocatedIndex[allocated[_owner].index];\r\n    }\r\n\r\n\r\n    /** \r\n     * Get the allocated drps token balance of `_owner`\r\n     * \r\n     * @param _token The address to test against\r\n     * @param _owner The address from which the allocated token balance will be retrieved\r\n     * @return The allocated drps token balance\r\n     */\r\n    function balanceOf(address _token, address _owner) public constant returns (uint) {\r\n        uint balance = 0;\r\n        if (address(drpsToken) == _token) {\r\n            balance = allocated[_owner].drps;\r\n        } \r\n        \r\n        else if (address(drpuToken) == _token) {\r\n            balance = allocated[_owner].drpu;\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_proposedAddress` is already proposed\r\n     *\r\n     * @param _proposedAddress Address that was proposed\r\n     * @return Whether `_proposedAddress` is already proposed \r\n     */\r\n    function isProposed(address _proposedAddress) public constant returns (bool) {\r\n        return proposalIndex.length > 0 && _proposedAddress == proposalIndex[proposals[_proposedAddress].index];\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the how many proposals where made\r\n     *\r\n     * @return The amount of proposals\r\n     */\r\n    function getProposalCount() public constant returns (uint) {\r\n        return proposalIndex.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * Propose the transfer token ownership and all funds to `_proposedAddress` \r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     */\r\n    function propose(address _proposedAddress) public only_owner only_at_stage(Stages.Deployed) {\r\n        require(!isProposed(_proposedAddress));\r\n\r\n        // Add proposal\r\n        Proposal storage p = proposals[_proposedAddress];\r\n        p.createdTimestamp = now;\r\n        p.index = proposalIndex.push(_proposedAddress) - 1;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the voting duration, the amount of time voting \r\n     * is allowed\r\n     *\r\n     * @return Voting duration\r\n     */\r\n    function getVotingDuration() public constant returns (uint) {              \r\n        return VOTING_DURATION;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the number of votes towards a proposal\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @return uint Vote count\r\n     */\r\n    function getVoteCount(address _proposedAddress) public constant returns (uint) {              \r\n        return proposals[_proposedAddress].voteIndex.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` has voted on the proposal\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @param _account The key (address) that maps to the vote\r\n     * @return bool Whether `_account` has voted on the proposal\r\n     */\r\n    function hasVoted(address _proposedAddress, address _account) public constant returns (bool) {\r\n        bool voted = false;\r\n        if (getVoteCount(_proposedAddress) > 0) {\r\n            Proposal storage p = proposals[_proposedAddress];\r\n            voted = p.voteIndex[p.votes[_account].index] == _account;\r\n        }\r\n\r\n        return voted;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if `_account` supported the proposal and returns \r\n     * false if `_account` is opposed to the proposal\r\n     *\r\n     * Does not check if `_account` had voted, use hasVoted()\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @param _account The key (address) that maps to the vote\r\n     * @return bool Supported\r\n     */\r\n    function getVote(address _proposedAddress, address _account) public constant returns (bool) {\r\n        return proposals[_proposedAddress].votes[_account].support;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows a token holder to vote on a proposal\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @param _support True if supported\r\n     */\r\n    function vote(address _proposedAddress, bool _support) public only_at_stage(Stages.Deployed) only_proposed(_proposedAddress) only_during_voting_period(_proposedAddress) only_token_holder {    \r\n        Proposal storage p = proposals[_proposedAddress];\r\n        Balance storage b = allocated[msg.sender];\r\n        \r\n        // Register vote\r\n        if (!hasVoted(_proposedAddress, msg.sender)) {\r\n            p.votes[msg.sender] = Vote(\r\n                now, _support, p.voteIndex.push(msg.sender) - 1);\r\n\r\n            // Register weight\r\n            if (_support) {\r\n                p.supportingWeight += b.drps + b.drpu;\r\n            } else {\r\n                p.rejectingWeight += b.drps + b.drpu;\r\n            }\r\n        } else {\r\n            Vote storage v = p.votes[msg.sender];\r\n            if (v.support != _support) {\r\n\r\n                // Register changed weight\r\n                if (_support) {\r\n                    p.supportingWeight += b.drps + b.drpu;\r\n                    p.rejectingWeight -= b.drps + b.drpu;\r\n                } else {\r\n                    p.rejectingWeight += b.drps + b.drpu;\r\n                    p.supportingWeight -= b.drps + b.drpu;\r\n                }\r\n\r\n                v.support = _support;\r\n                v.datetime = now;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the current voting results for a proposal\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @return supported, rejected\r\n     */\r\n    function getVotingResult(address _proposedAddress) public constant returns (uint, uint) {      \r\n        Proposal storage p = proposals[_proposedAddress];    \r\n        return (p.supportingWeight, p.rejectingWeight);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if the proposal is supported\r\n     *\r\n     * @param _proposedAddress The proposed DCORP address \r\n     * @param _strict If set to true the function requires that the voting period is ended\r\n     * @return bool Supported\r\n     */\r\n    function isSupported(address _proposedAddress, bool _strict) public constant returns (bool) {        \r\n        Proposal storage p = proposals[_proposedAddress];\r\n        bool supported = false;\r\n\r\n        if (!_strict || now > p.createdTimestamp + VOTING_DURATION) {\r\n            var (support, reject) = getVotingResult(_proposedAddress);\r\n            supported = support > reject;\r\n            if (supported) {\r\n                supported = support + reject >= getTotalSupply() * MIN_QUORUM / 100;\r\n            }\r\n        }\r\n        \r\n        return supported;\r\n    }\r\n\r\n\r\n    /**\r\n     * Executes the proposal\r\n     *\r\n     * Should only be called after the voting period and \r\n     * when the proposal is supported\r\n     *\r\n     * @param _acceptedAddress The accepted DCORP address \r\n     * @return bool Success\r\n     */\r\n    function execute(address _acceptedAddress) public only_owner only_at_stage(Stages.Deployed) only_proposed(_acceptedAddress) only_after_voting_period(_acceptedAddress) only_when_supported(_acceptedAddress) {\r\n        \r\n        // Mark as executed\r\n        stage = Stages.Executed;\r\n\r\n        // Add accepted address as token owner\r\n        IMultiOwned(drpsToken).addOwner(_acceptedAddress);\r\n        IMultiOwned(drpuToken).addOwner(_acceptedAddress);\r\n\r\n        // Remove self token as owner\r\n        IMultiOwned(drpsToken).removeOwner(this);\r\n        IMultiOwned(drpuToken).removeOwner(this);\r\n\r\n        // Transfer Eth (safe because we don't know how much gas is used counting votes)\r\n        uint balanceBefore = _acceptedAddress.balance;\r\n        uint balanceToSend = this.balance;\r\n        _acceptedAddress.transfer(balanceToSend);\r\n\r\n        // Assert balances\r\n        assert(balanceBefore + balanceToSend == _acceptedAddress.balance);\r\n        assert(this.balance == 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * Event handler that initializes the token conversion\r\n     * \r\n     * Called by `_token` when a token amount is received on \r\n     * the address of this token changer\r\n     *\r\n     * @param _token The token contract that received the transaction\r\n     * @param _from The account or contract that send the transaction\r\n     * @param _value The value of tokens that where received\r\n     */\r\n    function onTokensReceived(address _token, address _from, uint _value) internal only_at_stage(Stages.Deployed) only_accepted_token(_token) {\r\n        require(_token == msg.sender);\r\n\r\n        // Allocate tokens\r\n        if (!hasBalance(_from)) {\r\n            allocated[_from] = Balance(\r\n                0, 0, allocatedIndex.push(_from) - 1);\r\n        }\r\n\r\n        Balance storage b = allocated[_from];\r\n        if (_token == address(drpsToken)) {\r\n            b.drps += _value;\r\n        } else {\r\n            b.drpu += _value;\r\n        }\r\n\r\n        // Increase weight\r\n        _adjustWeight(_from, _value, true);\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw DRPS tokens from the proxy and reduce the \r\n     * owners weight accordingly\r\n     * \r\n     * @param _value The amount of DRPS tokens to withdraw\r\n     */\r\n    function withdrawDRPS(uint _value) public {\r\n        Balance storage b = allocated[msg.sender];\r\n\r\n        // Require sufficient balance\r\n        require(b.drps >= _value);\r\n        require(b.drps - _value <= b.drps);\r\n\r\n        // Update balance\r\n        b.drps -= _value;\r\n\r\n        // Reduce weight\r\n        _adjustWeight(msg.sender, _value, false);\r\n\r\n        // Call external\r\n        if (!drpsToken.transfer(msg.sender, _value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Withdraw DRPU tokens from the proxy and reduce the \r\n     * owners weight accordingly\r\n     * \r\n     * @param _value The amount of DRPU tokens to withdraw\r\n     */\r\n    function withdrawDRPU(uint _value) public {\r\n        Balance storage b = allocated[msg.sender];\r\n\r\n        // Require sufficient balance\r\n        require(b.drpu >= _value);\r\n        require(b.drpu - _value <= b.drpu);\r\n\r\n        // Update balance\r\n        b.drpu -= _value;\r\n\r\n        // Reduce weight\r\n        _adjustWeight(msg.sender, _value, false);\r\n\r\n        // Call external\r\n        if (!drpuToken.transfer(msg.sender, _value)) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Failsafe mechanism\r\n     * \r\n     * Allows the owner to retrieve tokens (other than DRPS and DRPU tokens) from the contract that \r\n     * might have been send there by accident\r\n     *\r\n     * @param _tokenContract The address of ERC20 compatible token\r\n     */\r\n    function retrieveTokens(address _tokenContract) public only_owner not_accepted_token(_tokenContract) {\r\n        super.retrieveTokens(_tokenContract);\r\n    }\r\n\r\n\r\n    /**\r\n     * Adjust voting weight in ongoing proposals on which `_owner` \r\n     * has already voted\r\n     * \r\n     * @param _owner The owner of the weight\r\n     * @param _value The amount of weight that is adjusted\r\n     * @param _increase Indicated whether the weight is increased or decreased\r\n     */\r\n    function _adjustWeight(address _owner, uint _value, bool _increase) private {\r\n        for (uint i = proposalIndex.length; i > 0; i--) {\r\n            Proposal storage p = proposals[proposalIndex[i - 1]];\r\n            if (now > p.createdTimestamp + VOTING_DURATION) {\r\n                break; // Last active proposal\r\n            }\r\n\r\n            if (hasVoted(proposalIndex[i - 1], _owner)) {\r\n                if (p.votes[_owner].support) {\r\n                    if (_increase) {\r\n                        p.supportingWeight += _value;\r\n                    } else {\r\n                        p.supportingWeight -= _value;\r\n                    }\r\n                } else {\r\n                    if (_increase) {\r\n                        p.rejectingWeight += _value;\r\n                    } else {\r\n                        p.rejectingWeight -= _value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"}],\"name\":\"propose\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isExecuted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"hasBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acceptedAddress\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"},{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"hasVoted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"},{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getVote\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"notifyTokensReceived\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"},{\"name\":\"_strict\",\"type\":\"bool\"}],\"name\":\"isSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawDRPU\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"}],\"name\":\"isProposed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"}],\"name\":\"getVotingResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawDRPS\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drpCrowdsaleRecordedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"},{\"name\":\"_support\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProposalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeployed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVotingDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proposedAddress\",\"type\":\"address\"}],\"name\":\"getVoteCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDeploying\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_drpsToken\",\"type\":\"address\"},{\"name\":\"_drpuToken\",\"type\":\"address\"},{\"name\":\"_drpCrowdsale\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"}]", "ContractName": "DcorpProxy", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003e250a4f78410c29cfc39463a81f14a226690eb4000000000000000000000000e30e02f049957e2a5907589e06ba646fb2c321ba000000000000000000000000d42433a8a0a1ceb73c8ff4e432463e2ee109039d", "Library": "", "SwarmSource": "bzzr://e1ae7edf82d2efbb774883f5aa3f7d070db03ed29a8d676f3d0bb9f75a4c740c"}]}