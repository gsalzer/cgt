{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.0;\r\n\r\n//https://github.com/nexusdev/erc20/blob/master/contracts/erc20.sol\r\n\r\ncontract ERC20Constant {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance(address owner, address spender) constant returns (uint _allowance);\r\n}\r\ncontract ERC20Stateful {\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n}\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// contract can buy or sell tokens for ETH\r\n// prices are in amount of wei per batch of token units\r\n\r\ncontract TokenTrader is owned {\r\n\r\n    address public asset;       // address of token\r\n    uint256 public buyPrice;   // contact buys lots of token at this price\r\n    uint256 public sellPrice;  // contract sells lots at this price\r\n    uint256 public units;       // lot size (token-wei)\r\n\r\n    bool public sellsTokens;    // is contract selling\r\n    bool public buysTokens;     // is contract buying\r\n\r\n    event ActivatedEvent(bool sells, bool buys);\r\n    event UpdateEvent();\r\n\r\n    function TokenTrader (\r\n        address _asset, \r\n        uint256 _buyPrice, \r\n        uint256 _sellPrice, \r\n        uint256 _units,\r\n        bool    _sellsTokens,\r\n        bool    _buysTokens\r\n        )\r\n    {\r\n          asset         = _asset; \r\n          buyPrice     = _buyPrice; \r\n          sellPrice    = _sellPrice;\r\n          units         = _units; \r\n          sellsTokens   = _sellsTokens;\r\n          buysTokens    = _buysTokens;\r\n\r\n          ActivatedEvent(sellsTokens,buysTokens);\r\n    }\r\n\r\n    // modify trading behavior\r\n    function activate (\r\n        bool    _sellsTokens,\r\n        bool    _buysTokens\r\n        ) onlyOwner\r\n    {\r\n          sellsTokens   = _sellsTokens;\r\n          buysTokens    = _buysTokens;\r\n\r\n          ActivatedEvent(sellsTokens,buysTokens);\r\n    }\r\n\r\n    // allows owner to deposit ETH\r\n    // deposit tokens by sending them directly to contract\r\n    // buyers must not send tokens to the contract, use: sell(...)\r\n    function deposit() payable onlyOwner {\r\n        UpdateEvent();\r\n    }\r\n\r\n    // allow owner to remove trade token\r\n    function withdrawAsset(uint256 _value) onlyOwner returns (bool ok)\r\n    {\r\n        return ERC20(asset).transfer(owner,_value);\r\n        UpdateEvent();\r\n    }\r\n\r\n    // allow owner to remove arbitrary tokens\r\n    // included just in case contract receives wrong token\r\n    function withdrawToken(address _token, uint256 _value) onlyOwner returns (bool ok)\r\n    {\r\n        return ERC20(_token).transfer(owner,_value);\r\n        UpdateEvent();\r\n    }\r\n\r\n    // allow owner to remove ETH\r\n    function withdraw(uint256 _value) onlyOwner returns (bool ok)\r\n    {\r\n        if(this.balance >= _value) {\r\n            return owner.send(_value);\r\n        }\r\n        UpdateEvent();\r\n    }\r\n\r\n    //user buys token with ETH\r\n    function buy() payable {\r\n        if(sellsTokens || msg.sender == owner) \r\n        {\r\n            uint order   = msg.value / sellPrice; \r\n            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;\r\n\r\n            if(order > can_sell)\r\n            {\r\n                uint256 change = msg.value - (can_sell * sellPrice);\r\n                order = can_sell;\r\n                if(!msg.sender.send(change)) throw;\r\n            }\r\n\r\n            if(order > 0) {\r\n                if(!ERC20(asset).transfer(msg.sender,order * units)) throw;\r\n            }\r\n            UpdateEvent();\r\n        }\r\n        else if(!msg.sender.send(msg.value)) throw;  // return user funds if the contract is not selling\r\n    }\r\n\r\n    // user sells token for ETH\r\n    // user must set allowance for this contract before calling\r\n    function sell(uint256 amount) {\r\n        if (buysTokens || msg.sender == owner) {\r\n            uint256 can_buy = this.balance / buyPrice;  // token lots contract can buy\r\n            uint256 order = amount / units;             // token lots available\r\n\r\n            if(order > can_buy) order = can_buy;        // adjust order for funds\r\n\r\n            if (order > 0)\r\n            { \r\n                // extract user tokens\r\n                if(!ERC20(asset).transferFrom(msg.sender, address(this), amount)) throw;\r\n\r\n                // pay user\r\n                if(!msg.sender.send(order * buyPrice)) throw;\r\n            }\r\n            UpdateEvent();\r\n        }\r\n    }\r\n\r\n    // sending ETH to contract sells ETH to user\r\n    function () payable {\r\n        buy();\r\n    }\r\n}\r\n\r\n// This contract deploys TokenTrader contracts and logs the event\r\n// trade pairs are identified with sha3(asset,units)\r\n\r\ncontract TokenTraderFactory {\r\n\r\n    event TradeListing(bytes32 bookid, address owner, address addr);\r\n    event NewBook(bytes32 bookid, address asset, uint256 units);\r\n\r\n    mapping( address => bool ) _verify;\r\n    mapping( bytes32 => bool ) pairExits;\r\n    \r\n    function verify(address tradeContract)  constant returns (\r\n        bool valid,\r\n        address asset, \r\n        uint256 buyPrice, \r\n        uint256 sellPrice, \r\n        uint256 units,\r\n        bool    sellsTokens,\r\n        bool    buysTokens       \r\n        ) {\r\n            \r\n            valid = _verify[tradeContract];\r\n            \r\n            if(valid) {\r\n                TokenTrader t = TokenTrader(tradeContract);\r\n                \r\n                asset = t.asset();\r\n                buyPrice =t.buyPrice();\r\n                sellPrice = t.sellPrice();\r\n                units = t.units();\r\n                sellsTokens = t.sellsTokens();\r\n                buysTokens = t.buysTokens();\r\n            }\r\n        \r\n    }\r\n\r\n    function createTradeContract(       \r\n        address _asset, \r\n        uint256 _buyPrice, \r\n        uint256 _sellPrice, \r\n        uint256 _units,\r\n        bool    _sellsTokens,\r\n        bool    _buysTokens\r\n        ) returns (address) \r\n    {\r\n        if(_buyPrice > _sellPrice) throw; // must make profit on spread\r\n        if(_units == 0) throw;              // can't sell zero units\r\n\r\n        address trader = new TokenTrader (\r\n                     _asset, \r\n                     _buyPrice, \r\n                     _sellPrice, \r\n                     _units,\r\n                     _sellsTokens,\r\n                     _buysTokens);\r\n\r\n        var bookid = sha3(_asset,_units);\r\n\r\n        _verify[trader] = true; // record that this factory created the trader\r\n\r\n        TokenTrader(trader).transferOwnership(msg.sender); // set the owner to whoever called the function\r\n\r\n        if(pairExits[bookid] == false) {\r\n            pairExits[bookid] = true;\r\n            NewBook(bookid, _asset, _units);\r\n        }\r\n\r\n        TradeListing(bookid,msg.sender,trader);\r\n    }\r\n\r\n    function () {\r\n        throw;     // Prevents accidental sending of ether to the factory\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_units\",\"type\":\"uint256\"},{\"name\":\"_sellsTokens\",\"type\":\"bool\"},{\"name\":\"_buysTokens\",\"type\":\"bool\"}],\"name\":\"createTradeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tradeContract\",\"type\":\"address\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"name\":\"sellPrice\",\"type\":\"uint256\"},{\"name\":\"units\",\"type\":\"uint256\"},{\"name\":\"sellsTokens\",\"type\":\"bool\"},{\"name\":\"buysTokens\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bookid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"TradeListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bookid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"units\",\"type\":\"uint256\"}],\"name\":\"NewBook\",\"type\":\"event\"}]", "ContractName": "TokenTraderFactory", "CompilerVersion": "v0.4.3-nightly.2016.9.30+commit.d5cfb17b", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": ""}]}