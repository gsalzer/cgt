{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/* \r\n * Token related contracts \r\n */\r\n\r\n\r\n/*\r\n * ERC20Basic\r\n * Simpler version of ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\n\r\ncontract ERC20Basic {\r\n    uint public totalSupply;\r\n    function balanceOf(address who) public view returns (uint);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n */\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() { \r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNewOwner() {\r\n        require(msg.sender == newOwner);\r\n        _;\r\n    }\r\n    /*\r\n    // This code is dangerous because an error in the newOwner \r\n    // means that this contract will be ownerless \r\n    function transfer(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0)); \r\n        owner = newOwner;\r\n    }\r\n   */\r\n\r\n    function proposeNewOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() external onlyNewOwner {\r\n        require(newOwner != owner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n    event Mint(address indexed to, uint256 amount);\r\n    event MintFinished();\r\n\r\n    bool public mintingFinished = false;\r\n\r\n\r\n    modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _amount The amount of tokens to mint.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        Mint(_to, _amount);\r\n        Transfer(address(0), _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to stop minting new tokens.\r\n     * @return True if the operation was successful.\r\n     */\r\n    function finishMinting() public onlyOwner canMint returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public  {\r\n        require(_value <= balances[msg.sender]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\n\r\ncontract Pausable is Ownable {\r\n\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = true;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n}\r\n\r\n\r\n\r\n/* @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n}\r\n\r\n\r\n/*\r\n * Actual token contract\r\n */\r\n\r\ncontract AcjToken is BurnableToken, MintableToken, PausableToken {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Artist Connect Coin\";\r\n    string public constant symbol = \"ACJ\";\r\n    uint public constant decimals = 18;\r\n    \r\n    function AcjToken() public {\r\n        totalSupply = 150000000 ether; \r\n        balances[msg.sender] = totalSupply;\r\n        paused = true;\r\n    }\r\n\r\n    function activate() external onlyOwner {\r\n        unpause();\r\n        finishMinting();\r\n    }\r\n\r\n    // This method will be used by the crowdsale smart contract \r\n    // that owns the AcjToken and will distribute \r\n    // the tokens to the contributors\r\n    function initialTransfer(address _to, uint _value) external onlyOwner returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _amount) public onlyOwner {\r\n        super.burn(_amount);\r\n    }\r\n\r\n}\r\n\r\n \r\n\r\n\r\ncontract AcjCrowdsale is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    // Presale bonus percentage\r\n    uint public constant BONUS_PRESALE = 10;            \r\n    // Medium bonus percentage\r\n    uint public constant BONUS_MID = 10;                \r\n    // High bonus percentage\r\n    uint public constant BONUS_HI = 20;                 \r\n    // Medium bonus threshold\r\n    uint public constant BONUS_MID_QTY = 150 ether;     \r\n    // High bonus threshold\r\n    uint public constant BONUS_HI_QTY = 335 ether;      \r\n    // Absolute dates as timestamps\r\n    uint public startPresale;            \r\n    uint public endPresale;             \r\n    uint public startIco;              \r\n    uint public endIco;               \r\n    // 30 days refund period on fail\r\n    uint public constant REFUND_PERIOD = 30 days;\r\n    // Indicative token balances during the crowdsale \r\n    mapping(address => uint256) public tokenBalances;    \r\n    // Token smart contract address\r\n    address public token;\r\n    // Total tokens created\r\n    uint256 public constant TOKENS_TOTAL_SUPPLY = 150000000 ether; \r\n    // Tokens available for sale\r\n    uint256 public constant TOKENS_FOR_SALE = 75000000 ether;    \r\n    // soft cap in Tokens\r\n    uint256 public constant TOKENS_SOFT_CAP = 500000 ether;       \r\n    // Tokens sold via buyTokens\r\n    uint256 public tokensSold;                             \r\n    // Tokens created during the sale\r\n    uint256 public tokensDistributed;                                         \r\n    // ICO flat rate subject to bonuses\r\n    uint256 public ethTokenRate;                                 \r\n    // Allow multiple administrators\r\n    mapping(address => bool) public admins;                    \r\n    // Total wei received \r\n    uint256 public weiReceived;                            \r\n    // Minimum contribution in ETH\r\n    uint256 public constant MIN_CONTRIBUTION = 100 finney;           \r\n    // Contributions in wei for each address\r\n    mapping(address => uint256) public contributions;\r\n    // Refund state for each address\r\n    mapping(address => bool) public refunds;\r\n    // Company wallet that will receive the ETH\r\n    address public companyWallet;     \r\n\r\n    // Yoohoo someone contributed !\r\n    event Contribute(address indexed _from, uint _amount); \r\n    // Token <> ETH rate updated\r\n    event TokenRateUpdated(uint _newRate);                  \r\n    // ETH Refund \r\n    event Refunded(address indexed _from, uint _amount);    \r\n    \r\n    modifier belowTotalSupply {\r\n        require(tokensDistributed < TOKENS_TOTAL_SUPPLY);\r\n        _;\r\n    }\r\n\r\n    modifier belowHardCap {\r\n        require(tokensDistributed < TOKENS_FOR_SALE);\r\n        _;\r\n    }\r\n\r\n    modifier adminOnly {\r\n        require(msg.sender == owner || admins[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier crowdsaleFailed {\r\n        require(isFailed());\r\n        _;\r\n    }\r\n\r\n    modifier crowdsaleSuccess {\r\n        require(isSuccess());\r\n        _;\r\n    }\r\n\r\n    modifier duringSale {\r\n        require(now < endIco);\r\n        require((now > startPresale && now < endPresale) || now > startIco);\r\n        _;\r\n    }\r\n\r\n    modifier afterSale {\r\n        require(now > endIco);\r\n        _;\r\n    }\r\n\r\n    modifier aboveMinimum {\r\n        require(msg.value >= MIN_CONTRIBUTION);\r\n        _;\r\n    }\r\n\r\n    /* \r\n     * Constructor\r\n     * Creating the new Token smart contract\r\n     * and setting its owner to the current sender\r\n     * \r\n     */\r\n    function AcjCrowdsale(\r\n        uint _presaleStart,\r\n        uint _presaleEnd,\r\n        uint _icoStart,\r\n        uint _icoEnd,\r\n        uint256 _rate,\r\n        address _token\r\n    ) public \r\n    {\r\n        require(_presaleEnd > _presaleStart);\r\n        require(_icoStart > _presaleEnd);\r\n        require(_icoEnd > _icoStart);\r\n        require(_rate > 0); \r\n\r\n        startPresale = _presaleStart;\r\n        endPresale = _presaleEnd;\r\n        startIco = _icoStart;\r\n        endIco = _icoEnd;\r\n        ethTokenRate = _rate;\r\n        \r\n        admins[msg.sender] = true;\r\n        companyWallet = msg.sender;\r\n\r\n        token = _token;\r\n    }\r\n\r\n    /*\r\n     * Fallback payable\r\n     */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /* Crowdsale staff only */\r\n    /*\r\n     * Admin management\r\n     */\r\n    function addAdmin(address _adr) external onlyOwner {\r\n        require(_adr != address(0));\r\n        admins[_adr] = true;\r\n    }\r\n\r\n    function removeAdmin(address _adr) external onlyOwner {\r\n        require(_adr != address(0));\r\n        admins[_adr] = false;\r\n    }\r\n\r\n    /*\r\n     * Change the company wallet\r\n     */\r\n    function updateCompanyWallet(address _wallet) external adminOnly {\r\n        companyWallet = _wallet;\r\n    }\r\n\r\n    /*\r\n     *  Change the owner of the token\r\n     */\r\n    function proposeTokenOwner(address _newOwner) external adminOnly {\r\n        AcjToken _token = AcjToken(token);\r\n        _token.proposeNewOwner(_newOwner);\r\n    }\r\n\r\n    function acceptTokenOwnership() external onlyOwner {    \r\n        AcjToken _token = AcjToken(token);\r\n        _token.acceptOwnership();\r\n    }\r\n\r\n    /*\r\n     * Activate the token\r\n     */\r\n    function activateToken() external adminOnly crowdsaleSuccess afterSale {\r\n        AcjToken _token = AcjToken(token);\r\n        _token.activate();\r\n    }\r\n\r\n    /* \r\n     * Adjust the token value before the ICO\r\n     */\r\n    function adjustTokenExchangeRate(uint _rate) external adminOnly {\r\n        require(now > endPresale && now < startIco);\r\n        ethTokenRate = _rate;\r\n        TokenRateUpdated(_rate);\r\n    }\r\n\r\n    /* \r\n     * Start therefund period\r\n     * Each contributor has to claim own  ETH \r\n     */     \r\n    function refundContribution() external crowdsaleFailed afterSale {\r\n        require(!refunds[msg.sender]);\r\n        require(contributions[msg.sender] > 0);\r\n\r\n        uint256 _amount = contributions[msg.sender];\r\n        tokenBalances[msg.sender] = 0;\r\n        refunds[msg.sender] = true;\r\n        Refunded(msg.sender, contributions[msg.sender]);\r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    /*\r\n     * After the refund period, remaining tokens\r\n     * are transfered to the company wallet\r\n     * Allow withdrawal at any time if the ICO is a success.\r\n     */     \r\n    function withdrawUnclaimed() external adminOnly {\r\n        require(now > endIco + REFUND_PERIOD || isSuccess());\r\n        companyWallet.transfer(this.balance);\r\n    }\r\n\r\n    /*\r\n     * Pre-ICO and offline Investors, collaborators and team tokens\r\n     */\r\n    function reserveTokens(address _beneficiary, uint256 _tokensQty) external adminOnly belowTotalSupply {\r\n        require(_beneficiary != address(0));\r\n        uint _distributed = tokensDistributed.add(_tokensQty);\r\n\r\n        require(_distributed <= TOKENS_TOTAL_SUPPLY);\r\n\r\n        tokenBalances[_beneficiary] = _tokensQty.add(tokenBalances[_beneficiary]);\r\n        tokensDistributed = _distributed;\r\n\r\n        AcjToken _token = AcjToken(token);\r\n        _token.initialTransfer(_beneficiary, _tokensQty);\r\n    }\r\n\r\n    /*\r\n     * Actually buy the tokens\r\n     * requires an active sale time\r\n     * and amount above the minimum contribution\r\n     * and sold tokens inferior to tokens for sale\r\n     */     \r\n    function buyTokens(address _beneficiary) public payable duringSale aboveMinimum belowHardCap {\r\n        require(_beneficiary != address(0));\r\n        uint256 _weiAmount = msg.value;        \r\n        uint256 _tokensQty = msg.value.mul(getBonus(_weiAmount));\r\n        uint256 _distributed = _tokensQty.add(tokensDistributed);\r\n        uint256 _sold = _tokensQty.add(tokensSold);\r\n\r\n        require(_distributed <= TOKENS_TOTAL_SUPPLY);\r\n        require(_sold <= TOKENS_FOR_SALE);\r\n\r\n        contributions[_beneficiary] = _weiAmount.add(contributions[_beneficiary]);\r\n        tokenBalances[_beneficiary] = _tokensQty.add(tokenBalances[_beneficiary]);\r\n        weiReceived = weiReceived.add(_weiAmount);\r\n        tokensDistributed = _distributed;\r\n        tokensSold = _sold;\r\n\r\n        Contribute(_beneficiary, msg.value);\r\n\r\n        AcjToken _token = AcjToken(token);\r\n        _token.initialTransfer(_beneficiary, _tokensQty);\r\n    }\r\n\r\n    /*\r\n     * Crowdsale Helpers \r\n     */\r\n    function hasEnded() public view returns(bool) {\r\n        return now > endIco;\r\n    }\r\n\r\n    /*\r\n     * Checks if the crowdsale is a success\r\n     */\r\n    function isSuccess() public view returns(bool) {\r\n        if (tokensDistributed >= TOKENS_SOFT_CAP) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /*\r\n     * Checks if the crowdsale failed\r\n     */\r\n    function isFailed() public view returns(bool) {\r\n        if (tokensDistributed < TOKENS_SOFT_CAP && now > endIco) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* \r\n     * Bonus calculations\r\n     * Either time or ETH quantity based \r\n     */\r\n    function getBonus(uint256 _wei) internal constant returns(uint256 ethToAcj) {\r\n        uint256 _bonus = 0;\r\n\r\n        // Time based bonus\r\n        if (endPresale > now) {\r\n            _bonus = _bonus.add(BONUS_PRESALE); \r\n        }\r\n\r\n        // ETH Quantity based bonus\r\n        if (_wei >= BONUS_HI_QTY) { \r\n            _bonus = _bonus.add(BONUS_HI);\r\n        } else if (_wei >= BONUS_MID_QTY) {\r\n            _bonus = _bonus.add(BONUS_MID);\r\n        }\r\n\r\n        return ethTokenRate.mul(100 + _bonus) / 100;\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"startPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_PRESALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSuccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"adjustTokenExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_MID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawUnclaimed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_SOFT_CAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_CONTRIBUTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_TOTAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokensQty\",\"type\":\"uint256\"}],\"name\":\"reserveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFUND_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refunds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeTokenOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_FOR_SALE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"updateCompanyWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_HI_QTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethTokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_MID_QTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_HI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_presaleStart\",\"type\":\"uint256\"},{\"name\":\"_presaleEnd\",\"type\":\"uint256\"},{\"name\":\"_icoStart\",\"type\":\"uint256\"},{\"name\":\"_icoEnd\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Contribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"TokenRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"}]", "ContractName": "AcjCrowdsale", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000005a499620000000000000000000000000000000000000000000000000000000005a71a174000000000000000000000000000000000000000000000000000000005a729ed0000000000000000000000000000000000000000000000000000000005a968b7400000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000a4697c54f7dde97478afe4d233f477ecbfb9e5a0", "Library": "", "SwarmSource": "bzzr://d16a1c65eef09af6b971a4f0334c1d1da1a744cebf3bcf41e79a4006ea2f1929"}]}