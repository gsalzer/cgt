{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.8;\r\n\r\ncontract WinMatrix\r\n {\r\n   function getCoeff(uint16 n) external returns (uint256);\r\n   function getBetsProcessed() external constant returns (uint16);\r\n }\r\n\r\ncontract SmartRouletteToken \r\n{\r\n   function emission(address player, address partner, uint256 value_bet, uint256 coef_player, uint256 coef_partner) external returns(uint256, uint8);\r\n   function isOperationBlocked() external constant returns (bool);\r\n}\r\n\r\ncontract SmartAffiliate \r\n{   \r\n   function getAffiliateInfo(address player) external constant returns(address affiliate, uint16 coef_affiliate, uint16 coef_player);\r\n}\r\n\r\n/*\r\n** User interface for SmartRoulette https://smartroulette.io\r\n*/\r\ncontract SmartRoulette\r\n{\r\n  address developer;\r\n  address operator;\r\n\r\n  // Wait BlockDelay blocks before generate random number\r\n  uint8 BlockDelay;\r\n\r\n  // Maximum bet value for game (one credit is currentMaxBet/256)\r\n  uint256 currentMaxBet;    \r\n\r\n  // maximum games count per block\r\n  uint64 maxGamblesPerBlock;\r\n        \r\n  // Enable\\disable to place new bets\r\n  bool ContractState;\r\n\r\n  // table with winner coefficients\r\n  WinMatrix winMatrix;\r\n\r\n  SmartRouletteToken smartToken;\r\n\r\n  address public profitDistributionContract;\r\n\r\n  SmartAffiliate smartAffiliateContract;\r\n\r\n  uint16 constant maxTypeBets = 157;\r\n  \r\n  // Default coef for token emission (if SmartAffiliate contract is not setup)\r\n  uint16 CoefPlayerEmission;   \r\n  // \r\n  mapping (uint8 => uint8) private minCreditsOnBet;\r\n  mapping (uint8 => uint8) private maxCreditsOnBet;\r\n\r\n  struct GameInfo\r\n  {\r\n       address player;\r\n       uint256 blockNumber;\r\n       uint8 wheelResult;\r\n       uint256 bets;\r\n       bytes32 values;\r\n       bytes32 values2;\r\n  } \r\n       \r\n  GameInfo[] private gambles;\r\n\r\n   enum GameStatus {Success, Skipped, Stop}\r\n\r\n   enum BetTypes{number0, number1,number2,number3,number4,number5,number6,number7,number8,number9,\r\n     number10,number11,number12,number13,number14,number15,number16,number17,number18,number19,number20,number21,\r\n     number22,number23,number24,number25,number26,number27,number28,number29,number30,number31,number32,number33,\r\n     number34,number35,number36, red, black, odd, even, dozen1,dozen2,dozen3, column1,column2,column3, low,high,\r\n     pair_01, pair_02, pair_03, pair_12, pair_23, pair_36, pair_25, pair_14, pair_45, pair_56, pair_69, pair_58, pair_47,\r\n     pair_78, pair_89, pair_912, pair_811, pair_710, pair_1011, pair_1112, pair_1215, pair_1518, pair_1617, pair_1718, pair_1720,\r\n     pair_1619, pair_1922, pair_2023, pair_2124, pair_2223, pair_2324, pair_2528, pair_2629, pair_2730, pair_2829, pair_2930, pair_1114,\r\n     pair_1013, pair_1314, pair_1415, pair_1316, pair_1417, pair_1821, pair_1920, pair_2021, pair_2225, pair_2326, pair_2427, pair_2526,\r\n     pair_2627, pair_2831, pair_2932, pair_3033, pair_3132, pair_3233, pair_3134, pair_3235, pair_3336, pair_3435, pair_3536, corner_0_1_2_3,\r\n     corner_1_2_5_4, corner_2_3_6_5, corner_4_5_8_7, corner_5_6_9_8, corner_7_8_11_10, corner_8_9_12_11, corner_10_11_14_13, corner_11_12_15_14,\r\n     corner_13_14_17_16, corner_14_15_18_17, corner_16_17_20_19, corner_17_18_21_20, corner_19_20_23_22, corner_20_21_24_23, corner_22_23_26_25,\r\n     corner_23_24_27_26, corner_25_26_29_28, corner_26_27_30_29, corner_28_29_32_31, corner_29_30_33_32, corner_31_32_35_34, corner_32_33_36_35,\r\n     three_0_2_3, three_0_1_2, three_1_2_3, three_4_5_6, three_7_8_9, three_10_11_12, three_13_14_15, three_16_17_18, three_19_20_21, three_22_23_24,\r\n     three_25_26_27, three_28_29_30, three_31_32_33, three_34_35_36, six_1_2_3_4_5_6, six_4_5_6_7_8_9, six_7_8_9_10_11_12, six_10_11_12_13_14_15,\r\n     six_13_14_15_16_17_18, six_16_17_18_19_20_21, six_19_20_21_22_23_24, six_22_23_24_25_26_27, six_25_26_27_28_29_30, six_28_29_30_31_32_33,\r\n     six_31_32_33_34_35_36}\r\n   \r\n\r\n   function SmartRoulette() internal\r\n   {        \r\n        developer  = msg.sender;\r\n        operator   = msg.sender;\r\n        \r\n        winMatrix = WinMatrix(0x073D6621E9150bFf9d1D450caAd3c790b6F071F2);\r\n        if (winMatrix.getBetsProcessed() != maxTypeBets) throw;\r\n        \r\n        smartToken = SmartRouletteToken(0xcced5b8288086be8c38e23567e684c3740be4d48);\r\n\r\n        currentMaxBet = 2560 finney; // 2.56 ether\r\n        BlockDelay = 1;        \r\n        maxGamblesPerBlock = 5;        \r\n        ContractState  = true;  \r\n        bankrolLimit = 277 ether;\r\n        profitLimit  = 50 ether;\r\n        CoefPlayerEmission = 100; // default 1%\r\n   }\r\n\r\n   function changeSettings(uint256 newMaxBet, uint8 newBlockDelay) public onlyDeveloper \r\n   {             \r\n      BlockDelay = newBlockDelay;\r\n      // rounds to 2 digts\r\n      newMaxBet = newMaxBet / 2560000000000000000 * 2560000000000000000;  \r\n      if (newMaxBet != currentMaxBet) \r\n      {\r\n        currentMaxBet = newMaxBet;\r\n        SettingsChanged();\r\n      }\r\n   }\r\n\r\n   uint256 bankrolLimit;\r\n   uint256 profitLimit;\r\n   uint256 lastDistributedProfit;\r\n   uint256 lastDateDistributedProfit;\r\n   \r\n   function getDistributeProfitsInfo() public constant returns (uint256 lastProfit, uint256 lastDate)\r\n   {\r\n      lastProfit = lastDistributedProfit;\r\n      lastDate = lastDateDistributedProfit;\r\n   }\r\n\r\n   function setProfitDistributionContract(address contractAddress) onlyDeveloper\r\n   {\r\n      if (profitDistributionContract > 0) throw;\r\n      profitDistributionContract = contractAddress;\r\n   }\r\n\r\n   function setSmartAffiliateContract(address contractAddress) onlyDeveloper\r\n   {\r\n      if (address(smartAffiliateContract) > 0) throw;\r\n      smartAffiliateContract = SmartAffiliate(contractAddress);\r\n   }\r\n\r\n   function distributeProfits(uint256 gasValue) onlyDeveloperOrOperator\r\n   {\r\n      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit+profitLimit))\r\n      {\r\n         uint256 diff = this.balance - bankrolLimit;\r\n         if (address(profitDistributionContract).call.gas(gasValue).value(diff)() == false) throw;\r\n         lastDistributedProfit = diff;\r\n         lastDateDistributedProfit = block.timestamp;\r\n      }      \r\n   }\r\n\r\n   function getTokenSettings() public constant returns(uint16 Coef_player, uint256 BankrolLimit, uint256 ProfitLimit)\r\n   {\r\n      Coef_player = CoefPlayerEmission;      \r\n      BankrolLimit = bankrolLimit;\r\n      ProfitLimit = profitLimit;\r\n   }\r\n\r\n   function changeTokenSettings(uint16 newCoef_player, uint256 newBankrolLimit, uint256 newProfitLimit) onlyDeveloper\r\n   {\r\n      CoefPlayerEmission  = newCoef_player;      \r\n      bankrolLimit = newBankrolLimit;\r\n      profitLimit  = newProfitLimit;\r\n   }\r\n\r\n   function changeMinBet(uint8[157] value) onlyDeveloper\r\n   {\r\n     // value[i] == 0 means skip this value\r\n     // value[i] == 255 means value will be 0\r\n     // Raw mapping minCreditsOnBet changes from 0 to 254, \r\n     // when compare with real bet we add +1, so min credits changes from 1 to 255\r\n     for(var i=0;i<157;i++) \r\n     {\r\n        if (value[i] > 0) \r\n        {\r\n           if (value[i] == 255)\r\n             minCreditsOnBet[i] = 0;     \r\n           else  \r\n             minCreditsOnBet[i] = value[i];\r\n        }\r\n     }\r\n     SettingsChanged();\r\n   }\r\n\r\n   function changeMaxBet(uint8[157] value) onlyDeveloper\r\n   {\r\n     // value[i] == 0 means skip this value\r\n     // value[i] == 255 means value will be 0\r\n     // Raw mapping maxCreditsOnBet hold values that reduce max bet from 255 to 0     \r\n     // If we want to calculate real max bet value we should do: 256 - maxCreditsOnBet[i]\r\n     // example: if mapping holds 0 it means, that max bet will be 256 - 0 = 256\r\n     //          if mapping holds 50 it means, that max bet will be 256 - 50 = 206 \r\n     for(var i=0;i<157;i++) \r\n     {\r\n       if (value[i] > 0) \r\n       {\r\n          if (value[i] == 255)\r\n             maxCreditsOnBet[i] = 0;     \r\n           else  \r\n             maxCreditsOnBet[i] = 255 - value[i];              \r\n       }\r\n     }\r\n     SettingsChanged();\r\n   }\r\n   \r\n   function deleteContract() onlyDeveloper  \r\n   {\r\n        suicide(msg.sender);\r\n   }\r\n\r\n   // bit from 0 to 255\r\n   function isBitSet(uint256 data, uint8 bit) private constant returns (bool ret)\r\n   {\r\n       assembly {\r\n            ret := iszero(iszero(and(data, exp(2,bit))))\r\n        }\r\n        return ret;\r\n   }\r\n\r\n   // unique combination of bet and wheelResult, used for access to WinMatrix\r\n   function getIndex(uint16 bet, uint16 wheelResult) private constant returns (uint16)\r\n   {\r\n      return (bet+1)*256 + (wheelResult+1);\r\n   }\r\n\r\n   // n form 1 <= to <= 32\r\n   function getBetValue(bytes32 values, uint8 n, uint8 nBit) private constant returns (uint256)\r\n   {\r\n        // bet in credits (1..256) \r\n        uint256 bet = uint256(values[32 - n]) + 1;\r\n\r\n        if (bet < uint256(minCreditsOnBet[nBit]+1)) throw;   //default: bet < 0+1\r\n        if (bet > uint256(256-maxCreditsOnBet[nBit])) throw; //default: bet > 256-0      \r\n\r\n        return currentMaxBet * bet / 256;        \r\n   }\r\n\r\n   // n - number player bet\r\n   // nBit - betIndex\r\n   function getBetValueByGamble(GameInfo memory gamble, uint8 n, uint8 nBit) private constant returns (uint256) \r\n   {\r\n      if (n <= 32) return getBetValue(gamble.values , n, nBit);\r\n      if (n <= 64) return getBetValue(gamble.values2, n - 32, nBit);\r\n      // there are 64 maximum unique bets (positions) in one game\r\n      throw;\r\n   }\r\n  \r\n   function totalGames() constant returns (uint256)\r\n   {\r\n       return gambles.length;\r\n   }\r\n   \r\n   function getSettings() constant returns(uint256 maxBet, uint256 oneCredit, uint8[157] _minCreditsOnBet, uint8[157] _maxCreditsOnBet, uint8 blockDelay, bool contractState)\r\n    {\r\n        maxBet    = currentMaxBet;\r\n        oneCredit = currentMaxBet / 256; \r\n        blockDelay = BlockDelay;      \r\n        for(var i = 0;i < maxTypeBets;i++)  \r\n        {\r\n          _minCreditsOnBet[i] = minCreditsOnBet[i] + 1;\r\n          _maxCreditsOnBet[i] = 255 - maxCreditsOnBet[i];\r\n        }     \r\n        contractState        = ContractState;\r\n    }\r\n   \r\n    modifier onlyDeveloper() \r\n    {\r\n       if (msg.sender != developer) throw;\r\n       _;\r\n    }\r\n\r\n    modifier onlyDeveloperOrOperator() \r\n    {\r\n       if (msg.sender != developer && msg.sender != operator) throw;\r\n       _;\r\n    }\r\n\r\n   function disableBetting_only_Dev()\r\n    onlyDeveloperOrOperator\r\n    {\r\n        ContractState=false;\r\n    }\r\n\r\n\r\n    function changeOperator(address newOperator) onlyDeveloper\r\n    {\r\n       operator = newOperator;\r\n    }\r\n\r\n    function enableBetting_only_Dev()\r\n    onlyDeveloperOrOperator\r\n    {\r\n        ContractState=true;\r\n\r\n    }\r\n\r\n    event PlayerBet(uint256 gambleId, uint256 playerTokens);\r\n    event EndGame(address player, uint8 result, uint256 gambleId);\r\n    event SettingsChanged();\r\n    event ErrorLog(address player, string message);\r\n    event GasLog(string msg, uint256 level, uint256 gas);\r\n\r\n   function totalBetValue(GameInfo memory g) private constant returns (uint256)\r\n   {              \r\n       uint256 totalBetsValue = 0; \r\n       uint8 nPlayerBetNo = 0;\r\n       uint8 betsCount = uint8(bytes32(g.bets)[0]);\r\n\r\n       for(uint8 i = 0; i < maxTypeBets;i++) \r\n        if (isBitSet(g.bets, i))\r\n        {\r\n          totalBetsValue += getBetValueByGamble(g, nPlayerBetNo+1, i);\r\n          nPlayerBetNo++;\r\n\r\n          if (betsCount == 1) break;\r\n          betsCount--;          \r\n        }\r\n\r\n       return totalBetsValue;\r\n   }\r\n\r\n   function totalBetCount(GameInfo memory g) private constant returns (uint256)\r\n   {              \r\n       uint256 totalBets = 0; \r\n       for(uint8 i=0; i < maxTypeBets;i++) \r\n        if (isBitSet(g.bets, i)) totalBets++;          \r\n       return totalBets;   \r\n   }\r\n\r\n   function placeBet(uint256 bets, bytes32 values1,bytes32 values2) public payable\r\n   {\r\n       if (ContractState == false)\r\n       {\r\n         ErrorLog(msg.sender, \"ContractDisabled\");\r\n         if (msg.sender.send(msg.value) == false) throw;\r\n         return;\r\n       }\r\n\r\n       var gamblesLength = gambles.length;\r\n\r\n       if (gamblesLength > 0)\r\n       {\r\n          uint8 gamblesCountInCurrentBlock = 0;\r\n          for(var i = gamblesLength - 1;i > 0; i--)\r\n          {\r\n            if (gambles[i].blockNumber == block.number) \r\n            {\r\n               if (gambles[i].player == msg.sender)\r\n               {\r\n                   ErrorLog(msg.sender, \"Play twice the same block\");\r\n                   if (msg.sender.send(msg.value) == false) throw;\r\n                   return;\r\n               }\r\n\r\n               gamblesCountInCurrentBlock++;\r\n               if (gamblesCountInCurrentBlock >= maxGamblesPerBlock)\r\n               {\r\n                  ErrorLog(msg.sender, \"maxGamblesPerBlock\");\r\n                  if (msg.sender.send(msg.value) == false) throw;\r\n                  return;\r\n               }\r\n            }\r\n            else\r\n            {\r\n               break;\r\n            }\r\n          }\r\n       }\r\n       \r\n       var _currentMaxBet = currentMaxBet;\r\n\r\n       if (msg.value < _currentMaxBet/256 || bets == 0)\r\n       {\r\n          ErrorLog(msg.sender, \"Wrong bet value\");\r\n          if (msg.sender.send(msg.value) == false) throw;\r\n          return;\r\n       }\r\n\r\n       if (msg.value > _currentMaxBet)\r\n       {\r\n          ErrorLog(msg.sender, \"Limit for table\");\r\n          if (msg.sender.send(msg.value) == false) throw;\r\n          return;\r\n       }\r\n\r\n       GameInfo memory g = GameInfo(msg.sender, block.number, 37, bets, values1,values2);\r\n\r\n       if (totalBetValue(g) != msg.value)\r\n       {\r\n          ErrorLog(msg.sender, \"Wrong bet value\");\r\n          if (msg.sender.send(msg.value) == false) throw;\r\n          return;\r\n       }       \r\n\r\n       address affiliate = 0;\r\n       uint16 coef_affiliate = 0;\r\n       uint16 coef_player;\r\n       if (address(smartAffiliateContract) > 0)\r\n       {        \r\n         (affiliate, coef_affiliate, coef_player) = smartAffiliateContract.getAffiliateInfo(msg.sender);   \r\n       }\r\n       else\r\n       {\r\n         coef_player = CoefPlayerEmission;\r\n       }\r\n\r\n       uint256 playerTokens;\r\n       uint8 errorCodeEmission;\r\n       \r\n       (playerTokens, errorCodeEmission) = smartToken.emission(msg.sender, affiliate, msg.value, coef_player, coef_affiliate);\r\n       if (errorCodeEmission != 0)\r\n       {\r\n          if (errorCodeEmission == 1) \r\n            ErrorLog(msg.sender, \"token operations stopped\");\r\n          else if (errorCodeEmission == 2) \r\n            ErrorLog(msg.sender, \"contract is not in a games list\");\r\n          else if (errorCodeEmission == 3) \r\n            ErrorLog(msg.sender, \"incorect player address\");\r\n          else if (errorCodeEmission == 4) \r\n            ErrorLog(msg.sender, \"incorect value bet\");\r\n          else if (errorCodeEmission == 5) \r\n            ErrorLog(msg.sender, \"incorect Coefficient emissions\");\r\n          \r\n          if (msg.sender.send(msg.value) == false) throw;\r\n          return;\r\n       }\r\n\r\n       gambles.push(g);\r\n\r\n       PlayerBet(gamblesLength, playerTokens); \r\n   }\r\n\r\n    function Invest() payable onlyDeveloper\r\n    {      \r\n    }\r\n\r\n    function GetGameIndexesToProcess() public constant returns (uint256[64] gameIndexes)\r\n    {           \r\n      uint8 index = 0;\r\n      for(int256 i = int256(gambles.length) - 1;i >= 0;i--)\r\n      {      \r\n         GameInfo memory g = gambles[uint256(i)];\r\n         if (block.number - g.blockNumber >= 256) break;\r\n\r\n         if (g.wheelResult == 37 && block.number >= g.blockNumber + BlockDelay)\r\n         { \r\n            gameIndexes[index++] = uint256(i + 1);\r\n         }\r\n      }      \r\n    }\r\n\r\n    uint256 lastBlockGamesProcessed;\r\n\r\n    function ProcessGames(uint256[] gameIndexes, bool simulate) \r\n    {\r\n      if (!simulate)\r\n      {\r\n         if (lastBlockGamesProcessed == block.number)  return;\r\n         lastBlockGamesProcessed = block.number;\r\n      }\r\n\r\n      uint8 delay = BlockDelay;\r\n      uint256 length = gameIndexes.length;\r\n      bool success = false;\r\n      for(uint256 i = 0;i < length;i++)\r\n      {      \r\n         if (ProcessGame(gameIndexes[i], delay) == GameStatus.Success) success = true;         \r\n      }      \r\n      if (simulate && !success) throw;\r\n    }\r\n    \r\n    function ProcessGameExt(uint256 index) public returns (GameStatus)\r\n    {\r\n      return ProcessGame(index, BlockDelay);\r\n    }\r\n\r\n    function ProcessGame(uint256 index, uint256 delay) private returns (GameStatus)\r\n    {            \r\n      GameInfo memory g = gambles[index];\r\n      if (block.number - g.blockNumber >= 256) return GameStatus.Stop;\r\n\r\n      if (g.wheelResult == 37 && block.number > g.blockNumber + delay)\r\n      {            \r\n         gambles[index].wheelResult = getRandomNumber(g.player, g.blockNumber);\r\n                 \r\n         uint256 playerWinnings = getGameResult(gambles[index]);\r\n         if (playerWinnings > 0) \r\n         {\r\n            if (g.player.send(playerWinnings) == false) throw;\r\n         }\r\n\r\n         EndGame(g.player, gambles[index].wheelResult, index);\r\n         return GameStatus.Success;\r\n      }\r\n\r\n      return GameStatus.Skipped;\r\n    }\r\n\r\n    function getRandomNumber(address player, uint256 playerblock) private returns(uint8 wheelResult)\r\n    {\r\n        // block.blockhash - hash of the given block - only works for 256 most recent blocks excluding current\r\n        bytes32 blockHash = block.blockhash(playerblock+BlockDelay); \r\n        \r\n        if (blockHash==0) \r\n        {\r\n          ErrorLog(msg.sender, \"Cannot generate random number\");\r\n          wheelResult = 200;\r\n        }\r\n        else\r\n        {\r\n          bytes32 shaPlayer = sha3(player, blockHash);\r\n    \r\n          wheelResult = uint8(uint256(shaPlayer)%37);\r\n        }    \r\n    }\r\n\r\n    function calculateRandomNumberByBlockhash(uint256 blockHash, address player) public constant returns (uint8 wheelResult) \r\n    { \r\n          bytes32 shaPlayer = sha3(player, blockHash);\r\n    \r\n          wheelResult = uint8(uint256(shaPlayer)%37);\r\n    }\r\n\r\n    function emergencyFixGameResult(uint64 gambleId, uint256 blockHash) onlyDeveloperOrOperator\r\n    {\r\n      // Probably this function will never be called, but\r\n      // if game was not spinned in 256 blocks then block.blockhash will returns always 0 and \r\n      // we should fix this manually (you can check result with public function calculateRandomNumberByBlockhash)\r\n      GameInfo memory gamble = gambles[gambleId];\r\n      if (gamble.wheelResult != 200) throw;\r\n\r\n      gambles[gambleId].wheelResult = calculateRandomNumberByBlockhash(blockHash, gamble.player);      \r\n\r\n      uint256 playerWinnings = getGameResult(gambles[gambleId]);\r\n      if (playerWinnings > 0)\r\n      {\r\n        if (gamble.player.send(playerWinnings) == false) throw;\r\n      }      \r\n\r\n      EndGame(gamble.player, gamble.wheelResult, gambleId);\r\n    }\r\n\r\n\r\n    function preliminaryGameResult(uint64 gambleIndex) constant returns (uint64 gambleId, address player, uint256 blockNumber, uint256 totalWin, uint8 wheelResult, uint256 bets, uint256 values1, uint256 values2, uint256 nTotalBetValue, uint256 nTotalBetCount) \r\n    { \r\n      GameInfo memory g = gambles[uint256(gambleIndex)];\r\n      \r\n      if (g.wheelResult == 37 && block.number > g.blockNumber + BlockDelay)\r\n      {\r\n         gambles[gambleIndex].wheelResult = getRandomNumber(g.player, g.blockNumber);\r\n         return getGame(gambleIndex);\r\n      }\r\n      throw;      \r\n    }\r\n\r\n    // Preliminary game result before real transaction is mined\r\n    function calcRandomNumberAndGetPreliminaryGameResult(uint256 blockHash, uint64 gambleIndex) constant returns (uint64 gambleId, address player, uint256 blockNumber, uint256 totalWin, uint8 wheelResult, uint256 bets, uint256 values1, uint256 values2, uint256 nTotalBetValue, uint256 nTotalBetCount)\r\n    { \r\n      GameInfo memory g = gambles[uint256(gambleIndex)];      \r\n      g.wheelResult = calculateRandomNumberByBlockhash(blockHash, g.player);      \r\n\r\n      gambleId = gambleIndex;\r\n      player = g.player;\r\n      wheelResult = g.wheelResult;      \r\n      totalWin = getGameResult(g);\r\n      blockNumber = g.blockNumber;              \r\n      nTotalBetValue = totalBetValue(g);\r\n      nTotalBetCount = totalBetCount(g);\r\n      bets = g.bets;\r\n      values1 = uint256(g.values);\r\n      values2 = uint256(g.values2);     \r\n    }\r\n\r\n    function getGameResult(GameInfo memory game) private constant returns (uint256 totalWin) \r\n    {\r\n        totalWin = 0;\r\n        uint8 nPlayerBetNo = 0;\r\n        // we sent count bets at last byte \r\n        uint8 betsCount = uint8(bytes32(game.bets)[0]); \r\n        for(uint8 i=0; i<maxTypeBets; i++)\r\n        {                      \r\n            if (isBitSet(game.bets, i))\r\n            {              \r\n              var winMul = winMatrix.getCoeff(getIndex(i, game.wheelResult)); // get win coef\r\n              if (winMul > 0) winMul++; // + return player bet\r\n              totalWin += winMul * getBetValueByGamble(game, nPlayerBetNo+1,i);\r\n              nPlayerBetNo++; \r\n\r\n              if (betsCount == 1) break;\r\n              betsCount--;\r\n            }\r\n        }        \r\n    }\r\n\r\n    function getGame(uint64 index) constant returns (uint64 gambleId, address player, uint256 blockNumber, uint256 totalWin, uint8 wheelResult, uint256 bets, uint256 values1, uint256 values2, uint256 nTotalBetValue, uint256 nTotalBetCount) \r\n    {\r\n        gambleId = index;\r\n        player = gambles[index].player;\r\n        totalWin = getGameResult(gambles[index]);\r\n        blockNumber = gambles[index].blockNumber;        \r\n        wheelResult = gambles[index].wheelResult;\r\n        nTotalBetValue = totalBetValue(gambles[index]);\r\n        nTotalBetCount = totalBetCount(gambles[index]);\r\n        bets = gambles[index].bets;\r\n        values1 = uint256(gambles[index].values);\r\n        values2 = uint256(gambles[index].values2);        \r\n    }\r\n\r\n   function() \r\n   {\r\n      throw;\r\n   }\r\n   \r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint8[157]\"}],\"name\":\"changeMinBet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint8[157]\"}],\"name\":\"changeMaxBet\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gambleId\",\"type\":\"uint64\"},{\"name\":\"blockHash\",\"type\":\"uint256\"}],\"name\":\"emergencyFixGameResult\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bets\",\"type\":\"uint256\"},{\"name\":\"values1\",\"type\":\"bytes32\"},{\"name\":\"values2\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSettings\",\"outputs\":[{\"name\":\"Coef_player\",\"type\":\"uint16\"},{\"name\":\"BankrolLimit\",\"type\":\"uint256\"},{\"name\":\"ProfitLimit\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDistributeProfitsInfo\",\"outputs\":[{\"name\":\"lastProfit\",\"type\":\"uint256\"},{\"name\":\"lastDate\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCoef_player\",\"type\":\"uint16\"},{\"name\":\"newBankrolLimit\",\"type\":\"uint256\"},{\"name\":\"newProfitLimit\",\"type\":\"uint256\"}],\"name\":\"changeTokenSettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint64\"}],\"name\":\"getGame\",\"outputs\":[{\"name\":\"gambleId\",\"type\":\"uint64\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"totalWin\",\"type\":\"uint256\"},{\"name\":\"wheelResult\",\"type\":\"uint8\"},{\"name\":\"bets\",\"type\":\"uint256\"},{\"name\":\"values1\",\"type\":\"uint256\"},{\"name\":\"values2\",\"type\":\"uint256\"},{\"name\":\"nTotalBetValue\",\"type\":\"uint256\"},{\"name\":\"nTotalBetCount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setSmartAffiliateContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableBetting_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deleteContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gameIndexes\",\"type\":\"uint256[]\"},{\"name\":\"simulate\",\"type\":\"bool\"}],\"name\":\"ProcessGames\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableBetting_only_Dev\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"oneCredit\",\"type\":\"uint256\"},{\"name\":\"_minCreditsOnBet\",\"type\":\"uint8[157]\"},{\"name\":\"_maxCreditsOnBet\",\"type\":\"uint8[157]\"},{\"name\":\"blockDelay\",\"type\":\"uint8\"},{\"name\":\"contractState\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitDistributionContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ProcessGameExt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockHash\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"calculateRandomNumberByBlockhash\",\"outputs\":[{\"name\":\"wheelResult\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasValue\",\"type\":\"uint256\"}],\"name\":\"distributeProfits\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockHash\",\"type\":\"uint256\"},{\"name\":\"gambleIndex\",\"type\":\"uint64\"}],\"name\":\"calcRandomNumberAndGetPreliminaryGameResult\",\"outputs\":[{\"name\":\"gambleId\",\"type\":\"uint64\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"totalWin\",\"type\":\"uint256\"},{\"name\":\"wheelResult\",\"type\":\"uint8\"},{\"name\":\"bets\",\"type\":\"uint256\"},{\"name\":\"values1\",\"type\":\"uint256\"},{\"name\":\"values2\",\"type\":\"uint256\"},{\"name\":\"nTotalBetValue\",\"type\":\"uint256\"},{\"name\":\"nTotalBetCount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Invest\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxBet\",\"type\":\"uint256\"},{\"name\":\"newBlockDelay\",\"type\":\"uint8\"}],\"name\":\"changeSettings\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetGameIndexesToProcess\",\"outputs\":[{\"name\":\"gameIndexes\",\"type\":\"uint256[64]\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setProfitDistributionContract\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"gambleIndex\",\"type\":\"uint64\"}],\"name\":\"preliminaryGameResult\",\"outputs\":[{\"name\":\"gambleId\",\"type\":\"uint64\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"totalWin\",\"type\":\"uint256\"},{\"name\":\"wheelResult\",\"type\":\"uint8\"},{\"name\":\"bets\",\"type\":\"uint256\"},{\"name\":\"values1\",\"type\":\"uint256\"},{\"name\":\"values2\",\"type\":\"uint256\"},{\"name\":\"nTotalBetValue\",\"type\":\"uint256\"},{\"name\":\"nTotalBetCount\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerTokens\",\"type\":\"uint256\"}],\"name\":\"PlayerBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"gambleId\",\"type\":\"uint256\"}],\"name\":\"EndGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SettingsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"ErrorLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"GasLog\",\"type\":\"event\"}]", "ContractName": "SmartRoulette", "CompilerVersion": "v0.4.8+commit.60cc1668", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://a3eb481f3a7d35ecb53e1767d0cc54c5bca56b7fe092f961faaf7e8194858d8b"}]}