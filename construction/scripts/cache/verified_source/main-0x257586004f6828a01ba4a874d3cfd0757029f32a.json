{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract dexBlue{\r\n    \r\n    // Events\r\n\r\n    /** @notice The event, emitted when a trade is settled\r\n      * @param  index Implying the index of the settled trade in the trade array passed to matchTrades() \r\n      */\r\n    event TradeSettled(uint8 index);\r\n\r\n    /** @notice The event, emitted when a trade settlement failed\r\n      * @param  index Implying the index of the failed trade in the trade array passed to matchTrades() \r\n      */\r\n    event TradeFailed(uint8 index);\r\n\r\n    /** @notice The event, emitted after a successful deposit of ETH or token\r\n      * @param  account  The address, which initiated the deposit\r\n      * @param  token    The address of the deposited token (ETH is address(0))\r\n      * @param  amount   The amount deposited in this transaction \r\n      */\r\n    event Deposit(address account, address token, uint256 amount);\r\n\r\n    /** @notice The event, emitted after a successful (multi-sig) withdrawal of deposited ETH or token\r\n      * @param  account  The address, which initiated the withdrawal\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event Withdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice The event, emitted after a user successfully blocked tokens or ETH for a single signature withdrawal\r\n      * @param  account  The address controlling the tokens\r\n      * @param  token    The address of the token which is blocked (ETH is address(0))\r\n      * @param  amount   The amount blocked in this transaction \r\n      */\r\n    event BlockedForSingleSigWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice The event, emitted after a successful single-sig withdrawal of deposited ETH or token\r\n      * @param  account  The address, which initiated the withdrawal\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event SingleSigWithdrawal(address account, address token, uint256 amount);\r\n\r\n    /** @notice The event, emitted once the feeCollector address initiated a withdrawal of collected tokens or ETH via feeWithdrawal()\r\n      * @param  token    The address of the token which is withdrawn (ETH is address(0))\r\n      * @param  amount   The amount withdrawn in this transaction \r\n      */\r\n    event FeeWithdrawal(address token, uint256 amount);\r\n\r\n    /** @notice The event, emitted once an on-chain cancellation of an order was performed\r\n      * @param  hash    The invalidated orders hash \r\n      */\r\n    event OrderCanceled(bytes32 hash);\r\n   \r\n    /** @notice The event, emitted once a address delegation or dedelegation was performed\r\n      * @param  delegator The delegating address,\r\n      * @param  delegate  The delegated address,\r\n      * @param  status    Whether the transaction delegated an address (true) or inactivated an active delegation (false) \r\n      */\r\n    event DelegateStatus(address delegator, address delegate, bool status);\r\n\r\n\r\n    // Mappings \r\n\r\n    mapping(address => mapping(address => uint256)) balances;                           // Users balances (token address > user address > balance amount) (ETH is address(0))\r\n    mapping(address => mapping(address => uint256)) blocked_for_single_sig_withdrawal;  // Users balances they blocked to withdraw without arbiters multi-sig (token address > user address > balance amount) (ETH is address(0))\r\n    mapping(address => uint256) last_blocked_timestamp;                                 // The last timestamp a user blocked tokens to withdraw without arbiters multi-sig\r\n    mapping(bytes32 => bool) processed_withdrawals;                                     // Processed withdrawal hashes\r\n    mapping(bytes32 => uint256) matched;                                                // Orders matched sell_amounts to prevent multiple-/over- matches of the same orders\r\n    mapping(address => address) delegates;                                              // Delegated order signing addresses\r\n\r\n\r\n    // EIP712 (signTypedData)\r\n\r\n    // EIP712 Domain\r\n    struct EIP712_Domain {\r\n        string  name;\r\n        string  version;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n    bytes32          EIP712_DOMAIN_SEPARATOR;\r\n    // Order typehash\r\n    bytes32 constant EIP712_ORDER_TYPEHASH = keccak256(\"Order(address buyTokenAddress,address sellTokenAddress,uint256 buyTokenAmount,uint256 sellTokenAmount,uint64 nonce)\");\r\n    // Withdrawal typehash\r\n    bytes32 constant EIP712_WITHDRAWAL_TYPEHASH = keccak256(\"Withdrawal(address token,uint256 amount,uint64 nonce)\");\r\n        \r\n\r\n    // Utility functions:\r\n\r\n    /** @notice Get the balance of a user for a specific token\r\n      * @param  token  The token address (ETH is token address(0))\r\n      * @param  holder The address holding the token\r\n      * @return The amount of the specified token held by the user \r\n      */\r\n    function getBalance(address token, address holder) constant public returns(uint256){\r\n        return balances[token][holder];\r\n    }\r\n    \r\n    /** @notice Get the balance a user blocked for a single-signature withdrawal (ETH is token address(0))\r\n      * @param  token  The token address (ETH is token address(0))\r\n      * @param  holder The address holding the token\r\n      * @return The amount of the specified token blocked by the user \r\n      */\r\n    function getBlocked(address token, address holder) constant public returns(uint256){\r\n        return blocked_for_single_sig_withdrawal[token][holder];\r\n    }\r\n    \r\n    /** @notice Returns the timestamp of the last blocked balance\r\n      * @param  user  Address of the user which blocked funds\r\n      * @return The last unix timestamp the user blocked funds at, which starts the waiting period for single-sig withdrawals \r\n      */\r\n    function getLastBlockedTimestamp(address user) constant public returns(uint256){\r\n        return last_blocked_timestamp[user];\r\n    }\r\n\r\n\r\n    // Deposit functions:\r\n\r\n    /** @notice Deposit Ether into the smart contract \r\n      */\r\n    function depositEther() public payable{\r\n        balances[address(0)][msg.sender] += msg.value;      // Add the received ETH to the users balance\r\n        emit Deposit(msg.sender, address(0), msg.value);    // Emit a deposit event\r\n    }\r\n    \r\n    /** @notice Fallback function to credit ETH sent to the contract without data \r\n      */\r\n    function() public payable{\r\n        depositEther();                                     // Call the deposit function to credit ETH sent in this transaction\r\n    }\r\n    \r\n    /** @notice Deposit ERC20 tokens into the smart contract (remember to set allowance in the token contract first)\r\n      * @param  token   The address of the token to deposit\r\n      * @param  amount  The amount of tokens to deposit \r\n      */\r\n    function depositToken(address token, uint256 amount) public {\r\n        Token(token).transferFrom(msg.sender, address(this), amount);    // Deposit ERC20\r\n        require(\r\n            checkERC20TransferSuccess(),                                 // Check whether the ERC20 token transfer was successful\r\n            \"ERC20 token transfer failed.\"\r\n        );\r\n        balances[token][msg.sender] += amount;                           // Credit the deposited token to users balance\r\n        emit Deposit(msg.sender, token, amount);                         // Emit a deposit event\r\n    }\r\n        \r\n    // Multi-sig withdrawal functions:\r\n\r\n    /** @notice User-submitted withdrawal with arbiters signature, which withdraws to the users address\r\n      * @param  token   The token to withdraw (ETH is address(address(0)))\r\n      * @param  amount  The amount of tokens to withdraw\r\n      * @param  nonce   The nonce (to salt the hash)\r\n      * @param  v       Multi-signature v\r\n      * @param  r       Multi-signature r\r\n      * @param  s       Multi-signature s \r\n      */\r\n    function multiSigWithdrawal(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 hash = keccak256(abi.encodePacked(                      // Calculate the withdrawal hash from the parameters\r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                token,\r\n                amount,\r\n                nonce,\r\n                address(this)\r\n            ))\r\n        ));\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[ecrecover(hash, v,r,s)]                         // Check if the multi-sig is valid\r\n            && balances[token][msg.sender] >= amount                    // Check if the user holds the required balance\r\n        ){\r\n            processed_withdrawals[hash]  = true;                        // Mark this withdrawal as processed\r\n            balances[token][msg.sender] -= amount;                      // Substract withdrawn token from users balance\r\n            if(token == address(0)){                                    // Withdraw ETH\r\n                require(\r\n                    msg.sender.send(amount),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{                                                      // Withdraw an ERC20 token\r\n                Token(token).transfer(msg.sender, amount);              // Transfer the ERC20 token\r\n                require(\r\n                    checkERC20TransferSuccess(),                        // Check whether the ERC20 token transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] = 0;   // Set possible previous manual blocking of these funds to 0\r\n        \r\n            emit Withdrawal(msg.sender,token,amount);                   // Emit a Withdrawal event\r\n        }else{\r\n            revert();                                                   // Revert the transaction if checks fail\r\n        }\r\n    }    \r\n\r\n    /** @notice User-submitted withdrawal with arbiters signature, which sends tokens to specified address\r\n      * @param  token              The token to withdraw (ETH is address(address(0)))\r\n      * @param  amount             The amount of tokens to withdraw\r\n      * @param  nonce              The nonce (to salt the hash)\r\n      * @param  v                  Multi-signature v\r\n      * @param  r                  Multi-signature r\r\n      * @param  s                  Multi-signature s\r\n      * @param  receiving_address  The address to send the withdrawn token/ETH to\r\n      */\r\n    function multiSigSend(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s, address receiving_address) public {\r\n        bytes32 hash = keccak256(abi.encodePacked(                      // Calculate the withdrawal hash from the parameters \r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                token,\r\n                amount,\r\n                nonce,\r\n                address(this)\r\n            ))\r\n        ));\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[ecrecover(hash, v,r,s)]                         // Check if the multi-sig is valid\r\n            && balances[token][msg.sender] >= amount                    // Check if the user holds the required balance\r\n        ){\r\n            processed_withdrawals[hash]  = true;                        // Mark this withdrawal as processed\r\n            balances[token][msg.sender] -= amount;                      // Substract the withdrawn balance from the users balance\r\n            if(token == address(0)){                                    // Process an ETH withdrawal\r\n                require(\r\n                    receiving_address.send(amount),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{                                                      // Withdraw an ERC20 token\r\n                Token(token).transfer(receiving_address, amount);       // Transfer the ERC20 token\r\n                require(\r\n                    checkERC20TransferSuccess(),                        // Check whether the ERC20 token transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] = 0;   // Set possible previous manual blocking of these funds to 0\r\n            \r\n            emit Withdrawal(msg.sender,token,amount);                   // Emit a Withdrawal event\r\n        }else{\r\n            revert();                                                   // Revert the transaction if checks fail\r\n        }\r\n    }\r\n\r\n    /** @notice User-submitted transfer with arbiters signature, which sends tokens to another addresses account in the smart contract\r\n      * @param  token              The token to transfer (ETH is address(address(0)))\r\n      * @param  amount             The amount of tokens to transfer\r\n      * @param  nonce              The nonce (to salt the hash)\r\n      * @param  v                  Multi-signature v\r\n      * @param  r                  Multi-signature r\r\n      * @param  s                  Multi-signature s\r\n      * @param  receiving_address  The address to transfer the token/ETH to\r\n      */\r\n    function multiSigTransfer(address token, uint256 amount, uint64 nonce, uint8 v, bytes32 r, bytes32 s, address receiving_address) public {\r\n        bytes32 hash = keccak256(abi.encodePacked(                      // Calculate the withdrawal/transfer hash from the parameters \r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                token,\r\n                amount,\r\n                nonce,\r\n                address(this)\r\n            ))\r\n        ));\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[ecrecover(hash, v,r,s)]                         // Check if the multi-sig is valid\r\n            && balances[token][msg.sender] >= amount                    // Check if the user holds the required balance\r\n        ){\r\n            processed_withdrawals[hash]         = true;                 // Mark this withdrawal as processed\r\n            balances[token][msg.sender]        -= amount;               // Substract the balance from the withdrawing account\r\n            balances[token][receiving_address] += amount;               // Add the balance to the receiving account\r\n            \r\n            blocked_for_single_sig_withdrawal[token][msg.sender] = 0;   // Set possible previous manual blocking of these funds to 0\r\n            \r\n            emit Withdrawal(msg.sender,token,amount);                   // Emit a Withdrawal event\r\n            emit Deposit(receiving_address,token,amount);               // Emit a Deposit event\r\n        }else{\r\n            revert();                                                   // Revert the transaction if checks fail\r\n        }\r\n    }\r\n\r\n    /** @notice Arbiter submitted withdrawal with users multi-sig to users address\r\n      * @param  token   The token to withdraw (ETH is address(address(0)))\r\n      * @param  amount  The amount of tokens to withdraw\r\n      * @param  fee     The fee, covering the gas cost of the arbiter\r\n      * @param  nonce   The nonce (to salt the hash)\r\n      * @param  v       Multi-signature v (either 27 or 28. To identify the different signing schemes an offset of 10 is applied for EIP712)\r\n      * @param  r       Multi-signature r\r\n      * @param  s       Multi-signature s\r\n      */\r\n    function userSigWithdrawal(address token, uint256 amount, uint256 fee, uint64 nonce, uint8 v, bytes32 r, bytes32 s) public {            \r\n        bytes32 hash;\r\n        if(v < 30){                                                     // Standard signing scheme (personal.sign())\r\n            hash = keccak256(abi.encodePacked(                          // Restore multi-sig hash\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                keccak256(abi.encodePacked(\r\n                    token,\r\n                    amount,\r\n                    nonce,\r\n                    address(this)\r\n                ))\r\n            ));\r\n        }else{                                                          // EIP712 signing scheme\r\n            v -= 10;                                                    // Remove offset\r\n            hash = keccak256(abi.encodePacked(                          // Restore multi-sig hash\r\n                \"\\x19\\x01\",\r\n                EIP712_DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(\r\n                    EIP712_WITHDRAWAL_TYPEHASH,\r\n                    token,\r\n                    amount,\r\n                    nonce\r\n                ))\r\n            ));\r\n        }\r\n        address account = ecrecover(hash, v, r, s);                     // Restore signing address\r\n        if(\r\n            !processed_withdrawals[hash]                                // Check if the withdrawal was initiated before\r\n            && arbiters[msg.sender]                                     // Check if transaction comes from arbiter\r\n            && fee <= amount / 50                                       // Check if fee is not too big\r\n            && balances[token][account] >= amount                       // Check if the user holds the required tokens\r\n        ){\r\n            processed_withdrawals[hash]    = true;\r\n            balances[token][account]      -= amount;\r\n            balances[token][feeCollector] += fee;                       // Fee to cover gas costs for the withdrawal\r\n            if(token == address(0)){                                    // Send ETH\r\n                require(\r\n                    account.send(amount - fee),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(token).transfer(account, amount - fee);           // Withdraw ERC20\r\n                require(\r\n                    checkERC20TransferSuccess(),                        // Check if the transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n        \r\n            blocked_for_single_sig_withdrawal[token][account] = 0;      // Set possible previous manual blocking of these funds to 0\r\n            \r\n            emit Withdrawal(account,token,amount);                      // Emit a Withdrawal event\r\n        }else{\r\n            revert();                                                   // Revert the transaction is checks fail\r\n        }\r\n    }\r\n    \r\n    // Single-sig withdrawal functions:\r\n\r\n    /** @notice Allows user to block funds for single-sig withdrawal after 24h waiting period \r\n      *         (This period is necessary to ensure all trades backed by these funds will be settled.)\r\n      * @param  token   The address of the token to block (ETH is address(address(0)))\r\n      * @param  amount  The amount of the token to block\r\n      */\r\n    function blockFundsForSingleSigWithdrawal(address token, uint256 amount) public {\r\n        if (balances[token][msg.sender] - blocked_for_single_sig_withdrawal[token][msg.sender] >= amount){  // Check if the user holds the required funds\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] += amount;         // Block funds for manual withdrawal\r\n            last_blocked_timestamp[msg.sender] = block.timestamp;                   // Start 24h waiting period\r\n            emit BlockedForSingleSigWithdrawal(msg.sender,token,amount);            // Emit BlockedForSingleSigWithdrawal event\r\n        }else{\r\n            revert();                                                               // Revert the transaction if the user does not hold the required balance\r\n        }\r\n    }\r\n    \r\n    /** @notice Allows user to withdraw funds previously blocked after 24h\r\n      */\r\n    function initiateSingleSigWithdrawal(address token, uint256 amount) public {\r\n        if (\r\n            balances[token][msg.sender] >= amount                                   // Check if the user holds the funds\r\n            && blocked_for_single_sig_withdrawal[token][msg.sender] >= amount       // Check if these funds are blocked\r\n            && last_blocked_timestamp[msg.sender] + 86400 <= block.timestamp        // Check if the one day waiting period has passed\r\n        ){\r\n            balances[token][msg.sender] -= amount;                                  // Substract the tokens from users balance\r\n            blocked_for_single_sig_withdrawal[token][msg.sender] -= amount;         // Substract the tokens from users blocked balance\r\n            if(token == address(0)){                                                // Withdraw ETH\r\n                require(\r\n                    msg.sender.send(amount),\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{                                                                  // Withdraw ERC20 tokens\r\n                Token(token).transfer(msg.sender, amount);                          // Transfer the ERC20 tokens\r\n                require(\r\n                    checkERC20TransferSuccess(),                                    // Check if the transfer was successful\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n            emit SingleSigWithdrawal(msg.sender,token,amount);                      // Emit a SingleSigWithdrawal event\r\n        }else{\r\n            revert();                                                               // Revert the transaction if the required checks fail\r\n        }\r\n    } \r\n\r\n\r\n    //Trade settlement structs and function\r\n    \r\n    struct OrderInput{\r\n        uint8       buy_token;      // The token, the order signee wants to buy\r\n        uint8       sell_token;     // The token, the order signee wants to sell\r\n        uint256     buy_amount;     // The total amount the signee wants to buy\r\n        uint256     sell_amount;    // The total amount the signee wants to give for the amount he wants to buy (the orders \"rate\" is implied by the ratio between the two amounts)\r\n        uint64      nonce;          // Random number to give each order an individual hash and signature\r\n        int8        v;              // Signature v (either 27 or 28)\r\n                                    // To identify the different signing schemes an offset of 10 is applied for EIP712.\r\n                                    // To identify whether the order was signed by a delegated signing address, the number is either positive or negative.\r\n        bytes32     r;              // Signature r\r\n        bytes32     s;              // Signature s\r\n    }\r\n    \r\n    struct TradeInput{\r\n        uint8       maker_order;    // The index of the maker order\r\n        uint8       taker_order;    // The index of the taker order\r\n        uint256     maker_amount;   // The amount the maker gives in return for the taker's tokens\r\n        uint256     taker_amount;   // The amount the taker gives in return for the maker's tokens\r\n        uint256     maker_fee;      // The trading fee of the maker + a share in the settlement (gas) cost\r\n        uint256     taker_fee;      // The trading fee of the taker + a share in the settlement (gas) cost\r\n        uint256     maker_rebate;   // A optional rebate for the maker (portion of takers fee) as an incentive\r\n    }\r\n\r\n    /** @notice Allows an arbiter to settle trades between two user-signed orders\r\n      * @param  addresses  Array of all addresses involved in the transactions\r\n      * @param  orders     Array of all orders involved in the transactions\r\n      * @param  trades     Array of the trades to be settled\r\n      */   \r\n    function matchTrades(address[] addresses, OrderInput[] orders, TradeInput[] trades) public {\r\n        require(arbiters[msg.sender] && marketActive);      // Check if msg.sender is an arbiter and the market is active\r\n        \r\n        //Restore signing addresses\r\n        uint len = orders.length;                           // Length of orders array to loop through\r\n        bytes32[]  memory hashes = new bytes32[](len);      // Array of the restored order hashes\r\n        address[]  memory signee = new address[](len);      // Array of the restored order signees\r\n        OrderInput memory order;                            // Memory slot to cache orders while looping (otherwise the Stack would be too deep)\r\n        address    addressCache1;                           // Memory slot 1 to cache addresses while looping (otherwise the Stack would be too deep)\r\n        address    addressCache2;                           // Memory slot 2 to cache addresses while looping (otherwise the Stack would be too deep)\r\n        bool       delegated;\r\n        \r\n        for(uint8 i = 0; i < len; i++){                     // Loop through the orders array to restore all signees\r\n            order         = orders[i];                      // Cache order\r\n            addressCache1 = addresses[order.buy_token];     // Cache orders buy token\r\n            addressCache2 = addresses[order.sell_token];    // Cache orders sell token\r\n            \r\n            if(order.v < 0){                                // Check if the order is signed by a delegate\r\n                delegated = true;                           \r\n                order.v  *= -1;                             // Restore the negated v\r\n            }else{\r\n                delegated = false;\r\n            }\r\n            \r\n            if(order.v < 30){                               // Order is hashed after signature scheme personal.sign()\r\n                hashes[i] = keccak256(abi.encodePacked(     // Restore the hash of this order\r\n                    \"\\x19Ethereum Signed Message:\\n32\",\r\n                    keccak256(abi.encodePacked(\r\n                        addressCache1,\r\n                        addressCache2,\r\n                        order.buy_amount,\r\n                        order.sell_amount,\r\n                        order.nonce,        \r\n                        address(this)                       // This contract's address\r\n                    ))\r\n                ));\r\n            }else{                                          // Order is hashed after EIP712\r\n                order.v -= 10;                              // Remove signature format identifying offset\r\n                hashes[i] = keccak256(abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    EIP712_DOMAIN_SEPARATOR,\r\n                    keccak256(abi.encode(\r\n                        EIP712_ORDER_TYPEHASH,\r\n                        addressCache1,\r\n                        addressCache2,\r\n                        order.buy_amount,\r\n                        order.sell_amount,\r\n                        order.nonce\r\n                    ))\r\n                ));\r\n            }\r\n            signee[i] = ecrecover(                          // Restore the signee of this order\r\n                hashes[i],                                  // Order hash\r\n                uint8(order.v),                             // Signature v\r\n                order.r,                                    // Signature r\r\n                order.s                                     // Signature s\r\n            );\r\n            // When the signature was delegated restore delegating address\r\n            if(delegated){\r\n                signee[i] = delegates[signee[i]];\r\n            }\r\n        }\r\n        \r\n        // Settle Trades after check\r\n        len = trades.length;                                            // Length of the trades array to loop through\r\n        TradeInput memory trade;                                        // Memory slot to cache trades while looping\r\n        uint maker_index;                                               // Memory slot to cache the trade's maker order index\r\n        uint taker_index;                                               // Memory slot to cache the trade's taker order index\r\n        \r\n        for(i = 0; i < len; i++){                                       // Loop through trades to settle after checks\r\n            trade = trades[i];                                          // Cache trade\r\n            maker_index = trade.maker_order;                            // Cache maker order index\r\n            taker_index = trade.taker_order;                            // Cache taker order index\r\n            addressCache1 = addresses[orders[maker_index].buy_token];   // Cache first of the two swapped token addresses\r\n            addressCache2 = addresses[orders[taker_index].buy_token];   // Cache second of the two swapped token addresses\r\n            \r\n            if( // Check if the arbiter has matched following the conditions of the two order signees\r\n                // Do maker and taker want to trade the same tokens with each other\r\n                    orders[maker_index].buy_token == orders[taker_index].sell_token\r\n                && orders[taker_index].buy_token == orders[maker_index].sell_token\r\n                \r\n                // Do maker and taker hold the required balances\r\n                && balances[addressCache2][signee[maker_index]] >= trade.maker_amount - trade.maker_rebate\r\n                && balances[addressCache1][signee[taker_index]] >= trade.taker_amount\r\n                \r\n                // Are they both matched at a rate better or equal to the one they signed\r\n                && trade.maker_amount - trade.maker_rebate <= orders[maker_index].sell_amount * trade.taker_amount / orders[maker_index].buy_amount + 1  // Check maker doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n                && trade.taker_amount <= orders[taker_index].sell_amount * trade.maker_amount / orders[taker_index].buy_amount + 1                       // Check taker doesn't overpay (+ 1 to deal with rouding errors for very smal amounts)\r\n                \r\n                // Check if the matched amount + previously matched trades doesn't exceed the amount specified by the order signee\r\n                && trade.taker_amount + matched[hashes[taker_index]] <= orders[taker_index].sell_amount\r\n                && trade.maker_amount - trade.maker_rebate + matched[hashes[maker_index]] <= orders[maker_index].sell_amount\r\n                    \r\n                // Check if the charged fee is not too high\r\n                && trade.maker_fee <= trade.taker_amount / 100\r\n                && trade.taker_fee <= trade.maker_amount / 50\r\n                \r\n                // Check if maker_rebate is smaller than or equal to the taker's fee which compensates it\r\n                && trade.maker_rebate <= trade.taker_fee\r\n            ){\r\n                // Settle the trade:\r\n                \r\n                // Substract sold amounts\r\n                balances[addressCache2][signee[maker_index]] -= trade.maker_amount - trade.maker_rebate;    // Substract maker's sold amount minus the makers rebate\r\n                balances[addressCache1][signee[taker_index]] -= trade.taker_amount;                         // Substract taker's sold amount\r\n                \r\n                // Add bought amounts\r\n                balances[addressCache1][signee[maker_index]] += trade.taker_amount - trade.maker_fee;       // Give the maker his bought amount minus the fee\r\n                balances[addressCache2][signee[taker_index]] += trade.maker_amount - trade.taker_fee;       // Give the taker his bought amount minus the fee\r\n                \r\n                // Save bought amounts to prevent double matching\r\n                matched[hashes[maker_index]] += trade.maker_amount;                                         // Prevent maker order from being reused\r\n                matched[hashes[taker_index]] += trade.taker_amount;                                         // Prevent taker order from being reused\r\n                \r\n                // Give fee to feeCollector\r\n                balances[addressCache2][feeCollector] += trade.taker_fee - trade.maker_rebate;              // Give the feeColletor the taker fee minus the maker rebate \r\n                balances[addressCache1][feeCollector] += trade.maker_fee;                                   // Give the feeColletor the maker fee\r\n                \r\n                // Set possible previous manual blocking of these funds to 0\r\n                blocked_for_single_sig_withdrawal[addressCache2][signee[maker_index]] = 0;                  // If the maker tried to block funds which he/she used in this order we have to unblock them\r\n                blocked_for_single_sig_withdrawal[addressCache1][signee[taker_index]] = 0;                  // If the taker tried to block funds which he/she used in this order we have to unblock them\r\n                \r\n                emit TradeSettled(i);                                                                       // Emit tradeSettled Event to confirm the trade was settled\r\n            }else{\r\n                emit TradeFailed(i);                                                                        // Emit tradeFailed Event because the trade checks failed\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Order cancellation functions\r\n\r\n    /** @notice Give the user the option to perform multiple on-chain cancellations of orders at once with arbiters multi-sig\r\n      * @param  orderHashes Array of orderHashes of the orders to be canceled\r\n      * @param  v           Multi-sig v\r\n      * @param  r           Multi-sig r\r\n      * @param  s           Multi-sig s\r\n      */\r\n    function multiSigOrderBatchCancel(bytes32[] orderHashes, uint8 v, bytes32 r, bytes32 s) public {\r\n        if(\r\n            arbiters[                                               // Check if the signee is an arbiter\r\n                ecrecover(                                          // Restore the signing address\r\n                    keccak256(abi.encodePacked(                     // Restore the signed hash (hash of all orderHashes)\r\n                        \"\\x19Ethereum Signed Message:\\n32\", \r\n                        keccak256(abi.encodePacked(orderHashes))\r\n                    )),\r\n                    v, r, s\r\n                )\r\n            ]\r\n        ){\r\n            uint len = orderHashes.length;\r\n            for(uint8 i = 0; i < len; i++){\r\n                matched[orderHashes[i]] = 2**256 - 1;               // Set the matched amount of all orders to the maximum\r\n                emit OrderCanceled(orderHashes[i]);                 // emit OrderCanceled event\r\n            }\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n        \r\n    /** @notice Give arbiters the option to perform on-chain multiple cancellations of orders at once  \r\n      * @param orderHashes Array of hashes of the orders to be canceled\r\n      */\r\n    function orderBatchCancel(bytes32[] orderHashes) public {\r\n        if(\r\n            arbiters[msg.sender]                        // Check if the sender is an arbiter\r\n        ){\r\n            uint len = orderHashes.length;\r\n            for(uint8 i = 0; i < len; i++){\r\n                matched[orderHashes[i]] = 2**256 - 1;   // Set the matched amount of all orders to the maximum\r\n                emit OrderCanceled(orderHashes[i]);     // emit OrderCanceled event\r\n            }\r\n        }else{\r\n            revert();\r\n        }\r\n    }\r\n        \r\n        \r\n    // Signature delegation\r\n\r\n    /** @notice delegate an address to allow it to sign orders on your behalf\r\n      * @param delegate  The address to delegate\r\n      */\r\n    function delegateAddress(address delegate) public {\r\n        // set as delegate\r\n        require(delegates[delegate] == address(0), \"Address is already a delegate\");\r\n        delegates[delegate] = msg.sender;\r\n        \r\n        emit DelegateStatus(msg.sender, delegate, true);\r\n    }\r\n    \r\n    /** @notice revoke the delegation of an address\r\n      * @param  delegate  The delegated address\r\n      * @param  v         Multi-sig v\r\n      * @param  r         Multi-sig r\r\n      * @param  s         Multi-sig s\r\n      */\r\n    function revokeDelegation(address delegate, uint8 v, bytes32 r, bytes32 s) public {\r\n        bytes32 hash = keccak256(abi.encodePacked(              // Restore the signed hash\r\n            \"\\x19Ethereum Signed Message:\\n32\", \r\n            keccak256(abi.encodePacked(\r\n                delegate,\r\n                msg.sender,\r\n                address(this)\r\n            ))\r\n        ));\r\n\r\n        require(arbiters[ecrecover(hash, v, r, s)], \"MultiSig is not from known arbiter\");  // Check if signee is an arbiter\r\n        \r\n        delegates[delegate] = address(1);       // set to 1 not 0 to prevent double delegation, which would make old signed order valid for the new delegator\r\n        \r\n        emit DelegateStatus(msg.sender, delegate, false);\r\n    }\r\n    \r\n\r\n    // Management functions:\r\n\r\n    address owner;                      // Contract owner address (has the right to nominate arbiters and the feeCollectors addresses)   \r\n    address feeCollector;               // feeCollector address\r\n    bool marketActive = true;           // Make it possible to pause the market\r\n    bool feeCollectorLocked = false;    // Make it possible to lock the feeCollector address (to allow to change the feeCollector to a fee distribution contract)\r\n    mapping(address => bool) arbiters;  // Mapping of arbiters\r\n    \r\n    /** @notice Constructor function\r\n      */\r\n    constructor() public {\r\n        owner = msg.sender;             // Nominate sender to be the contract owner\r\n        feeCollector = msg.sender;      // Nominate sender to be the standart feeCollector\r\n        arbiters[msg.sender] = true;    // Nominate sender to be an arbiter\r\n        \r\n        // create EIP712 domain seperator\r\n        EIP712_Domain memory eip712Domain = EIP712_Domain({\r\n            name              : \"dex.blue\",\r\n            version           : \"1\",\r\n            chainId           : 1,\r\n            verifyingContract : this\r\n        });\r\n        EIP712_DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            EIP712_DOMAIN_TYPEHASH,\r\n            keccak256(bytes(eip712Domain.name)),\r\n            keccak256(bytes(eip712Domain.version)),\r\n            eip712Domain.chainId,\r\n            eip712Domain.verifyingContract\r\n        ));\r\n    }\r\n    \r\n    /** @notice Allows the owner to nominate or denominate trade arbitting addresses\r\n      * @param  arbiter The arbiter whose status to change\r\n      * @param  status  Whether the address should be an arbiter (true) or not (false)\r\n      */\r\n    function nominateArbiter(address arbiter, bool status) public {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        arbiters[arbiter] = status;                             // Update address status\r\n    }\r\n\r\n    /** @notice Allows the owner to pause / unpause the market\r\n      * @param  state  Whether the the market should be active (true) or paused (false)\r\n      */\r\n    function setMarketActiveState(bool state) public {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        marketActive = state;                                   // pause / unpause market\r\n    }\r\n    \r\n    /** @notice Allows the owner to nominate the feeCollector address\r\n      * @param  collector The address to nominate as feeCollector\r\n      */\r\n    function nominateFeeCollector(address collector) public {\r\n        require(msg.sender == owner && !feeCollectorLocked);    // Check if sender is owner and feeCollector address is not locked\r\n        feeCollector = collector;                               // Update feeCollector address\r\n    }\r\n    \r\n    /** @notice Allows the owner to lock the feeCollector address\r\n  */\r\n    function lockFeeCollector() public {\r\n        require(msg.sender == owner);                           // Check if sender is owner\r\n        feeCollectorLocked = true;                              // Lock feeCollector address\r\n    }\r\n    \r\n    /** @notice Get the feeCollectors address\r\n      * @return The feeCollectors address\r\n      */\r\n    function getFeeCollector() public constant returns (address){\r\n        return feeCollector;\r\n    }\r\n\r\n    /** @notice Allows the feeCollector to directly withdraw his funds (would allow a fee distribution contract to withdraw collected fees)\r\n      * @param  token   The token to withdraw\r\n      * @param  amount  The amount of tokens to withdraw\r\n  */\r\n    function feeWithdrawal(address token, uint256 amount) public {\r\n        if (\r\n            msg.sender == feeCollector                              // Check if the sender is the feeCollector\r\n            && balances[token][feeCollector] >= amount              // Check if feeCollector has the sufficient balance\r\n        ){\r\n            balances[token][feeCollector] -= amount;                // Substract the feeCollectors balance\r\n            if(token == address(0)){                                // Is the withdrawal token ETH\r\n                require(\r\n                    feeCollector.send(amount),                      // Withdraw ETH\r\n                    \"Sending of ETH failed.\"\r\n                );\r\n            }else{\r\n                Token(token).transfer(feeCollector, amount);        // Withdraw ERC20\r\n                require(                                            // Revert if the withdrawal failed\r\n                    checkERC20TransferSuccess(),\r\n                    \"ERC20 token transfer failed.\"\r\n                );\r\n            }\r\n            emit FeeWithdrawal(token,amount);                       // Emit FeeWithdrawal event\r\n        }else{\r\n            revert();                                               // Revert the transaction if the checks fail\r\n        }\r\n    }\r\n    \r\n    // We have to check returndatasize after ERC20 tokens transfers, as some tokens are implemented badly (dont return a boolean)\r\n    function checkERC20TransferSuccess() pure private returns(bool){\r\n        uint256 success = 0;\r\n\r\n        assembly {\r\n            switch returndatasize               // Check the number of bytes the token contract returned\r\n                case 0 {                        // Nothing returned, but contract did not throw > assume our transfer succeeded\r\n                    success := 1\r\n                }\r\n                case 32 {                       // 32 bytes returned, result is the returned bool\r\n                    returndatacopy(0, 0, 32)\r\n                    success := mload(0)\r\n                }\r\n        }\r\n\r\n        return success != 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Standart ERC20 token interface to interact with ERC20 token contracts\r\n// To support badly implemented tokens (which dont return a boolean on the transfer functions)\r\n// we have to expect a badly implemented token and then check with checkERC20TransferSuccess() whether the transfer succeeded\r\n\r\ncontract Token {\r\n    /** @return total amount of tokens\r\n      */\r\n    function totalSupply() constant public returns (uint256 supply) {}\r\n\r\n    /** @param _owner The address from which the balance will be retrieved\r\n      * @return The balance\r\n      */\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {}\r\n\r\n    /** @notice send `_value` token to `_to` from `msg.sender`\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return Whether the transfer was successful or not\r\n      */\r\n    function transfer(address _to, uint256 _value) public {}\r\n\r\n    /** @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n      * @param  _from   The address of the sender\r\n      * @param  _to     The address of the recipient\r\n      * @param  _value  The amount of tokens to be transferred\r\n      * @return Whether the transfer was successful or not\r\n      */\r\n    function transferFrom(address _from, address _to, uint256 _value)  public {}\r\n\r\n    /** @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @param  _value   The amount of wei to be approved for transfer\r\n      * @return Whether the approval was successful or not\r\n      */\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\r\n\r\n    /** @param  _owner   The address of the account owning tokens\r\n      * @param  _spender The address of the account able to transfer the tokens\r\n      * @return Amount of remaining tokens allowed to spend\r\n      */\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint public decimals;\r\n    string public name;\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMarketActiveState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeCollector\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"collector\",\"type\":\"address\"}],\"name\":\"nominateFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"receiving_address\",\"type\":\"address\"}],\"name\":\"multiSigTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"delegateAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"},{\"components\":[{\"name\":\"buy_token\",\"type\":\"uint8\"},{\"name\":\"sell_token\",\"type\":\"uint8\"},{\"name\":\"buy_amount\",\"type\":\"uint256\"},{\"name\":\"sell_amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"int8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"type\":\"tuple[]\"},{\"components\":[{\"name\":\"maker_order\",\"type\":\"uint8\"},{\"name\":\"taker_order\",\"type\":\"uint8\"},{\"name\":\"maker_amount\",\"type\":\"uint256\"},{\"name\":\"taker_amount\",\"type\":\"uint256\"},{\"name\":\"maker_fee\",\"type\":\"uint256\"},{\"name\":\"taker_fee\",\"type\":\"uint256\"},{\"name\":\"maker_rebate\",\"type\":\"uint256\"}],\"name\":\"trades\",\"type\":\"tuple[]\"}],\"name\":\"matchTrades\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"},{\"name\":\"receiving_address\",\"type\":\"address\"}],\"name\":\"multiSigSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"orderBatchCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"nominateArbiter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockFeeCollector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLastBlockedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderHashes\",\"type\":\"bytes32[]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"multiSigOrderBatchCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"blockFundsForSingleSigWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"multiSigWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"initiateSingleSigWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint64\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"userSigWithdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"revokeDelegation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getBlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"TradeSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"TradeFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BlockedForSingleSigWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SingleSigWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"OrderCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"DelegateStatus\",\"type\":\"event\"}]", "ContractName": "dexBlue", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://05ac64da0bc2a1953968bc6fd98ea4a383d11d73b86360a202386bd43314b80f"}]}