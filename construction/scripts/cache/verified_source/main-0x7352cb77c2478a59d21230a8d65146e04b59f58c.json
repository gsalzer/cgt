{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\nlibrary KeysUtils {\r\n    // Such order is important to load from state\r\n    struct Object {\r\n        uint32 gasPriceGwei;\r\n        uint32 gasLimit;\r\n        uint32 timestamp;\r\n        address contractAddress;\r\n    }\r\n\r\n    function toKey(Object _obj) internal pure returns (bytes32) {\r\n        return toKey(_obj.contractAddress, _obj.timestamp, _obj.gasLimit, _obj.gasPriceGwei);\r\n    }\r\n\r\n    function toKeyFromStorage(Object storage _obj) internal view returns (bytes32 _key) {\r\n        assembly {\r\n            _key := sload(_obj_slot)\r\n        }\r\n    }\r\n\r\n    function toKey(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal pure returns (bytes32 result) {\r\n        result = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n        //         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - address (20 bytes)\r\n        //                                                 ^^^^^^^^ - timestamp (4 bytes)\r\n        //                                                         ^^^^^^^^ - gas limit (4 bytes)\r\n        //                                                                 ^^^^^^^^ - gas price (4 bytes)\r\n        assembly {\r\n            result := or(result, mul(_address, 0x1000000000000000000000000))\r\n            result := or(result, mul(and(_timestamp, 0xffffffff), 0x10000000000000000))\r\n            result := or(result, mul(and(_gasLimit, 0xffffffff), 0x100000000))\r\n            result := or(result, and(_gasPrice, 0xffffffff))\r\n        }\r\n    }\r\n\r\n    function toMemoryObject(bytes32 _key, Object memory _dest) internal pure {\r\n        assembly {\r\n            mstore(_dest, and(_key, 0xffffffff))\r\n            mstore(add(_dest, 0x20), and(div(_key, 0x100000000), 0xffffffff))\r\n            mstore(add(_dest, 0x40), and(div(_key, 0x10000000000000000), 0xffffffff))\r\n            mstore(add(_dest, 0x60), div(_key, 0x1000000000000000000000000))\r\n        }\r\n    }\r\n\r\n    function toObject(bytes32 _key) internal pure returns (Object memory _dest) {\r\n        toMemoryObject(_key, _dest);\r\n    }\r\n\r\n    function toStateObject(bytes32 _key, Object storage _dest) internal {\r\n        assembly {\r\n            sstore(_dest_slot, _key)\r\n        }\r\n    }\r\n\r\n    function getTimestamp(bytes32 _key) internal pure returns (uint result) {\r\n        assembly {\r\n            result := and(div(_key, 0x10000000000000000), 0xffffffff)\r\n        }\r\n    }\r\n}\r\n\r\ncontract TransferToken is Ownable {\r\n    function transferToken(ERC20Basic _token, address _to, uint _value) public onlyOwner {\r\n        _token.transfer(_to, _value);\r\n    }\r\n}\r\n\r\n\r\ncontract JouleProxyAPI {\r\n    /**\r\n     * Function hash is: 0x73027f6d\r\n     */\r\n    function callback(address _contract) public;\r\n}\r\n\r\ncontract CheckableContract {\r\n    event Checked();\r\n    /*\r\n     * Function hash is 0x919840ad.\r\n     */\r\n    function check() public;\r\n}\r\n\r\n\r\ncontract JouleAPI {\r\n    event Invoked(address indexed _address, bool _status, uint _usedGas);\r\n    event Registered(address indexed _address, uint _timestamp, uint _gasLimit, uint _gasPrice);\r\n\r\n    /**\r\n     * @dev Registers the specified contract to invoke at the specified time with the specified gas and price.\r\n     * @notice It required amount of ETH as value, to cover gas usage. See getPrice method.\r\n     *\r\n     * @param _address Contract's address. Contract MUST implements Checkable interface.\r\n     * @param _timestamp Timestamp at what moment contract should be called. It MUST be in future.\r\n     * @param _gasLimit Gas which will be posted to call.\r\n     * @param _gasPrice Gas price which is recommended to use for this invocation.\r\n     */\r\n    function register(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external payable returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes next contracts in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @return Reward amount.\r\n     */\r\n    function invoke() public returns (uint);\r\n\r\n    /**\r\n     * @dev Invokes the top contract in the queue.\r\n     * @notice Eth amount to cover gas will be returned if gas price is equal or less then specified for contract. Check getTop for right gas price.\r\n     * @return Reward amount.\r\n     */\r\n    function invokeTop() public returns (uint);\r\n\r\n    /**\r\n     * @dev Calculates required to register amount of WEI.\r\n     *\r\n     * @param _gasLimit Gas which will be posted to call.\r\n     * @param _gasPrice Gas price which is recommended to use for this invocation.\r\n     * @return Amount in wei.\r\n     */\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets how many contracts are registered (and not invoked).\r\n     */\r\n    function getCount() public view returns (uint);\r\n\r\n    /**\r\n     * @dev Gets top contract (the next to invoke).\r\n     *\r\n     * @return contractAddress  The contract address.\r\n     * @return timestamp        The invocation timestamp.\r\n     * @return gasLimit         The invocation maximum gas.\r\n     * @return gasPrice         The invocation expected price.\r\n     */\r\n    function getTop() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice\r\n    );\r\n\r\n    /**\r\n     * @dev Gets top _count contracts (in order to invoke).\r\n     *\r\n     * @param _count        How many records will be returned.\r\n     * @return addresses    The contracts addresses.\r\n     * @return timestamps   The invocation timestamps.\r\n     * @return gasLimits    The invocation gas limits.\r\n     * @return gasPrices    The invocation expected prices.\r\n     */\r\n    function getTop(uint _count) external view returns (\r\n        address[] addresses,\r\n        uint[] timestamps,\r\n        uint[] gasLimits,\r\n        uint[] gasPrices\r\n    );\r\n\r\n    /**\r\n     * @dev Gets actual code version.\r\n     * @return Code version. Mask: 0xff.0xff.0xffff-0xffffffff (major.minor.build-hash)\r\n     */\r\n    function getVersion() external view returns (bytes8);\r\n}\r\n\r\n\r\n\r\ncontract usingConsts {\r\n    uint constant GWEI = 0.001 szabo;\r\n    // this value influence to the reward price! do not change for already registered contracts!\r\n    uint constant IDLE_GAS = 22273;\r\n    uint constant MAX_GAS = 4000000;\r\n    // Code version\r\n    bytes8 constant VERSION = 0x0100001300000000;\r\n    //                        ^^ - major\r\n    //                          ^^ - minor\r\n    //                            ^^^^ - build\r\n    //                                ^^^^^^^^ - git hash\r\n}\r\n\r\n\r\ncontract JouleIndex {\r\n    using KeysUtils for bytes32;\r\n    uint constant YEAR = 0x1DFE200;\r\n\r\n    // year -> month -> day -> hour\r\n    mapping (bytes32 => bytes32) index;\r\n    bytes32 head;\r\n\r\n    function insert(bytes32 _key) public {\r\n        uint timestamp = _key.getTimestamp();\r\n        bytes32 year = toKey(timestamp, YEAR);\r\n        bytes32 headLow;\r\n        bytes32 headHigh;\r\n        (headLow, headHigh) = fromValue(head);\r\n        if (year < headLow || headLow == 0 || year > headHigh) {\r\n            if (year < headLow || headLow == 0) {\r\n                headLow = year;\r\n            }\r\n            if (year > headHigh) {\r\n                headHigh = year;\r\n            }\r\n            head = toValue(headLow, headHigh);\r\n        }\r\n\r\n        bytes32 week = toKey(timestamp, 1 weeks);\r\n        bytes32 low;\r\n        bytes32 high;\r\n        (low, high) = fromValue(index[year]);\r\n        if (week < low || week > high) {\r\n            if (week < low || low == 0) {\r\n                low = week;\r\n            }\r\n            if (week > high) {\r\n                high = week;\r\n            }\r\n            index[year] = toValue(low, high);\r\n        }\r\n\r\n        (low, high) = fromValue(index[week]);\r\n        bytes32 hour = toKey(timestamp, 1 hours);\r\n        if (hour < low || hour > high) {\r\n            if (hour < low || low == 0) {\r\n                low = hour;\r\n            }\r\n            if (hour > high) {\r\n                high = hour;\r\n            }\r\n            index[week] = toValue(low, high);\r\n        }\r\n\r\n        (low, high) = fromValue(index[hour]);\r\n        bytes32 minute = toKey(timestamp, 1 minutes);\r\n        if (minute < low || minute > high) {\r\n            if (minute < low || low == 0) {\r\n                low = minute;\r\n            }\r\n            if (minute > high) {\r\n                high = minute;\r\n            }\r\n            index[hour] = toValue(low, high);\r\n        }\r\n\r\n        (low, high) = fromValue(index[minute]);\r\n        bytes32 tsKey = toKey(timestamp);\r\n        if (tsKey < low || tsKey > high) {\r\n            if (tsKey < low || low == 0) {\r\n                low = tsKey;\r\n            }\r\n            if (tsKey > high) {\r\n                high = tsKey;\r\n            }\r\n            index[minute] = toValue(low, high);\r\n        }\r\n\r\n        index[tsKey] = _key;\r\n    }\r\n\r\n    function findFloorKeyYear(uint _timestamp, bytes32 _low, bytes32 _high) view internal returns (bytes32) {\r\n        bytes32 year = toKey(_timestamp, YEAR);\r\n        if (year < _low) {\r\n            return 0;\r\n        }\r\n        if (year > _high) {\r\n            // week\r\n            (low, high) = fromValue(index[_high]);\r\n            // hour\r\n            (low, high) = fromValue(index[high]);\r\n            // minute\r\n            (low, high) = fromValue(index[high]);\r\n            // ts\r\n            (low, high) = fromValue(index[high]);\r\n            return index[high];\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        while (year >= _low) {\r\n            (low, high) = fromValue(index[year]);\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyWeek(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n            // 0x1DFE200 = 52 weeks = 31449600\r\n            assembly {\r\n                year := sub(year, 0x1DFE200)\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyWeek(uint _timestamp, bytes32 _low, bytes32 _high) view internal returns (bytes32) {\r\n        bytes32 week = toKey(_timestamp, 1 weeks);\r\n        if (week < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (week > _high) {\r\n            // hour\r\n            (low, high) = fromValue(index[_high]);\r\n            // minute\r\n            (low, high) = fromValue(index[high]);\r\n            // ts\r\n            (low, high) = fromValue(index[high]);\r\n            return index[high];\r\n        }\r\n\r\n        while (week >= _low) {\r\n            (low, high) = fromValue(index[week]);\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyHour(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 weeks = 604800\r\n            assembly {\r\n                week := sub(week, 604800)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function findFloorKeyHour(uint _timestamp, bytes32 _low, bytes32 _high) view internal returns (bytes32) {\r\n        bytes32 hour = toKey(_timestamp, 1 hours);\r\n        if (hour < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (hour > _high) {\r\n            // minute\r\n            (low, high) = fromValue(index[_high]);\r\n            // ts\r\n            (low, high) = fromValue(index[high]);\r\n            return index[high];\r\n        }\r\n\r\n        while (hour >= _low) {\r\n            (low, high) = fromValue(index[hour]);\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyMinute(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 hours = 3600\r\n            assembly {\r\n                hour := sub(hour, 3600)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyMinute(uint _timestamp, bytes32 _low, bytes32 _high) view internal returns (bytes32) {\r\n        bytes32 minute = toKey(_timestamp, 1 minutes);\r\n        if (minute < _low) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 low;\r\n        bytes32 high;\r\n\r\n        if (minute > _high) {\r\n            // ts\r\n            (low, high) = fromValue(index[_high]);\r\n            return index[high];\r\n        }\r\n\r\n        while (minute >= _low) {\r\n            (low, high) = fromValue(index[minute]);\r\n            if (low != 0) {\r\n                bytes32 key = findFloorKeyTimestamp(_timestamp, low, high);\r\n                if (key != 0) {\r\n                    return key;\r\n                }\r\n            }\r\n\r\n            // 1 minutes = 60\r\n            assembly {\r\n                minute := sub(minute, 60)\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKeyTimestamp(uint _timestamp, bytes32 _low, bytes32 _high) view internal returns (bytes32) {\r\n        bytes32 tsKey = toKey(_timestamp);\r\n        if (tsKey < _low) {\r\n            return 0;\r\n        }\r\n        if (tsKey > _high) {\r\n            return index[_high];\r\n        }\r\n\r\n        while (tsKey >= _low) {\r\n            bytes32 key = index[tsKey];\r\n            if (key != 0) {\r\n                return key;\r\n            }\r\n            assembly {\r\n                tsKey := sub(tsKey, 1)\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function findFloorKey(uint _timestamp) view public returns (bytes32) {\r\n//        require(_timestamp > 0xffffffff);\r\n//        if (_timestamp < 1515612415) {\r\n//            return 0;\r\n//        }\r\n\r\n        bytes32 yearLow;\r\n        bytes32 yearHigh;\r\n        (yearLow, yearHigh) = fromValue(head);\r\n\r\n        return findFloorKeyYear(_timestamp, yearLow, yearHigh);\r\n    }\r\n\r\n    function toKey(uint _timestamp, uint rounder) pure internal returns (bytes32 result) {\r\n        // 0x0...00000000000000000\r\n        //        ^^^^^^^^ - rounder marker (eg, to avoid crossing first day of year with year)\r\n        //                ^^^^^^^^ - rounded moment (year, week, etc)\r\n        assembly {\r\n            result := or(mul(rounder, 0x100000000), mul(div(_timestamp, rounder), rounder))\r\n        }\r\n    }\r\n\r\n    function toValue(bytes32 _lowKey, bytes32 _highKey) pure internal returns (bytes32 result) {\r\n        assembly {\r\n            result := or(mul(_lowKey, 0x10000000000000000), _highKey)\r\n        }\r\n    }\r\n\r\n    function fromValue(bytes32 _value) pure internal returns (bytes32 _lowKey, bytes32 _highKey) {\r\n        assembly {\r\n            _lowKey := and(div(_value, 0x10000000000000000), 0xffffffffffffffff)\r\n            _highKey := and(_value, 0xffffffffffffffff)\r\n        }\r\n    }\r\n\r\n\r\n    function toKey(uint timestamp) pure internal returns (bytes32) {\r\n        return bytes32(timestamp);\r\n    }\r\n}\r\n\r\n\r\ncontract JouleContractHolder is usingConsts {\r\n    using KeysUtils for bytes32;\r\n//    event Found(uint timestamp);\r\n    uint internal length;\r\n    bytes32 head;\r\n    mapping (bytes32 => bytes32) objects;\r\n    JouleIndex index;\r\n\r\n    function JouleContractHolder() public {\r\n        index = new JouleIndex();\r\n    }\r\n\r\n    function insert(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) internal {\r\n        length ++;\r\n        bytes32 id = KeysUtils.toKey(_address, _timestamp, _gasLimit, _gasPrice);\r\n        if (head == 0) {\r\n            head = id;\r\n            index.insert(id);\r\n//            Found(0xffffffff);\r\n            return;\r\n        }\r\n        bytes32 previous = index.findFloorKey(_timestamp);\r\n\r\n        // reject duplicate key on the end\r\n        require(previous != id);\r\n        // reject duplicate in the middle\r\n        require(objects[id] == 0);\r\n\r\n        uint prevTimestamp = previous.getTimestamp();\r\n//        Found(prevTimestamp);\r\n        uint headTimestamp = head.getTimestamp();\r\n        // add as head, prevTimestamp == 0 or in the past\r\n        if (prevTimestamp < headTimestamp) {\r\n            objects[id] = head;\r\n            head = id;\r\n        }\r\n        // add after the previous\r\n        else {\r\n            objects[id] = objects[previous];\r\n            objects[previous] = id;\r\n        }\r\n        index.insert(id);\r\n    }\r\n\r\n    function next() internal returns (KeysUtils.Object memory _next) {\r\n        head = objects[head];\r\n        length--;\r\n        _next = head.toObject();\r\n    }\r\n\r\n    function getCount() public view returns (uint) {\r\n        return length;\r\n    }\r\n\r\n    function getTop(uint _count) external view returns (\r\n        address[] _addresses,\r\n        uint[] _timestamps,\r\n        uint[] _gasLimits,\r\n        uint[] _gasPrices\r\n    ) {\r\n        uint amount = _count <= length ? _count : length;\r\n\r\n        _addresses = new address[](amount);\r\n        _timestamps = new uint[](amount);\r\n        _gasLimits = new uint[](amount);\r\n        _gasPrices = new uint[](amount);\r\n\r\n        bytes32 current = head;\r\n        for (uint i = 0; i < amount; i ++) {\r\n            KeysUtils.Object memory obj = current.toObject();\r\n            _addresses[i] = obj.contractAddress;\r\n            _timestamps[i] = obj.timestamp;\r\n            _gasLimits[i] = obj.gasLimit;\r\n            _gasPrices[i] = obj.gasPriceGwei * GWEI;\r\n            current = objects[current];\r\n        }\r\n        }\r\n\r\n    function getTop() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice\r\n    ) {\r\n        KeysUtils.Object memory obj = head.toObject();\r\n\r\n        contractAddress = obj.contractAddress;\r\n        timestamp = obj.timestamp;\r\n        gasLimit = obj.gasLimit;\r\n        gasPrice = obj.gasPriceGwei * GWEI;\r\n    }\r\n    \r\n        function getNext(address _contractAddress,\r\n                     uint _timestamp,\r\n                     uint _gasLimit,\r\n                     uint _gasPrice) public view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice\r\n    ) {\r\n        if (_timestamp == 0) {\r\n            return this.getTop();\r\n        }\r\n\r\n        bytes32 prev = KeysUtils.toKey(_contractAddress, _timestamp, _gasLimit, _gasPrice / GWEI);\r\n        bytes32 current = objects[prev];\r\n        KeysUtils.Object memory obj = current.toObject();\r\n\r\n        contractAddress = obj.contractAddress;\r\n        timestamp = obj.timestamp;\r\n        gasLimit = obj.gasLimit;\r\n        gasPrice = obj.gasPriceGwei * GWEI;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Joule is JouleAPI, JouleContractHolder {\r\n    function register(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external payable returns (uint) {\r\n        uint price = this.getPrice(_gasLimit, _gasPrice);\r\n        require(msg.value >= price);\r\n\r\n        require(_timestamp > now);\r\n        require(_timestamp < 0x100000000);\r\n        require(_gasLimit < MAX_GAS);\r\n        // from 1 gwei to 0x100000000 gwei\r\n        require(_gasPrice > GWEI);\r\n        require(_gasPrice < 0x100000000 * GWEI);\r\n\r\n        insert(_address, _timestamp, _gasLimit, _gasPrice / GWEI);\r\n\r\n        Registered(_address, _timestamp, _gasLimit, _gasPrice);\r\n\r\n        if (msg.value > price) {\r\n            msg.sender.transfer(msg.value - price);\r\n            return msg.value - price;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint) {\r\n        require(_gasLimit < 4300000);\r\n        require(_gasPrice > GWEI);\r\n        require(_gasPrice < 0x100000000 * GWEI);\r\n\r\n        return getPriceInner(_gasLimit, _gasPrice);\r\n    }\r\n\r\n    function getPriceInner(uint _gasLimit, uint _gasPrice) internal pure returns (uint) {\r\n        return (_gasLimit + IDLE_GAS) * _gasPrice;\r\n    }\r\n\r\n    function invoke() public returns (uint) {\r\n        return innerInvoke(invokeCallback);\r\n    }\r\n\r\n    function invokeTop() public returns (uint) {\r\n        return innerInvokeTop(invokeCallback);\r\n    }\r\n\r\n    function getVersion() external view returns (bytes8) {\r\n        return VERSION;\r\n    }\r\n\r\n    function innerInvoke(function (address, uint) internal returns (bool) _callback) internal returns (uint _amount) {\r\n        KeysUtils.Object memory current = KeysUtils.toObject(head);\r\n\r\n        uint amount;\r\n        while (current.timestamp != 0 && current.timestamp < now && msg.gas >= current.gasLimit) {\r\n            uint gas = msg.gas;\r\n            bool status = _callback(current.contractAddress, current.gasLimit);\r\n//            current.contractAddress.call.gas(current.gasLimit)(0x919840ad);\r\n            gas -= msg.gas;\r\n            Invoked(current.contractAddress, status, gas);\r\n\r\n            amount += getPriceInner(current.gasLimit, current.gasPriceGwei * GWEI);\r\n            current = next();\r\n        }\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function innerInvokeTop(function (address, uint) internal returns (bool) _callback) internal returns (uint _amount) {\r\n        KeysUtils.Object memory current = KeysUtils.toObject(head);\r\n        uint gas = msg.gas;\r\n        bool status = _callback(current.contractAddress, current.gasLimit);\r\n        gas -= msg.gas;\r\n\r\n        Invoked(current.contractAddress, status, gas);\r\n\r\n        uint amount = getPriceInner(current.gasLimit, current.gasPriceGwei * GWEI);\r\n\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n\r\n    function invokeCallback(address _contract, uint _gas) internal returns (bool) {\r\n        return _contract.call.gas(_gas)(0x919840ad);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract JouleBehindProxy is Joule, Ownable, TransferToken {\r\n    address public proxy;\r\n\r\n    function setProxy(address _proxy) public onlyOwner {\r\n        proxy = _proxy;\r\n    }\r\n\r\n    modifier onlyProxy() {\r\n        require(msg.sender == proxy);\r\n        _;\r\n    }\r\n\r\n    function invoke() public onlyProxy returns (uint) {\r\n        return super.invoke();\r\n    }\r\n\r\n    function invokeTop() public onlyProxy returns (uint) {\r\n        return super.invokeTop();\r\n    }\r\n\r\n    function invokeCallback(address _contract, uint _gas) internal returns (bool) {\r\n        return proxy.call.gas(_gas)(0x73027f6d, _contract);\r\n    }\r\n}\r\n\r\ncontract JouleProxy is JouleProxyAPI, JouleAPI, Ownable, TransferToken {\r\n    JouleBehindProxy public joule;\r\n\r\n    function setJoule(JouleBehindProxy _joule) public onlyOwner {\r\n        joule = _joule;\r\n    }\r\n\r\n    modifier onlyJoule() {\r\n        require(msg.sender == address(joule));\r\n        _;\r\n    }\r\n\r\n    function () public payable onlyJoule {\r\n    }\r\n\r\n    function getCount() public view returns (uint) {\r\n        return joule.getCount();\r\n    }\r\n\r\n    function register(address _address, uint _timestamp, uint _gasLimit, uint _gasPrice) external payable returns (uint) {\r\n        uint change = joule.register.value(msg.value)(_address, _timestamp, _gasLimit, _gasPrice);\r\n        if (change > 0) {\r\n            msg.sender.transfer(change);\r\n        }\r\n        return change;\r\n    }\r\n\r\n    function invoke() public returns (uint) {\r\n        uint amount = joule.invoke();\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function invokeTop() public returns (uint) {\r\n        uint amount = joule.invokeTop();\r\n        if (amount > 0) {\r\n            msg.sender.transfer(amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function getPrice(uint _gasLimit, uint _gasPrice) external view returns (uint) {\r\n        return joule.getPrice(_gasLimit, _gasPrice);\r\n    }\r\n\r\n    function getTop() external view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice\r\n    ) {\r\n        (contractAddress, timestamp, gasLimit, gasPrice) = joule.getTop();\r\n    }\r\n\r\n    function getNext(address _contractAddress,\r\n                     uint _timestamp,\r\n                     uint _gasLimit,\r\n                     uint _gasPrice) public view returns (\r\n        address contractAddress,\r\n        uint timestamp,\r\n        uint gasLimit,\r\n        uint gasPrice\r\n    ) {\r\n        (contractAddress, timestamp, gasLimit, gasPrice) = joule.getNext(_contractAddress, _timestamp, _gasLimit, _gasPrice);\r\n    }\r\n\r\n\r\n\r\n    function getTop(uint _count) external view returns (\r\n        address[] _addresses,\r\n        uint[] _timestamps,\r\n        uint[] _gasLimits,\r\n        uint[] _gasPrices\r\n    ) {\r\n        uint length = joule.getCount();\r\n        uint amount = _count <= length ? _count : length;\r\n\r\n        _addresses = new address[](amount);\r\n        _timestamps = new uint[](amount);\r\n        _gasLimits = new uint[](amount);\r\n        _gasPrices = new uint[](amount);\r\n\r\n        address contractAddress;\r\n        uint timestamp;\r\n        uint gasLimit;\r\n        uint gasPrice;\r\n\r\n        (contractAddress, timestamp, gasLimit, gasPrice) = joule.getTop();\r\n        _addresses[0] = contractAddress;\r\n        _timestamps[0] = timestamp;\r\n        _gasLimits[0] = gasLimit;\r\n        _gasPrices[0] = gasPrice;\r\n\r\n        for (uint i = 1; i < amount; i ++) {\r\n            (contractAddress, timestamp, gasLimit, gasPrice) = joule.getNext(contractAddress, timestamp, gasLimit, gasPrice);\r\n            _addresses[i] = contractAddress;\r\n            _timestamps[i] = timestamp;\r\n            _gasLimits[i] = gasLimit;\r\n            _gasPrices[i] = gasPrice;\r\n        }\r\n    }\r\n\r\n    function getVersion() external view returns (bytes8) {\r\n        return joule.getVersion();\r\n    }\r\n\r\n    function callback(address _contract) public onlyJoule {\r\n        CheckableContract(_contract).check();\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invokeTop\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getTop\",\"outputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_timestamps\",\"type\":\"uint256[]\"},{\"name\":\"_gasLimits\",\"type\":\"uint256[]\"},{\"name\":\"_gasPrices\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"getNext\",\"outputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"},{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_joule\",\"type\":\"address\"}],\"name\":\"setJoule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invoke\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joule\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_status\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_usedGas\",\"type\":\"uint256\"}],\"name\":\"Invoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gasPrice\",\"type\":\"uint256\"}],\"name\":\"Registered\",\"type\":\"event\"}]", "ContractName": "JouleProxy", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://ae240ac37bfdda31e766dae5aa6aaec3f77cead516c021718f0bfff27aa6ab50"}]}