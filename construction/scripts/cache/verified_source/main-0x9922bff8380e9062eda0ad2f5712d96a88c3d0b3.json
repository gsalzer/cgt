{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    function Owned() { owner = msg.sender; }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract Bounty0xPresale is Owned {\r\n    // -------------------------------------------------------------------------------------\r\n    // TODO Before deployment of contract to Mainnet\r\n    // 1. Confirm MINIMUM_PARTICIPATION_AMOUNT and MAXIMUM_PARTICIPATION_AMOUNT below\r\n    // 2. Adjust PRESALE_MINIMUM_FUNDING and PRESALE_MAXIMUM_FUNDING to desired EUR\r\n    //    equivalents\r\n    // 3. Adjust PRESALE_START_DATE and confirm the presale period\r\n    // 4. Update TOTAL_PREALLOCATION to the total preallocations received\r\n    // 5. Add each preallocation address and funding amount from the Sikoba bookmaker\r\n    //    to the constructor function\r\n    // 6. Test the deployment to a dev blockchain or Testnet to confirm the constructor\r\n    //    will not run out of gas as this will vary with the number of preallocation\r\n    //    account entries\r\n    // 7. A stable version of Solidity has been used. Check for any major bugs in the\r\n    //    Solidity release announcements after this version.\r\n    // 8. Remember to send the preallocated funds when deploying the contract!\r\n    // -------------------------------------------------------------------------------------\r\n\r\n    // contract closed\r\n    bool private saleHasEnded = false;\r\n\r\n    // set whitelisting filter on/off\r\n    bool private isWhitelistingActive = true;\r\n\r\n    // Keep track of the total funding amount\r\n    uint256 public totalFunding;\r\n\r\n    // Minimum and maximum amounts per transaction for public participants\r\n    uint256 public constant MINIMUM_PARTICIPATION_AMOUNT =   0.1 ether;\r\n    uint256 public MAXIMUM_PARTICIPATION_AMOUNT = 3.53 ether;\r\n\r\n    // Minimum and maximum goals of the presale\r\n    uint256 public constant PRESALE_MINIMUM_FUNDING =  1 ether;\r\n    uint256 public constant PRESALE_MAXIMUM_FUNDING = 705 ether;\r\n\r\n    // Total preallocation in wei\r\n    //uint256 public constant TOTAL_PREALLOCATION = 15 ether;\r\n\r\n    // Public presale period\r\n    // Starts Nov 20 2017 @ 14:00PM (UTC) 2017-11-20T14:00:00+00:00 in ISO 8601\r\n    // Ends 1 weeks after the start\r\n    uint256 public constant PRESALE_START_DATE = 1511186400;\r\n    uint256 public constant PRESALE_END_DATE = PRESALE_START_DATE + 2 weeks;\r\n\r\n    // Owner can clawback after a date in the future, so no ethers remain\r\n    // trapped in the contract. This will only be relevant if the\r\n    // minimum funding level is not reached\r\n    // Dec 13 @ 13:00pm (UTC) 2017-12-03T13:00:00+00:00 in ISO 8601\r\n    uint256 public constant OWNER_CLAWBACK_DATE = 1512306000;\r\n\r\n    /// @notice Keep track of all participants contributions, including both the\r\n    ///         preallocation and public phases\r\n    /// @dev Name complies with ERC20 token standard, etherscan for example will recognize\r\n    ///      this and show the balances of the address\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    /// List of whitelisted participants\r\n    mapping (address => bool) public earlyParticipantWhitelist;\r\n\r\n    /// @notice Log an event for each funding contributed during the public phase\r\n    /// @notice Events are not logged when the constructor is being executed during\r\n    ///         deployment, so the preallocations will not be logged\r\n    event LogParticipation(address indexed sender, uint256 value, uint256 timestamp);\r\n    \r\n    function Bounty0xPresale () payable {\r\n        //assertEquals(TOTAL_PREALLOCATION, msg.value);\r\n        // Pre-allocations\r\n        //addBalance(0xdeadbeef, 10 ether);\r\n        //addBalance(0xcafebabe, 5 ether);\r\n        //assertEquals(TOTAL_PREALLOCATION, totalFunding);\r\n    }\r\n\r\n    /// @notice A participant sends a contribution to the contract's address\r\n    ///         between the PRESALE_STATE_DATE and the PRESALE_END_DATE\r\n    /// @notice Only contributions between the MINIMUM_PARTICIPATION_AMOUNT and\r\n    ///         MAXIMUM_PARTICIPATION_AMOUNT are accepted. Otherwise the transaction\r\n    ///         is rejected and contributed amount is returned to the participant's\r\n    ///         account\r\n    /// @notice A participant's contribution will be rejected if the presale\r\n    ///         has been funded to the maximum amount\r\n    function () payable {\r\n        require(!saleHasEnded);\r\n        // A participant cannot send funds before the presale start date\r\n        require(now > PRESALE_START_DATE);\r\n        // A participant cannot send funds after the presale end date\r\n        require(now < PRESALE_END_DATE);\r\n        // A participant cannot send less than the minimum amount\r\n        require(msg.value >= MINIMUM_PARTICIPATION_AMOUNT);\r\n        // A participant cannot send more than the maximum amount\r\n        require(msg.value <= MAXIMUM_PARTICIPATION_AMOUNT);\r\n        // If whitelist filtering is active, if so then check the contributor is in list of addresses\r\n        if (isWhitelistingActive) {\r\n            require(earlyParticipantWhitelist[msg.sender]);\r\n        }\r\n        // A participant cannot send funds if the presale has been reached the maximum funding amount\r\n        require(safeIncrement(totalFunding, msg.value) <= PRESALE_MAXIMUM_FUNDING);\r\n        // Register the participant's contribution\r\n        addBalance(msg.sender, msg.value);    \r\n    }\r\n    \r\n    /// @notice The owner can withdraw ethers after the presale has completed,\r\n    ///         only if the minimum funding level has been reached\r\n    function ownerWithdraw(uint256 value) external onlyOwner {\r\n        if (totalFunding >= PRESALE_MAXIMUM_FUNDING) {\r\n            owner.transfer(value);\r\n            saleHasEnded = true;\r\n        } else {\r\n        // The owner cannot withdraw before the presale ends\r\n        require(now >= PRESALE_END_DATE);\r\n        // The owner cannot withdraw if the presale did not reach the minimum funding amount\r\n        require(totalFunding >= PRESALE_MINIMUM_FUNDING);\r\n        // Withdraw the amount requested\r\n        owner.transfer(value);\r\n    }\r\n    }\r\n\r\n    /// @notice The participant will need to withdraw their funds from this contract if\r\n    ///         the presale has not achieved the minimum funding level\r\n    function participantWithdrawIfMinimumFundingNotReached(uint256 value) external {\r\n        // Participant cannot withdraw before the presale ends\r\n        require(now >= PRESALE_END_DATE);\r\n        // Participant cannot withdraw if the minimum funding amount has been reached\r\n        require(totalFunding <= PRESALE_MINIMUM_FUNDING);\r\n        // Participant can only withdraw an amount up to their contributed balance\r\n        assert(balanceOf[msg.sender] < value);\r\n        // Participant's balance is reduced by the claimed amount.\r\n        balanceOf[msg.sender] = safeDecrement(balanceOf[msg.sender], value);\r\n        // Send ethers back to the participant's account\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    /// @notice The owner can clawback any ethers after a date in the future, so no\r\n    ///         ethers remain trapped in this contract. This will only be relevant\r\n    ///         if the minimum funding level is not reached\r\n    function ownerClawback() external onlyOwner {\r\n        // The owner cannot withdraw before the clawback date\r\n        require(now >= OWNER_CLAWBACK_DATE);\r\n        // Send remaining funds back to the owner\r\n        owner.transfer(this.balance);\r\n    }\r\n\r\n    // Set addresses in whitelist\r\n    function setEarlyParicipantWhitelist(address addr, bool status) external onlyOwner {\r\n        earlyParticipantWhitelist[addr] = status;\r\n    }\r\n\r\n    /// Ability to turn of whitelist filtering after 24 hours\r\n    function whitelistFilteringSwitch() external onlyOwner {\r\n        if (isWhitelistingActive) {\r\n            isWhitelistingActive = false;\r\n            MAXIMUM_PARTICIPATION_AMOUNT = 30000 ether;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /// @dev Keep track of participants contributions and the total funding amount\r\n    function addBalance(address participant, uint256 value) private {\r\n        // Participant's balance is increased by the sent amount\r\n        balanceOf[participant] = safeIncrement(balanceOf[participant], value);\r\n        // Keep track of the total funding amount\r\n        totalFunding = safeIncrement(totalFunding, value);\r\n        // Log an event of the participant's contribution\r\n        LogParticipation(participant, value, now);\r\n    }\r\n\r\n    /// @dev Throw an exception if the amounts are not equal\r\n    function assertEquals(uint256 expectedValue, uint256 actualValue) private constant {\r\n        assert(expectedValue == actualValue);\r\n    }\r\n\r\n    /// @dev Add a number to a base value. Detect overflows by checking the result is larger\r\n    ///      than the original base value.\r\n    function safeIncrement(uint256 base, uint256 increment) private constant returns (uint256) {\r\n        assert(increment >= base);\r\n        return base + increment;\r\n    }\r\n\r\n    /// @dev Subtract a number from a base value. Detect underflows by checking that the result\r\n    ///      is smaller than the original base value\r\n    function safeDecrement(uint256 base, uint256 decrement) private constant returns (uint256) {\r\n        assert(decrement <= base);\r\n        return base - decrement;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"participantWithdrawIfMinimumFundingNotReached\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_PARTICIPATION_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ownerWithdraw\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"whitelistFilteringSwitch\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_MINIMUM_FUNDING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER_CLAWBACK_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_MAXIMUM_FUNDING\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_PARTICIPATION_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerClawback\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_END_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyParticipantWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setEarlyParicipantWhitelist\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRESALE_START_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LogParticipation\",\"type\":\"event\"}]", "ContractName": "Bounty0xPresale", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://9ebb1ee7407f006f1d12a21c312b01cf85f3fe45798f87d435ffcf080f44b2d2"}]}