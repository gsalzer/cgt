{"status": "1", "message": "OK", "result": [{"SourceCode": "//File: node_modules/liquidpledging/contracts/ILiquidPledgingPlugin.sol\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributor: Adri\u00e0 Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\r\n///  liquid pledging plugin\r\ncontract ILiquidPledgingPlugin {\r\n\r\n    /// @notice Plugins are used (much like web hooks) to initiate an action\r\n    ///  upon any donation, delegation, or transfer; this is an optional feature\r\n    ///  and allows for extreme customization of the contract. This function\r\n    ///  implements any action that should be initiated before a transfer.\r\n    /// @param pledgeManager The admin or current manager of the pledge\r\n    /// @param pledgeFrom This is the Id from which value will be transfered.\r\n    /// @param pledgeTo This is the Id that value will be transfered to.    \r\n    /// @param context The situation that is triggering the plugin:\r\n    ///  0 -> Plugin for the owner transferring pledge to another party\r\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\r\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\r\n    ///  ...\r\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\r\n    ///\r\n    ///  256 -> Plugin for the owner receiving pledge to another party\r\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\r\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\r\n    ///  ...\r\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\r\n    /// @param amount The amount of value that will be transfered.\r\n    function beforeTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount ) returns (uint maxAllowed);\r\n\r\n    /// @notice Plugins are used (much like web hooks) to initiate an action\r\n    ///  upon any donation, delegation, or transfer; this is an optional feature\r\n    ///  and allows for extreme customization of the contract. This function\r\n    ///  implements any action that should be initiated after a transfer.\r\n    /// @param pledgeManager The admin or current manager of the pledge\r\n    /// @param pledgeFrom This is the Id from which value will be transfered.\r\n    /// @param pledgeTo This is the Id that value will be transfered to.    \r\n    /// @param context The situation that is triggering the plugin:\r\n    ///  0 -> Plugin for the owner transferring pledge to another party\r\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\r\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\r\n    ///  ...\r\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\r\n    ///\r\n    ///  256 -> Plugin for the owner receiving pledge to another party\r\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\r\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\r\n    ///  ...\r\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\r\n    ///  @param amount The amount of value that will be transfered.\r\n    function afterTransfer(\r\n        uint64 pledgeManager,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    );\r\n}\r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Owned.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/// @title Owned\r\n/// @author Adri\u00e0 Massanet <adria@codecontext.io>\r\n/// @notice The Owned contract has an owner address, and provides basic \r\n///  authorization control functions, this simplifies & the implementation of\r\n///  user permissions; this contract has three work flows for a change in\r\n///  ownership, the first requires the new owner to validate that they have the\r\n///  ability to accept ownership, the second allows the ownership to be\r\n///  directly transfered without requiring acceptance, and the third allows for\r\n///  the ownership to be removed to allow for decentralization \r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwnerCandidate;\r\n\r\n    event OwnershipRequested(address indexed by, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event OwnershipRemoved();\r\n\r\n    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\r\n    ///  be called first by the current `owner` then `acceptOwnership()` must be\r\n    ///  called by the `newOwnerCandidate`\r\n    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\r\n    ///  new owner\r\n    /// @param _newOwnerCandidate The address being proposed as the new owner\r\n    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\r\n        newOwnerCandidate = _newOwnerCandidate;\r\n        OwnershipRequested(msg.sender, newOwnerCandidate);\r\n    }\r\n\r\n    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\r\n    ///  transfer of ownership\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwnerCandidate);\r\n\r\n        address oldOwner = owner;\r\n        owner = newOwnerCandidate;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the `newOwner`\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner\r\n    function changeOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0);\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        newOwnerCandidate = 0x0;\r\n\r\n        OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\r\n    ///  be called and it will immediately assign ownership to the 0x0 address;\r\n    ///  it requires a 0xdece be input as a parameter to prevent accidental use\r\n    /// @notice Decentralizes the contract, this operation cannot be undone \r\n    /// @param _dac `0xdac` has to be entered for this function to work\r\n    function removeOwnership(address _dac) public onlyOwner {\r\n        require(_dac == 0xdac);\r\n        owner = 0x0;\r\n        newOwnerCandidate = 0x0;\r\n        OwnershipRemoved();     \r\n    }\r\n} \r\n\r\n//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\r\npragma solidity ^0.4.15;\r\n\r\n\r\n/**\r\n * @title ERC20\r\n * @dev A standard interface for tokens.\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20 {\r\n  \r\n    /// @dev Returns the total token supply\r\n    function totalSupply() public constant returns (uint256 supply);\r\n\r\n    /// @dev Returns the account balance of the account with address _owner\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n\r\n    /// @dev Transfers _value number of tokens to address _to\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Transfers _value number of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\r\npragma solidity ^0.4.15;\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Contributor: Adri\u00e0 Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n/// @dev `Escapable` is a base level contract built off of the `Owned`\r\n///  contract; it creates an escape hatch function that can be called in an\r\n///  emergency that will allow designated addresses to send any ether or tokens\r\n///  held in the contract to an `escapeHatchDestination` as long as they were\r\n///  not blacklisted\r\ncontract Escapable is Owned {\r\n    address public escapeHatchCaller;\r\n    address public escapeHatchDestination;\r\n    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\r\n\r\n    /// @notice The Constructor assigns the `escapeHatchDestination` and the\r\n    ///  `escapeHatchCaller`\r\n    /// @param _escapeHatchCaller The address of a trusted account or contract\r\n    ///  to call `escapeHatch()` to send the ether in this contract to the\r\n    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    /// @param _escapeHatchDestination The address of a safe location (usu a\r\n    ///  Multisig) to send the ether held in this contract; if a neutral address\r\n    ///  is required, the WHG Multisig is an option:\r\n    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \r\n    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\r\n        escapeHatchCaller = _escapeHatchCaller;\r\n        escapeHatchDestination = _escapeHatchDestination;\r\n    }\r\n\r\n    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\r\n    ///  are the only addresses that can call a function with this modifier\r\n    modifier onlyEscapeHatchCallerOrOwner {\r\n        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\r\n        _;\r\n    }\r\n\r\n    /// @notice Creates the blacklist of tokens that are not able to be taken\r\n    ///  out of the contract; can only be done at the deployment, and the logic\r\n    ///  to add to the blacklist will be in the constructor of a child contract\r\n    /// @param _token the token contract address that is to be blacklisted \r\n    function blacklistEscapeToken(address _token) internal {\r\n        escapeBlacklist[_token] = true;\r\n        EscapeHatchBlackistedToken(_token);\r\n    }\r\n\r\n    /// @notice Checks to see if `_token` is in the blacklist of tokens\r\n    /// @param _token the token address being queried\r\n    /// @return False if `_token` is in the blacklist and can't be taken out of\r\n    ///  the contract via the `escapeHatch()`\r\n    function isTokenEscapable(address _token) constant public returns (bool) {\r\n        return !escapeBlacklist[_token];\r\n    }\r\n\r\n    /// @notice The `escapeHatch()` should only be called as a last resort if a\r\n    /// security issue is uncovered or something unexpected happened\r\n    /// @param _token to transfer, use 0x0 for ether\r\n    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \r\n        require(escapeBlacklist[_token]==false);\r\n\r\n        uint256 balance;\r\n\r\n        /// @dev Logic for ether\r\n        if (_token == 0x0) {\r\n            balance = this.balance;\r\n            escapeHatchDestination.transfer(balance);\r\n            EscapeHatchCalled(_token, balance);\r\n            return;\r\n        }\r\n        /// @dev Logic for tokens\r\n        ERC20 token = ERC20(_token);\r\n        balance = token.balanceOf(this);\r\n        require(token.transfer(escapeHatchDestination, balance));\r\n        EscapeHatchCalled(_token, balance);\r\n    }\r\n\r\n    /// @notice Changes the address assigned to call `escapeHatch()`\r\n    /// @param _newEscapeHatchCaller The address of a trusted account or\r\n    ///  contract to call `escapeHatch()` to send the value in this contract to\r\n    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\r\n    ///  cannot move funds out of `escapeHatchDestination`\r\n    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\r\n        escapeHatchCaller = _newEscapeHatchCaller;\r\n    }\r\n\r\n    event EscapeHatchBlackistedToken(address token);\r\n    event EscapeHatchCalled(address token, uint amount);\r\n}\r\n\r\n//File: node_modules/liquidpledging/contracts/LiquidPledgingBase.sol\r\npragma solidity ^0.4.11;\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributors: Adri\u00e0 Massanet <adria@codecontext.io>, RJ Ewing, Griff\r\n    Green, Arthur Lunn\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n\r\n\r\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\r\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\r\n///  payments can Pledges be converted for ETH\r\ninterface LPVault {\r\n    function authorizePayment(bytes32 _ref, address _dest, uint _amount);\r\n    function () payable;\r\n}\r\n\r\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\r\n///  liquidPledging's most basic functions, mostly handling and searching the\r\n///  data structures\r\ncontract LiquidPledgingBase is Escapable {\r\n\r\n    // Limits inserted to prevent large loops that could prevent canceling\r\n    uint constant MAX_DELEGATES = 20;\r\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\r\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\r\n\r\n    enum PledgeAdminType { Giver, Delegate, Project }\r\n    enum PledgeState { Pledged, Paying, Paid }\r\n\r\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \r\n    ///  commonly referenced by their index in the `admins` array\r\n    ///  and can own pledges and act as delegates\r\n    struct PledgeAdmin { \r\n        PledgeAdminType adminType; // Giver, Delegate or Project\r\n        address addr; // Account or contract address for admin\r\n        string name;\r\n        string url;  // Can be IPFS hash\r\n        uint64 commitTime;  // In seconds, used for Givers' & Delegates' vetos\r\n        uint64 parentProject;  // Only for projects\r\n        bool canceled;      //Always false except for canceled projects\r\n\r\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\r\n        // than that smart contract is called when appropriate\r\n        ILiquidPledgingPlugin plugin; \r\n    }\r\n\r\n    struct Pledge {\r\n        uint amount;\r\n        uint64 owner; // PledgeAdmin\r\n        uint64[] delegationChain; // List of delegates in order of authority\r\n        uint64 intendedProject; // Used when delegates are sending to projects\r\n        uint64 commitTime;  // When the intendedProject will become the owner  \r\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\r\n        PledgeState pledgeState; //  Pledged, Paying, Paid\r\n    }\r\n\r\n    Pledge[] pledges;\r\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\r\n    LPVault public vault;\r\n\r\n    /// @dev this mapping allows you to search for a specific pledge's \r\n    ///  index number by the hash of that pledge\r\n    mapping (bytes32 => uint64) hPledge2idx;\r\n    mapping (bytes32 => bool) pluginWhitelist;\r\n    \r\n    bool public usePluginWhitelist = true;\r\n\r\n/////////////\r\n// Modifiers\r\n/////////////\r\n\r\n\r\n    /// @dev The `vault`is the only addresses that can call a function with this\r\n    ///  modifier\r\n    modifier onlyVault() {\r\n        require(msg.sender == address(vault));\r\n        _;\r\n    }\r\n\r\n\r\n///////////////\r\n// Constructor\r\n///////////////\r\n\r\n    /// @notice The Constructor creates `LiquidPledgingBase` on the blockchain\r\n    /// @param _vault The vault where the ETH backing the pledges is stored\r\n    function LiquidPledgingBase(\r\n        address _vault,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {\r\n        admins.length = 1; // we reserve the 0 admin\r\n        pledges.length = 1; // we reserve the 0 pledge\r\n        vault = LPVault(_vault); // Assigns the specified vault\r\n    }\r\n\r\n\r\n/////////////////////////\r\n// PledgeAdmin functions\r\n/////////////////////////\r\n\r\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\r\n    /// @param name The name used to identify the Giver\r\n    /// @param url The link to the Giver's profile often an IPFS hash\r\n    /// @param commitTime The length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    /// @param plugin This is Giver's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idGiver The id number used to reference this Admin\r\n    function addGiver(\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idGiver) {\r\n\r\n        require(isValidPlugin(plugin)); // Plugin check\r\n\r\n        idGiver = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Giver,\r\n            msg.sender,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            0,\r\n            false,\r\n            plugin));\r\n\r\n        GiverAdded(idGiver);\r\n    }\r\n\r\n    event GiverAdded(uint64 indexed idGiver);\r\n\r\n    /// @notice Updates a Giver's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\r\n    ///  by the current address of the Giver\r\n    /// @param idGiver This is the Admin id number used to specify the Giver\r\n    /// @param newAddr The new address that represents this Giver\r\n    /// @param newName The new name used to identify the Giver\r\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    function updateGiver(\r\n        uint64 idGiver,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime)\r\n    {\r\n        PledgeAdmin storage giver = findAdmin(idGiver);\r\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\r\n        require(giver.addr == msg.sender); // Current addr had to send this tx\r\n        giver.addr = newAddr;\r\n        giver.name = newName;\r\n        giver.url = newUrl;\r\n        giver.commitTime = newCommitTime;\r\n        GiverUpdated(idGiver);\r\n    }\r\n\r\n    event GiverUpdated(uint64 indexed idGiver);\r\n\r\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\r\n    /// @param name The name used to identify the Delegate\r\n    /// @param url The link to the Delegate's profile often an IPFS hash\r\n    /// @param commitTime Sets the length of time in seconds that this delegate\r\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\r\n    ///  allowed to veto any event must be greater than or equal to this time.\r\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idxDelegate The id number used to reference this Delegate within\r\n    ///  the admins array\r\n    function addDelegate(\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idDelegate) { \r\n\r\n        require(isValidPlugin(plugin)); // Plugin check\r\n\r\n        idDelegate = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Delegate,\r\n            msg.sender,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            0,\r\n            false,\r\n            plugin));\r\n\r\n        DelegateAdded(idDelegate);\r\n    }\r\n\r\n    event DelegateAdded(uint64 indexed idDelegate);\r\n\r\n    /// @notice Updates a Delegate's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\r\n    ///  by the current address of the Delegate\r\n    /// @param idDelegate The Admin id number used to specify the Delegate\r\n    /// @param newAddr The new address that represents this Delegate\r\n    /// @param newName The new name used to identify the Delegate\r\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds that this \r\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain \r\n    ///  the time allowed to veto any event must be greater than or equal to\r\n    ///  this time.\r\n    function updateDelegate(\r\n        uint64 idDelegate,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime) {\r\n        PledgeAdmin storage delegate = findAdmin(idDelegate);\r\n        require(delegate.adminType == PledgeAdminType.Delegate);\r\n        require(delegate.addr == msg.sender);// Current addr had to send this tx\r\n        delegate.addr = newAddr;\r\n        delegate.name = newName;\r\n        delegate.url = newUrl;\r\n        delegate.commitTime = newCommitTime;\r\n        DelegateUpdated(idDelegate);\r\n    }\r\n\r\n    event DelegateUpdated(uint64 indexed idDelegate);\r\n\r\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\r\n    /// @param name The name used to identify the Project\r\n    /// @param url The link to the Project's profile often an IPFS hash\r\n    /// @param projectAdmin The address for the trusted project manager \r\n    /// @param parentProject The Admin id number for the parent project or 0 if\r\n    ///  there is no parentProject\r\n    /// @param commitTime Sets the length of time in seconds the Project has to\r\n    ///   veto when the Project delegates to another Delegate and they pledge \r\n    ///   those funds to a project\r\n    /// @param plugin This is Project's liquid pledge plugin allowing for \r\n    ///  extended functionality\r\n    /// @return idProject The id number used to reference this Admin\r\n    function addProject(\r\n        string name,\r\n        string url,\r\n        address projectAdmin,\r\n        uint64 parentProject,\r\n        uint64 commitTime,\r\n        ILiquidPledgingPlugin plugin\r\n    ) returns (uint64 idProject) {\r\n        require(isValidPlugin(plugin));\r\n\r\n        if (parentProject != 0) {\r\n            PledgeAdmin storage pa = findAdmin(parentProject);\r\n            require(pa.adminType == PledgeAdminType.Project);\r\n            require(getProjectLevel(pa) < MAX_SUBPROJECT_LEVEL);\r\n        }\r\n\r\n        idProject = uint64(admins.length);\r\n\r\n        admins.push(PledgeAdmin(\r\n            PledgeAdminType.Project,\r\n            projectAdmin,\r\n            name,\r\n            url,\r\n            commitTime,\r\n            parentProject,\r\n            false,\r\n            plugin));\r\n\r\n\r\n        ProjectAdded(idProject);\r\n    }\r\n\r\n    event ProjectAdded(uint64 indexed idProject);\r\n\r\n\r\n    /// @notice Updates a Project's info to change the address, name, url, or \r\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\r\n    ///  and it must be called by the current address of the Project\r\n    /// @param idProject The Admin id number used to specify the Project\r\n    /// @param newAddr The new address that represents this Project\r\n    /// @param newName The new name used to identify the Project\r\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\r\n    /// @param newCommitTime Sets the length of time in seconds the Project has\r\n    ///  to veto when the Project delegates to a Delegate and they pledge those\r\n    ///  funds to a project\r\n    function updateProject(\r\n        uint64 idProject,\r\n        address newAddr,\r\n        string newName,\r\n        string newUrl,\r\n        uint64 newCommitTime)\r\n    {\r\n        PledgeAdmin storage project = findAdmin(idProject);\r\n        require(project.adminType == PledgeAdminType.Project);\r\n        require(project.addr == msg.sender);\r\n        project.addr = newAddr;\r\n        project.name = newName;\r\n        project.url = newUrl;\r\n        project.commitTime = newCommitTime;\r\n        ProjectUpdated(idProject);\r\n    }\r\n\r\n    event ProjectUpdated(uint64 indexed idAdmin);\r\n\r\n\r\n//////////\r\n// Public constant functions\r\n//////////\r\n\r\n    /// @notice A constant getter that returns the total number of pledges\r\n    /// @return The total number of Pledges in the system\r\n    function numberOfPledges() constant returns (uint) {\r\n        return pledges.length - 1;\r\n    }\r\n\r\n    /// @notice A getter that returns the details of the specified pledge\r\n    /// @param idPledge the id number of the pledge being queried\r\n    /// @return the amount, owner, the number of delegates (but not the actual\r\n    ///  delegates, the intendedProject (if any), the current commit time and\r\n    ///  the previous pledge this pledge was derived from\r\n    function getPledge(uint64 idPledge) constant returns(\r\n        uint amount,\r\n        uint64 owner,\r\n        uint64 nDelegates,\r\n        uint64 intendedProject,\r\n        uint64 commitTime,\r\n        uint64 oldPledge,\r\n        PledgeState pledgeState\r\n    ) {\r\n        Pledge storage p = findPledge(idPledge);\r\n        amount = p.amount;\r\n        owner = p.owner;\r\n        nDelegates = uint64(p.delegationChain.length);\r\n        intendedProject = p.intendedProject;\r\n        commitTime = p.commitTime;\r\n        oldPledge = p.oldPledge;\r\n        pledgeState = p.pledgeState;\r\n    }\r\n\r\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\r\n    /// @param idPledge The id number representing the pledge being queried\r\n    /// @param idxDelegate The index number for the delegate in this Pledge \r\n    function getPledgeDelegate(uint64 idPledge, uint idxDelegate) constant returns(\r\n        uint64 idDelegate,\r\n        address addr,\r\n        string name\r\n    ) {\r\n        Pledge storage p = findPledge(idPledge);\r\n        idDelegate = p.delegationChain[idxDelegate - 1];\r\n        PledgeAdmin storage delegate = findAdmin(idDelegate);\r\n        addr = delegate.addr;\r\n        name = delegate.name;\r\n    }\r\n\r\n    /// @notice A constant getter used to check how many total Admins exist\r\n    /// @return The total number of admins (Givers, Delegates and Projects) .\r\n    function numberOfPledgeAdmins() constant returns(uint) {\r\n        return admins.length - 1;\r\n    }\r\n\r\n    /// @notice A constant getter to check the details of a specified Admin  \r\n    /// @return addr Account or contract address for admin\r\n    /// @return name Name of the pledgeAdmin\r\n    /// @return url The link to the Project's profile often an IPFS hash\r\n    /// @return commitTime The length of time in seconds the Admin has to veto\r\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\r\n    ///   funds to a project\r\n    /// @return parentProject The Admin id number for the parent project or 0\r\n    ///  if there is no parentProject\r\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been \r\n    ///  canceled\r\n    /// @return plugin This is Project's liquidPledging plugin allowing for \r\n    ///  extended functionality\r\n    function getPledgeAdmin(uint64 idAdmin) constant returns (\r\n        PledgeAdminType adminType,\r\n        address addr,\r\n        string name,\r\n        string url,\r\n        uint64 commitTime,\r\n        uint64 parentProject,\r\n        bool canceled,\r\n        address plugin)\r\n    {\r\n        PledgeAdmin storage m = findAdmin(idAdmin);\r\n        adminType = m.adminType;\r\n        addr = m.addr;\r\n        name = m.name;\r\n        url = m.url;\r\n        commitTime = m.commitTime;\r\n        parentProject = m.parentProject;\r\n        canceled = m.canceled;\r\n        plugin = address(m.plugin);\r\n    }\r\n\r\n////////\r\n// Private methods\r\n///////\r\n\r\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\r\n    ///  created already; otherwise it finds the pledge with the specified\r\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\r\n    ///  created in this system yet it simply isn't in the hash array\r\n    ///  hPledge2idx[] yet\r\n    /// @param owner The owner of the pledge being looked up\r\n    /// @param delegationChain The list of delegates in order of authority\r\n    /// @param intendedProject The project this pledge will Fund after the\r\n    ///  commitTime has passed\r\n    /// @param commitTime The length of time in seconds the Giver has to\r\n    ///   veto when the Giver's delegates Pledge funds to a project\r\n    /// @param oldPledge This value is used to store the pledge the current\r\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\r\n    ///  will revert back to it's previous state\r\n    /// @param state The pledge state: Pledged, Paying, or state\r\n    /// @return The hPledge2idx index number\r\n    function findOrCreatePledge(\r\n        uint64 owner,\r\n        uint64[] delegationChain,\r\n        uint64 intendedProject,\r\n        uint64 commitTime,\r\n        uint64 oldPledge,\r\n        PledgeState state\r\n        ) internal returns (uint64)\r\n    {\r\n        bytes32 hPledge = sha3(\r\n            owner, delegationChain, intendedProject, commitTime, oldPledge, state);\r\n        uint64 idx = hPledge2idx[hPledge];\r\n        if (idx > 0) return idx;\r\n        idx = uint64(pledges.length);\r\n        hPledge2idx[hPledge] = idx;\r\n        pledges.push(Pledge(\r\n            0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));\r\n        return idx;\r\n    }\r\n\r\n    /// @notice A getter to look up a Admin's details\r\n    /// @param idAdmin The id for the Admin to lookup\r\n    /// @return The PledgeAdmin struct for the specified Admin\r\n    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {\r\n        require(idAdmin < admins.length);\r\n        return admins[idAdmin];\r\n    }\r\n\r\n    /// @notice A getter to look up a Pledge's details\r\n    /// @param idPledge The id for the Pledge to lookup\r\n    /// @return The PledgeA struct for the specified Pledge\r\n    function findPledge(uint64 idPledge) internal returns (Pledge storage) {\r\n        require(idPledge < pledges.length);\r\n        return pledges[idPledge];\r\n    }\r\n\r\n    // a constant for when a delegate is requested that is not in the system\r\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\r\n\r\n    /// @notice A getter that searches the delegationChain for the level of\r\n    ///  authority a specific delegate has within a Pledge\r\n    /// @param p The Pledge that will be searched\r\n    /// @param idDelegate The specified delegate that's searched for\r\n    /// @return If the delegate chain contains the delegate with the\r\n    ///  `admins` array index `idDelegate` this returns that delegates\r\n    ///  corresponding index in the delegationChain. Otherwise it returns\r\n    ///  the NOTFOUND constant\r\n    function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns(uint64) {\r\n        for (uint i=0; i < p.delegationChain.length; i++) {\r\n            if (p.delegationChain[i] == idDelegate) return uint64(i);\r\n        }\r\n        return NOTFOUND;\r\n    }\r\n\r\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\r\n    ///  had using a self-referential loop\r\n    /// @param p The Pledge being queried\r\n    /// @return The number of old \"parent\" pledges a specific Pledge had\r\n    function getPledgeLevel(Pledge p) internal returns(uint) {\r\n        if (p.oldPledge == 0) return 0;\r\n        Pledge storage oldN = findPledge(p.oldPledge);\r\n        return getPledgeLevel(oldN) + 1; // a loop lookup\r\n    }\r\n\r\n    /// @notice A getter to find the longest commitTime out of the owner and all\r\n    ///  the delegates for a specified pledge\r\n    /// @param p The Pledge being queried\r\n    /// @return The maximum commitTime out of the owner and all the delegates\r\n    function maxCommitTime(Pledge p) internal returns(uint commitTime) {\r\n        PledgeAdmin storage m = findAdmin(p.owner);\r\n        commitTime = m.commitTime; // start with the owner's commitTime\r\n\r\n        for (uint i=0; i<p.delegationChain.length; i++) {\r\n            m = findAdmin(p.delegationChain[i]);\r\n\r\n            // If a delegate's commitTime is longer, make it the new commitTime\r\n            if (m.commitTime > commitTime) commitTime = m.commitTime;\r\n        }\r\n    }\r\n\r\n    /// @notice A getter to find the level of authority a specific Project has\r\n    ///  using a self-referential loop\r\n    /// @param m The Project being queried\r\n    /// @return The level of authority a specific Project has\r\n    function getProjectLevel(PledgeAdmin m) internal returns(uint) {\r\n        assert(m.adminType == PledgeAdminType.Project);\r\n        if (m.parentProject == 0) return(1);\r\n        PledgeAdmin storage parentNM = findAdmin(m.parentProject);\r\n        return getProjectLevel(parentNM) + 1;\r\n    }\r\n\r\n    /// @notice A getter to find if a specified Project has been canceled\r\n    /// @param projectId The Admin id number used to specify the Project\r\n    /// @return True if the Project has been canceled\r\n    function isProjectCanceled(uint64 projectId) constant returns (bool) {\r\n        PledgeAdmin storage m = findAdmin(projectId);\r\n        if (m.adminType == PledgeAdminType.Giver) return false;\r\n        assert(m.adminType == PledgeAdminType.Project);\r\n        if (m.canceled) return true;\r\n        if (m.parentProject == 0) return false;\r\n        return isProjectCanceled(m.parentProject);\r\n    }\r\n\r\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\r\n    /// @param idPledge The starting place to lookup the pledges \r\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\r\n    function getOldestPledgeNotCanceled(uint64 idPledge\r\n        ) internal constant returns(uint64) {\r\n        if (idPledge == 0) return 0;\r\n        Pledge storage p = findPledge(idPledge);\r\n        PledgeAdmin storage admin = findAdmin(p.owner);\r\n        if (admin.adminType == PledgeAdminType.Giver) return idPledge;\r\n\r\n        assert(admin.adminType == PledgeAdminType.Project);\r\n\r\n        if (!isProjectCanceled(p.owner)) return idPledge;\r\n\r\n        return getOldestPledgeNotCanceled(p.oldPledge);\r\n    }\r\n\r\n    /// @notice A check to see if the msg.sender is the owner or the\r\n    ///  plugin contract for a specific Admin\r\n    /// @param m The Admin being checked\r\n    function checkAdminOwner(PledgeAdmin m) internal constant {\r\n        require((msg.sender == m.addr) || (msg.sender == address(m.plugin)));\r\n    }\r\n///////////////////////////\r\n// Plugin Whitelist Methods\r\n///////////////////////////\r\n\r\n    function addValidPlugin(bytes32 contractHash) external onlyOwner {\r\n        pluginWhitelist[contractHash] = true;\r\n    }\r\n\r\n    function removeValidPlugin(bytes32 contractHash) external onlyOwner {\r\n        pluginWhitelist[contractHash] = false;\r\n    }\r\n\r\n    function useWhitelist(bool useWhitelist) external onlyOwner {\r\n        usePluginWhitelist = useWhitelist;\r\n    }\r\n\r\n    function isValidPlugin(address addr) public returns(bool) {\r\n        if (!usePluginWhitelist || addr == 0x0) return true;\r\n\r\n        bytes32 contractHash = getCodeHash(addr);\r\n\r\n        return pluginWhitelist[contractHash];\r\n    }\r\n\r\n    function getCodeHash(address addr) public returns(bytes32) {\r\n        bytes memory o_code;\r\n        assembly {\r\n            // retrieve the size of the code, this needs assembly\r\n            let size := extcodesize(addr)\r\n            // allocate output byte array - this could also be done without assembly\r\n            // by using o_code = new bytes(size)\r\n            o_code := mload(0x40)\r\n            // new \"memory end\" including padding\r\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            // store length in memory\r\n            mstore(o_code, size)\r\n            // actually retrieve the code, this needs assembly\r\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\r\n        }\r\n        return keccak256(o_code);\r\n    }\r\n}\r\n\r\n//File: node_modules/liquidpledging/contracts/LiquidPledging.sol\r\npragma solidity ^0.4.11;\r\n\r\n/*\r\n    Copyright 2017, Jordi Baylina\r\n    Contributor: Adri\u00e0 Massanet <adria@codecontext.io>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n// Contract Imports\r\n\r\n\r\n/// @dev `LiquidPleding` allows for liquid pledging through the use of\r\n///  internal id structures and delegate chaining. All basic operations for\r\n///  handling liquid pledging are supplied as well as plugin features\r\n///  to allow for expanded functionality.\r\ncontract LiquidPledging is LiquidPledgingBase {\r\n\r\n\r\n//////\r\n// Constructor\r\n//////\r\n\r\n    /// @notice Basic constructor for LiquidPleding, also calls the\r\n    ///  LiquidPledgingBase contract\r\n    /// @dev This constructor  also calls the constructor \r\n    ///  for `LiquidPledgingBase`\r\n    /// @param _vault The vault where ETH backing this pledge is stored\r\n    function LiquidPledging(\r\n        address _vault,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) LiquidPledgingBase(_vault, _escapeHatchCaller, _escapeHatchDestination) {\r\n\r\n    }\r\n\r\n    /// @notice This is how value enters into the system which creates pledges;\r\n    ///  the token of value goes into the vault and the amount in the pledge\r\n    ///  relevant to this Giver without delegates is increased, and a normal\r\n    ///  transfer is done to the idReceiver\r\n    /// @param idGiver Identifier of the giver thats donating.\r\n    /// @param idReceiver To whom it's transfered. Can be the same giver,\r\n    ///  another giver, a delegate or a project.\r\n    function donate(uint64 idGiver, uint64 idReceiver) payable {\r\n        if (idGiver == 0) {\r\n            // default to 3 day commitTime\r\n            idGiver = addGiver(\"\", \"\", 259200, ILiquidPledgingPlugin(0x0));\r\n        }\r\n\r\n        PledgeAdmin storage sender = findAdmin(idGiver);\r\n\r\n        checkAdminOwner(sender);\r\n\r\n        require(sender.adminType == PledgeAdminType.Giver);\r\n\r\n        uint amount = msg.value;\r\n\r\n        require(amount > 0);\r\n\r\n        vault.transfer(amount); // transfers the baseToken to the Vault\r\n        uint64 idPledge = findOrCreatePledge(\r\n            idGiver,\r\n            new uint64[](0), //what is new?\r\n            0,\r\n            0,\r\n            0,\r\n            PledgeState.Pledged\r\n        );\r\n\r\n\r\n        Pledge storage nTo = findPledge(idPledge);\r\n        nTo.amount += amount;\r\n\r\n        Transfer(0, idPledge, amount);\r\n\r\n        transfer(idGiver, idPledge, amount, idReceiver);\r\n    }\r\n\r\n\r\n    /// @notice Moves value between pledges\r\n    /// @param idSender ID of the giver, delegate or project admin that is \r\n    ///  transferring the funds from Pledge to Pledge; this admin must have \r\n    ///  permissions to move the value\r\n    /// @param idPledge Id of the pledge that's moving the value\r\n    /// @param amount Quantity of value that's being moved\r\n    /// @param idReceiver Destination of the value, can be a giver sending to \r\n    ///  a giver or a delegate, a delegate to another delegate or a project \r\n    ///  to pre-commit it to that project if called from a delegate,\r\n    ///  or to commit it to the project if called from the owner. \r\n    function transfer(\r\n        uint64 idSender,\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    )\r\n    {\r\n\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n        PledgeAdmin storage receiver = findAdmin(idReceiver);\r\n        PledgeAdmin storage sender = findAdmin(idSender);\r\n\r\n        checkAdminOwner(sender);\r\n        require(p.pledgeState == PledgeState.Pledged);\r\n\r\n        // If the sender is the owner\r\n        if (p.owner == idSender) {\r\n            if (receiver.adminType == PledgeAdminType.Giver) {\r\n                transferOwnershipToGiver(idPledge, amount, idReceiver);\r\n            } else if (receiver.adminType == PledgeAdminType.Project) {\r\n                transferOwnershipToProject(idPledge, amount, idReceiver);\r\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\r\n                idPledge = undelegate(\r\n                    idPledge,\r\n                    amount,\r\n                    p.delegationChain.length\r\n                );\r\n                appendDelegate(idPledge, amount, idReceiver);\r\n            } else {\r\n                assert(false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // If the sender is a delegate\r\n        uint senderDIdx = getDelegateIdx(p, idSender);\r\n        if (senderDIdx != NOTFOUND) {\r\n\r\n            // If the receiver is another giver\r\n            if (receiver.adminType == PledgeAdminType.Giver) {\r\n                // Only accept to change to the original giver to\r\n                // remove all delegates\r\n                assert(p.owner == idReceiver);\r\n                undelegate(idPledge, amount, p.delegationChain.length);\r\n                return;\r\n            }\r\n\r\n            // If the receiver is another delegate\r\n            if (receiver.adminType == PledgeAdminType.Delegate) {\r\n                uint receiverDIdx = getDelegateIdx(p, idReceiver);\r\n\r\n                // If the receiver is not in the delegate list\r\n                if (receiverDIdx == NOTFOUND) {\r\n                    idPledge = undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - senderDIdx - 1\r\n                    );\r\n                    appendDelegate(idPledge, amount, idReceiver);\r\n\r\n                // If the receiver is already part of the delegate chain and is\r\n                // after the sender, then all of the other delegates after the\r\n                // sender are removed and the receiver is appended at the\r\n                // end of the delegation chain\r\n                } else if (receiverDIdx > senderDIdx) {\r\n                    idPledge = undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - senderDIdx - 1\r\n                    );\r\n                    appendDelegate(idPledge, amount, idReceiver);\r\n\r\n                // If the receiver is already part of the delegate chain and is\r\n                // before the sender, then the sender and all of the other\r\n                // delegates after the RECEIVER are removed from the chain,\r\n                // this is interesting because the delegate is removed from the\r\n                // delegates that delegated to this delegate. Are there game theory\r\n                // issues? should this be allowed?\r\n                } else if (receiverDIdx <= senderDIdx) {\r\n                    undelegate(\r\n                        idPledge,\r\n                        amount,\r\n                        p.delegationChain.length - receiverDIdx - 1\r\n                    );\r\n                }\r\n                return;\r\n            }\r\n\r\n            // If the delegate wants to support a project, they remove all\r\n            // the delegates after them in the chain and choose a project\r\n            if (receiver.adminType == PledgeAdminType.Project) {\r\n                idPledge = undelegate(\r\n                    idPledge,\r\n                    amount,\r\n                    p.delegationChain.length - senderDIdx - 1\r\n                );\r\n                proposeAssignProject(idPledge, amount, idReceiver);\r\n                return;\r\n            }\r\n        }\r\n        assert(false);  // It is not the owner nor any delegate.\r\n    }\r\n\r\n    /// @notice This method is used to withdraw value from the system.\r\n    ///  This can be used by the givers withdraw any un-commited donations.\r\n    /// @param idPledge Id of the pledge that wants to be withdrawn.\r\n    /// @param amount Quantity of Ether that wants to be withdrawn.\r\n    function withdraw(uint64 idPledge, uint amount) {\r\n\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Pledged);\r\n\r\n        PledgeAdmin storage owner = findAdmin(p.owner);\r\n\r\n        checkAdminOwner(owner);\r\n\r\n        uint64 idNewPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Paying\r\n        );\r\n\r\n        doTransfer(idPledge, idNewPledge, amount);\r\n\r\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);\r\n    }\r\n\r\n    /// @notice Method called by the vault to confirm a payment.\r\n    /// @param idPledge Id of the pledge that wants to be withdrawn.\r\n    /// @param amount Quantity of Ether that wants to be withdrawn.\r\n    function confirmPayment(uint64 idPledge, uint amount) onlyVault {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Paying);\r\n\r\n        uint64 idNewPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Paid\r\n        );\r\n\r\n        doTransfer(idPledge, idNewPledge, amount);\r\n    }\r\n\r\n    /// @notice Method called by the vault to cancel a payment.\r\n    /// @param idPledge Id of the pledge that wants to be canceled for withdraw.\r\n    /// @param amount Quantity of Ether that wants to be rolled back.\r\n    function cancelPayment(uint64 idPledge, uint amount) onlyVault {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.pledgeState == PledgeState.Paying); //TODO change to revert\r\n\r\n        // When a payment is canceled, never is assigned to a project.\r\n        uint64 oldPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n\r\n        oldPledge = normalizePledge(oldPledge);\r\n\r\n        doTransfer(idPledge, oldPledge, amount);\r\n    }\r\n\r\n    /// @notice Method called to cancel this project.\r\n    /// @param idProject Id of the projct that wants to be canceled.\r\n    function cancelProject(uint64 idProject) {\r\n        PledgeAdmin storage project = findAdmin(idProject);\r\n        checkAdminOwner(project);\r\n        project.canceled = true;\r\n\r\n        CancelProject(idProject);\r\n    }\r\n\r\n    /// @notice Method called to cancel specific pledge.\r\n    /// @param idPledge Id of the pledge that should be canceled.\r\n    /// @param amount Quantity of Ether that wants to be rolled back.\r\n    function cancelPledge(uint64 idPledge, uint amount) {\r\n        idPledge = normalizePledge(idPledge);\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n        require(p.oldPledge != 0);\r\n\r\n        PledgeAdmin storage m = findAdmin(p.owner);\r\n        checkAdminOwner(m);\r\n\r\n        uint64 oldPledge = getOldestPledgeNotCanceled(p.oldPledge);\r\n        doTransfer(idPledge, oldPledge, amount);\r\n    }\r\n\r\n\r\n////////\r\n// Multi pledge methods\r\n////////\r\n\r\n    // @dev This set of functions makes moving a lot of pledges around much more\r\n    // efficient (saves gas) than calling these functions in series\r\n    \r\n    \r\n    /// Bit mask used for dividing pledge amounts in Multi pledge methods\r\n    uint constant D64 = 0x10000000000000000;\r\n\r\n    /// @notice `mTransfer` allows for multiple pledges to be transferred\r\n    ///  efficiently\r\n    /// @param idSender ID of the giver, delegate or project admin that is\r\n    ///  transferring the funds from Pledge to Pledge. This admin must have \r\n    ///  permissions to move the value\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    /// @param idReceiver Destination of the value, can be a giver sending\r\n    ///  to a giver or a delegate or a delegate to another delegate or a\r\n    ///  project to pre-commit it to that project\r\n    function mTransfer(\r\n        uint64 idSender,\r\n        uint[] pledgesAmounts,\r\n        uint64 idReceiver\r\n    ) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            transfer(idSender, idPledge, amount, idReceiver);\r\n        }\r\n    }\r\n\r\n    /// @notice `mWithdraw` allows for multiple pledges to be\r\n    ///  withdrawn efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are\r\n    ///  extrapolated using the D64 bitmask\r\n    function mWithdraw(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            withdraw(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed\r\n    ///  efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    function mConfirmPayment(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            confirmPayment(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mCancelPayment` allows for multiple pledges to be canceled\r\n    ///  efficiently\r\n    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\r\n    ///  using the D64 bitmask\r\n    function mCancelPayment(uint[] pledgesAmounts) {\r\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\r\n            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\r\n            uint amount = pledgesAmounts[i] / D64;\r\n\r\n            cancelPayment(idPledge, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\r\n    ///  normalized efficiently\r\n    /// @param pledges An array of pledge IDs\r\n    function mNormalizePledge(uint64[] pledges) {\r\n        for (uint i = 0; i < pledges.length; i++ ) {\r\n            normalizePledge( pledges[i] );\r\n        }\r\n    }\r\n\r\n////////\r\n// Private methods\r\n///////\r\n\r\n    /// @notice `transferOwnershipToProject` allows for the transfer of\r\n    ///  ownership to the project, but it can also be called by a project\r\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\r\n    /// @param idPledge Id of the pledge to be transfered.\r\n    /// @param amount Quantity of value that's being transfered\r\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\r\n    function transferOwnershipToProject(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Ensure that the pledge is not already at max pledge depth\r\n        // and the project has not been canceled\r\n        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\r\n        require(!isProjectCanceled(idReceiver));\r\n\r\n        uint64 oldPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        uint64 toPledge = findOrCreatePledge(\r\n            idReceiver,                     // Set the new owner\r\n            new uint64[](0),                // clear the delegation chain\r\n            0,\r\n            0,\r\n            oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }   \r\n\r\n\r\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\r\n    ///  value back to the Giver, value is placed in a pledged state\r\n    ///  without being attached to a project, delegation chain, or time line.\r\n    /// @param idPledge Id of the pledge to be transfered.\r\n    /// @param amount Quantity of value that's being transfered\r\n    /// @param idReceiver The new owner of the pledge\r\n    function transferOwnershipToGiver(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        uint64 toPledge = findOrCreatePledge(\r\n            idReceiver,\r\n            new uint64[](0),\r\n            0,\r\n            0,\r\n            0,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\r\n    ///  end of the delegate chain for a given Pledge.\r\n    /// @param idPledge Id of the pledge thats delegate chain will be modified.\r\n    /// @param amount Quantity of value that's being chained.\r\n    /// @param idReceiver The delegate to be added at the end of the chain\r\n    function appendDelegate(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(p.delegationChain.length < MAX_DELEGATES);\r\n        uint64[] memory newDelegationChain = new uint64[](\r\n            p.delegationChain.length + 1\r\n        );\r\n        for (uint i = 0; i<p.delegationChain.length; i++) {\r\n            newDelegationChain[i] = p.delegationChain[i];\r\n        }\r\n\r\n        // Make the last item in the array the idReceiver\r\n        newDelegationChain[p.delegationChain.length] = idReceiver;\r\n\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            newDelegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\r\n    ///  end of the delegate chain for a given Pledge.\r\n    /// @param idPledge Id of the pledge thats delegate chain will be modified.\r\n    /// @param amount Quantity of value that's shifted from delegates.\r\n    /// @param q Number (or depth) to remove as delegates\r\n    function undelegate(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint q\r\n    ) internal returns (uint64){\r\n        Pledge storage p = findPledge(idPledge);\r\n        uint64[] memory newDelegationChain = new uint64[](\r\n            p.delegationChain.length - q\r\n        );\r\n        for (uint i=0; i<p.delegationChain.length - q; i++) {\r\n            newDelegationChain[i] = p.delegationChain[i];\r\n        }\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            newDelegationChain,\r\n            0,\r\n            0,\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n\r\n        return toPledge;\r\n    }\r\n\r\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\r\n    ///  to a specific project.\r\n    /// @dev This function should potentially be named more specifically.\r\n    /// @param idPledge Id of the pledge that will be assigned.\r\n    /// @param amount Quantity of value this pledge leader would be assigned.\r\n    /// @param idReceiver The project this pledge will potentially \r\n    ///  be assigned to.\r\n    function proposeAssignProject(\r\n        uint64 idPledge,\r\n        uint amount,\r\n        uint64 idReceiver\r\n    ) internal {\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\r\n        require(!isProjectCanceled(idReceiver));\r\n\r\n        uint64 toPledge = findOrCreatePledge(\r\n            p.owner,\r\n            p.delegationChain,\r\n            idReceiver,\r\n            uint64(getTime() + maxCommitTime(p)),\r\n            p.oldPledge,\r\n            PledgeState.Pledged\r\n        );\r\n        doTransfer(idPledge, toPledge, amount);\r\n    }\r\n\r\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \r\n    ///  shifted around internally.\r\n    /// @param from This is the Id from which value will be transfered.\r\n    /// @param to This is the Id that value will be transfered to.\r\n    /// @param _amount The amount of value that will be transfered.\r\n    function doTransfer(uint64 from, uint64 to, uint _amount) internal {\r\n        uint amount = callPlugins(true, from, to, _amount);\r\n        if (from == to) { \r\n            return;\r\n        }\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        Pledge storage nFrom = findPledge(from);\r\n        Pledge storage nTo = findPledge(to);\r\n        require(nFrom.amount >= amount);\r\n        nFrom.amount -= amount;\r\n        nTo.amount += amount;\r\n\r\n        Transfer(from, to, amount);\r\n        callPlugins(false, from, to, amount);\r\n    }\r\n\r\n    /// @notice `normalizePledge` only affects pledges with the Pledged PledgeState\r\n    /// and does 2 things:\r\n    ///   #1: Checks if the pledge should be committed. This means that\r\n    ///       if the pledge has an intendedProject and it is past the\r\n    ///       commitTime, it changes the owner to be the proposed project\r\n    ///       (The UI will have to read the commit time and manually do what\r\n    ///       this function does to the pledge for the end user\r\n    ///       at the expiration of the commitTime)\r\n    ///\r\n    ///   #2: Checks to make sure that if there has been a cancellation in the\r\n    ///       chain of projects, the pledge's owner has been changed\r\n    ///       appropriately.\r\n    ///\r\n    /// This function can be called by anybody at anytime on any pledge.\r\n    /// In general it can be called to force the calls of the affected \r\n    /// plugins, which also need to be predicted by the UI\r\n    /// @param idPledge This is the id of the pledge that will be normalized\r\n    function normalizePledge(uint64 idPledge) returns(uint64) {\r\n\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Check to make sure this pledge hasn't already been used \r\n        // or is in the process of being used\r\n        if (p.pledgeState != PledgeState.Pledged) {\r\n            return idPledge;\r\n        }\r\n\r\n        // First send to a project if it's proposed and committed\r\n        if ((p.intendedProject > 0) && ( getTime() > p.commitTime)) {\r\n            uint64 oldPledge = findOrCreatePledge(\r\n                p.owner,\r\n                p.delegationChain,\r\n                0,\r\n                0,\r\n                p.oldPledge,\r\n                PledgeState.Pledged\r\n            );\r\n            uint64 toPledge = findOrCreatePledge(\r\n                p.intendedProject,\r\n                new uint64[](0),\r\n                0,\r\n                0,\r\n                oldPledge,\r\n                PledgeState.Pledged\r\n            );\r\n            doTransfer(idPledge, toPledge, p.amount);\r\n            idPledge = toPledge;\r\n            p = findPledge(idPledge);\r\n        }\r\n\r\n        toPledge = getOldestPledgeNotCanceled(idPledge);\r\n        if (toPledge != idPledge) {\r\n            doTransfer(idPledge, toPledge, p.amount);\r\n        }\r\n\r\n        return toPledge;\r\n    }\r\n\r\n/////////////\r\n// Plugins\r\n/////////////\r\n\r\n    /// @notice `callPlugin` is used to trigger the general functions in the\r\n    ///  plugin for any actions needed before and after a transfer happens.\r\n    ///  Specifically what this does in relation to the plugin is something\r\n    ///  that largely depends on the functions of that plugin. This function\r\n    ///  is generally called in pairs, once before, and once after a transfer.\r\n    /// @param before This toggle determines whether the plugin call is occurring\r\n    ///  before or after a transfer.\r\n    /// @param adminId This should be the Id of the *trusted* individual\r\n    ///  who has control over this plugin.\r\n    /// @param fromPledge This is the Id from which value is being transfered.\r\n    /// @param toPledge This is the Id that value is being transfered to.\r\n    /// @param context The situation that is triggering the plugin. See plugin\r\n    ///  for a full description of contexts.\r\n    /// @param amount The amount of value that is being transfered.\r\n    function callPlugin(\r\n        bool before,\r\n        uint64 adminId,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint64 context,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n\r\n        uint newAmount;\r\n        allowedAmount = amount;\r\n        PledgeAdmin storage admin = findAdmin(adminId);\r\n        // Checks admin has a plugin assigned and a non-zero amount is requested\r\n        if ((address(admin.plugin) != 0) && (allowedAmount > 0)) {\r\n            // There are two seperate functions called in the plugin.\r\n            // One is called before the transfer and one after\r\n            if (before) {\r\n                newAmount = admin.plugin.beforeTransfer(\r\n                    adminId,\r\n                    fromPledge,\r\n                    toPledge,\r\n                    context,\r\n                    amount\r\n                );\r\n                require(newAmount <= allowedAmount);\r\n                allowedAmount = newAmount;\r\n            } else {\r\n                admin.plugin.afterTransfer(\r\n                    adminId,\r\n                    fromPledge,\r\n                    toPledge,\r\n                    context,\r\n                    amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\r\n    ///  the delegate chain and the intended project if there is one.\r\n    ///  It does so in either a transferring or receiving context based\r\n    ///  on the `idPledge` and  `fromPledge` parameters.\r\n    /// @param before This toggle determines whether the plugin call is occuring\r\n    ///  before or after a transfer.\r\n    /// @param idPledge This is the Id of the pledge on which this plugin\r\n    ///  is being called.\r\n    /// @param fromPledge This is the Id from which value is being transfered.\r\n    /// @param toPledge This is the Id that value is being transfered to.\r\n    /// @param amount The amount of value that is being transfered.\r\n    function callPluginsPledge(\r\n        bool before,\r\n        uint64 idPledge,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n        // Determine if callPlugin is being applied in a receiving\r\n        // or transferring context\r\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\r\n        allowedAmount = amount;\r\n        Pledge storage p = findPledge(idPledge);\r\n\r\n        // Always call the plugin on the owner\r\n        allowedAmount = callPlugin(\r\n            before,\r\n            p.owner,\r\n            fromPledge,\r\n            toPledge,\r\n            offset,\r\n            allowedAmount\r\n        );\r\n\r\n        // Apply call plugin to all delegates\r\n        for (uint64 i=0; i<p.delegationChain.length; i++) {\r\n            allowedAmount = callPlugin(\r\n                before,\r\n                p.delegationChain[i],\r\n                fromPledge,\r\n                toPledge,\r\n                offset + i+1,\r\n                allowedAmount\r\n            );\r\n        }\r\n\r\n        // If there is an intended project also call the plugin in\r\n        // either a transferring or receiving context based on offset\r\n        // on the intended project\r\n        if (p.intendedProject > 0) {\r\n            allowedAmount = callPlugin(\r\n                before,\r\n                p.intendedProject,\r\n                fromPledge,\r\n                toPledge,\r\n                offset + 255,\r\n                allowedAmount\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\r\n    ///  context and once for the receiving context. The aggregated \r\n    ///  allowed amount is then returned.\r\n    /// @param before This toggle determines whether the plugin call is occurring\r\n    ///  before or after a transfer.\r\n    /// @param fromPledge This is the Id from which value is being transferred.\r\n    /// @param toPledge This is the Id that value is being transferred to.\r\n    /// @param amount The amount of value that is being transferred.\r\n    function callPlugins(\r\n        bool before,\r\n        uint64 fromPledge,\r\n        uint64 toPledge,\r\n        uint amount\r\n    ) internal returns (uint allowedAmount) {\r\n        allowedAmount = amount;\r\n\r\n        // Call the pledges plugins in the transfer context\r\n        allowedAmount = callPluginsPledge(\r\n            before,\r\n            fromPledge,\r\n            fromPledge,\r\n            toPledge,\r\n            allowedAmount\r\n        );\r\n\r\n        // Call the pledges plugins in the receive context\r\n        allowedAmount = callPluginsPledge(\r\n            before,\r\n            toPledge,\r\n            fromPledge,\r\n            toPledge,\r\n            allowedAmount\r\n        );\r\n    }\r\n\r\n/////////////\r\n// Test functions\r\n/////////////\r\n\r\n    /// @notice Basic helper function to return the current time\r\n    function getTime() internal returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    // Event Delcerations\r\n    event Transfer(uint64 indexed from, uint64 indexed to, uint amount);\r\n    event CancelProject(uint64 indexed idProject);\r\n\r\n}\r\n\r\n//File: node_modules/minimetoken/contracts/Controlled.sol\r\npragma solidity ^0.4.18;\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() public { controller = msg.sender;}\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n//File: node_modules/minimetoken/contracts/TokenController.sol\r\npragma solidity ^0.4.18;\r\n\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public\r\n        returns(bool);\r\n}\r\n\r\n//File: node_modules/minimetoken/contracts/MiniMeToken.sol\r\npragma solidity ^0.4.18;\r\n\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n/// @title MiniMeToken Contract\r\n/// @author Jordi Baylina\r\n/// @dev This token contract's goal is to make it easy for anyone to clone this\r\n///  token using the token distribution at a given block, this will allow DAO's\r\n///  and DApps to upgrade their features in a decentralized manner without\r\n///  affecting the original token\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\n\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\n/// @dev The actual token contract, the default controller is the msg.sender\r\n///  that deploys the contract, so usually this token will be deployed by a\r\n///  token controller contract, which Giveth will call a \"Campaign\"\r\ncontract MiniMeToken is Controlled {\r\n\r\n    string public name;                //The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             //Number of decimals of the smallest unit\r\n    string public symbol;              //An identifier: e.g. REP\r\n    string public version = 'MMT_0.2'; //An arbitrary versioning scheme\r\n\r\n\r\n    /// @dev `Checkpoint` is the structure that attaches a block number to a\r\n    ///  given value, the block number attached is the one that last changed the\r\n    ///  value\r\n    struct  Checkpoint {\r\n\r\n        // `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        // `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    // `parentToken` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    //  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    // `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the block number that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    // The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n////////////////\r\n// Constructor\r\n////////////////\r\n\r\n    /// @notice Constructor to create a MiniMeToken\r\n    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    ///  will create the Clone token contracts, the token factory needs to be\r\n    ///  deployed first\r\n    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param _parentSnapShotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token, set to 0 if it\r\n    ///  is a new token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 // Set the name\r\n        decimals = _decimalUnits;                          // Set the decimals\r\n        symbol = _tokenSymbol;                             // Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n///////////////////\r\n// ERC20 Methods\r\n///////////////////\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n\r\n        // The controller of this contract can move tokens around at will,\r\n        //  this is important to recognize! Confirm that you trust the\r\n        //  controller of this contract, which in most situations should be\r\n        //  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            // The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           require(parentSnapShotBlock < block.number);\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           require((_to != 0) && (_to != address(this)));\r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n        // Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n////////////////\r\n// Query balance and totalSupply in History\r\n////////////////\r\n\r\n    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @param _blockNumber The block number when the balance is queried\r\n    /// @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant\r\n        returns (uint) {\r\n\r\n        // These next few lines are used when the balance of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.balanceOfAt` be queried at the\r\n        //  genesis block for that token as this contains initial balance of\r\n        //  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                // Has no parent\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    /// @notice Total amount of tokens at a specific `_blockNumber`.\r\n    /// @param _blockNumber The block number when the totalSupply is queried\r\n    /// @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n\r\n        // These next few lines are used when the totalSupply of the token is\r\n        //  requested before a check point was ever created for this token, it\r\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        //  genesis block for this token as that contains totalSupply of this\r\n        //  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        // This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n////////////////\r\n// Clone Token Method\r\n////////////////\r\n\r\n    /// @notice Creates a new clone token with the initial distribution being\r\n    ///  this token at `_snapshotBlock`\r\n    /// @param _cloneTokenName Name of the clone token\r\n    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    /// @param _cloneTokenSymbol Symbol of the clone token\r\n    /// @param _snapshotBlock Block when the distribution of the parent token is\r\n    ///  copied to set the initial distribution of the new clone token;\r\n    ///  if the block is zero than the actual block, the current block is used\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    /// @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) public returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        // An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n////////////////\r\n// Generate and destroy tokens\r\n////////////////\r\n\r\n    /// @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    /// @param _owner The address that will be assigned the new tokens\r\n    /// @param _amount The quantity of tokens generated\r\n    /// @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) public onlyController returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @notice Burns `_amount` tokens from `_owner`\r\n    /// @param _owner The address that will lose the tokens\r\n    /// @param _amount The quantity of tokens to burn\r\n    /// @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController public returns (bool) {\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= _amount);\r\n        uint previousBalanceFrom = balanceOf(_owner);\r\n        require(previousBalanceFrom >= _amount);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n////////////////\r\n// Enable tokens transfers\r\n////////////////\r\n\r\n\r\n    /// @notice Enables token holders to transfer their tokens freely if true\r\n    /// @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) public onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n////////////////\r\n// Internal helper functions to query and set a value in a snapshot array\r\n////////////////\r\n\r\n    /// @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    /// @param checkpoints The history of values being queried\r\n    /// @param _block The block number to retrieve the value at\r\n    /// @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        // Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    /// @dev `updateValueAtNow` used to update the `balances` map and the\r\n    ///  `totalSupplyHistory`\r\n    /// @param checkpoints The history of data being updated\r\n    /// @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    /// @dev Internal function to determine if an address is a contract\r\n    /// @param _addr The address being queried\r\n    /// @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    /// @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /// @notice The fallback function: If the contract's controller has not been\r\n    ///  set to 0, then the `proxyPayment` method is called which relays the\r\n    ///  ether and creates tokens as described in the token controller contract\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\r\n    }\r\n\r\n//////////\r\n// Safety Methods\r\n//////////\r\n\r\n    /// @notice This method can be used by the controller to extract mistakenly\r\n    ///  sent tokens to this contract.\r\n    /// @param _token The address of the token contract that you want to recover\r\n    ///  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        MiniMeToken token = MiniMeToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n////////////////\r\n// Events\r\n////////////////\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\n\r\n////////////////\r\n// MiniMeTokenFactory\r\n////////////////\r\n\r\n/// @dev This contract is used to generate clone contracts from a contract.\r\n///  In solidity this is the way to create a contract from a contract of the\r\n///  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    /// @notice Update the DApp by creating a new token with new functionalities\r\n    ///  the msg.sender becomes the controller of this clone token\r\n    /// @param _parentToken Address of the token being cloned\r\n    /// @param _snapshotBlock Block of the parent token that will\r\n    ///  determine the initial distribution of the clone token\r\n    /// @param _tokenName Name of the new token\r\n    /// @param _decimalUnits Number of decimals of the new token\r\n    /// @param _tokenSymbol Token Symbol for the new token\r\n    /// @param _transfersEnabled If true, tokens will be able to be transferred\r\n    /// @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) public returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n//File: contracts/LPPCampaign.sol\r\npragma solidity ^0.4.13;\r\n\r\n\r\n\r\n\r\n\r\n/// @title LPPCampaign\r\n/// @author perissology <perissology@protonmail.com>\r\n/// @notice The LPPCampaign contract is a plugin contract for liquidPledging,\r\n///  extending the functionality of a liquidPledging project. This contract\r\n///  prevents withdrawals from any pledges this contract is the owner of.\r\n///  This contract has 2 roles. The owner and a reviewer. The owner can transfer or cancel\r\n///  any pledges this contract owns. The reviewer can only cancel the pledges.\r\n///  If this contract is canceled, all pledges will be rolled back to the previous owner\r\n///  and will reject all future pledge transfers to the pledgeAdmin represented by this contract\r\ncontract LPPCampaign is Escapable, TokenController {\r\n    uint constant FROM_OWNER = 0;\r\n    uint constant FROM_PROPOSEDPROJECT = 255;\r\n    uint constant TO_OWNER = 256;\r\n    uint constant TO_PROPOSEDPROJECT = 511;\r\n\r\n    LiquidPledging public liquidPledging;\r\n    MiniMeToken public token;\r\n    bool public initPending;\r\n    uint64 public idProject;\r\n    address public reviewer;\r\n    address public newReviewer;\r\n\r\n    event GenerateTokens(address indexed liquidPledging, address addr, uint amount);\r\n\r\n    function LPPCampaign(\r\n        LiquidPledging _liquidPledging,\r\n        string tokenName,\r\n        string tokenSymbol,\r\n        address _escapeHatchCaller,\r\n        address _escapeHatchDestination\r\n    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public\r\n    {\r\n      require(msg.sender != tx.origin);\r\n      liquidPledging = _liquidPledging;\r\n      MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();\r\n      token = new MiniMeToken(tokenFactory, 0x0, 0, tokenName, 18, tokenSymbol, false);\r\n      initPending = true;\r\n    }\r\n\r\n    function init(\r\n        string name,\r\n        string url,\r\n        uint64 parentProject,\r\n        address _reviewer\r\n    ) {\r\n        require(initPending);\r\n        idProject = liquidPledging.addProject(name, url, address(this), parentProject, 0, ILiquidPledgingPlugin(this));\r\n        reviewer = _reviewer;\r\n        initPending = false;\r\n    }\r\n\r\n    modifier initialized() {\r\n      require(!initPending);\r\n      _;\r\n    }\r\n\r\n    modifier onlyReviewer() {\r\n        require(msg.sender == reviewer);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrReviewer() {\r\n        require( msg.sender == owner || msg.sender == reviewer );\r\n        _;\r\n    }\r\n\r\n    function changeReviewer(address _newReviewer) public initialized onlyReviewer {\r\n        newReviewer = _newReviewer;\r\n    }\r\n\r\n    function acceptNewReviewer() public initialized {\r\n        require(newReviewer == msg.sender);\r\n        reviewer = newReviewer;\r\n        newReviewer = 0;\r\n    }\r\n\r\n    function beforeTransfer(\r\n        uint64 pledgeAdmin,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    ) external initialized returns (uint maxAllowed) {\r\n        require(msg.sender == address(liquidPledging));\r\n        var (, , , fromProposedProject , , , ) = liquidPledging.getPledge(pledgeFrom);\r\n        var (, , , , , , toPledgeState ) = liquidPledging.getPledge(pledgeTo);\r\n\r\n        // campaigns can not withdraw funds\r\n        if ( (context == TO_OWNER) && (toPledgeState != LiquidPledgingBase.PledgeState.Pledged) ) return 0;\r\n\r\n        // If this campaign is the proposed recipient of delegated funds or funds are being directly\r\n        // transferred to me, ensure that the campaign has not been canceled\r\n        if ( (context == TO_PROPOSEDPROJECT)\r\n            || ( (context == TO_OWNER) && (fromProposedProject != idProject) ))\r\n        {\r\n            if (isCanceled()) return 0;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function afterTransfer(\r\n        uint64 pledgeAdmin,\r\n        uint64 pledgeFrom,\r\n        uint64 pledgeTo,\r\n        uint64 context,\r\n        uint amount\r\n    ) external initialized {\r\n      require(msg.sender == address(liquidPledging));\r\n      var (, , , , , , toPledgeState) = liquidPledging.getPledge(pledgeTo);\r\n      var (, fromOwner, , , , , ) = liquidPledging.getPledge(pledgeFrom);\r\n\r\n      // only issue tokens when pledge is committed to this campaign\r\n      if ( (context == TO_OWNER) &&\r\n              (toPledgeState == LiquidPledgingBase.PledgeState.Pledged)) {\r\n        var (, fromAddr , , , , , , ) = liquidPledging.getPledgeAdmin(fromOwner);\r\n\r\n        token.generateTokens(fromAddr, amount);\r\n        GenerateTokens(liquidPledging, fromAddr, amount);\r\n      }\r\n    }\r\n\r\n    function cancelCampaign() public initialized onlyOwnerOrReviewer {\r\n        require( !isCanceled() );\r\n\r\n        liquidPledging.cancelProject(idProject);\r\n    }\r\n\r\n    function transfer(uint64 idPledge, uint amount, uint64 idReceiver) public initialized onlyOwner {\r\n      require( !isCanceled() );\r\n\r\n      liquidPledging.transfer(idProject, idPledge, amount, idReceiver);\r\n    }\r\n\r\n    function isCanceled() public constant initialized returns (bool) {\r\n      return liquidPledging.isProjectCanceled(idProject);\r\n    }\r\n\r\n    // allows the owner to send any tx, similar to a multi-sig\r\n    // this is necessary b/c the campaign may receive dac/campaign tokens\r\n    // if they transfer a pledge they own to another dac/campaign.\r\n    // this allows the owner to participate in governance with the tokens\r\n    // it holds.\r\n    function sendTransaction(address destination, uint value, bytes data) public initialized onlyOwner {\r\n      require(destination.call.value(value)(data));\r\n    }\r\n\r\n////////////////\r\n// TokenController\r\n////////////////\r\n\r\n  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n  /// @param _owner The address that sent the ether to create tokens\r\n  /// @return True if the ether is accepted, false if it throws\r\n  function proxyPayment(address _owner) public payable initialized returns(bool) {\r\n    return false;\r\n  }\r\n\r\n  /// @notice Notifies the controller about a token transfer allowing the\r\n  ///  controller to react if desired\r\n  /// @param _from The origin of the transfer\r\n  /// @param _to The destination of the transfer\r\n  /// @param _amount The amount of the transfer\r\n  /// @return False if the controller does not authorize the transfer\r\n  function onTransfer(address _from, address _to, uint _amount) public initialized returns(bool) {\r\n    return false;\r\n  }\r\n\r\n  /// @notice Notifies the controller about an approval allowing the\r\n  ///  controller to react if desired\r\n  /// @param _owner The address that calls `approve()`\r\n  /// @param _spender The spender in the `approve()` call\r\n  /// @param _amount The amount in the `approve()` call\r\n  /// @return False if the controller does not authorize the approval\r\n  function onApprove(address _owner, address _spender, uint _amount) public initialized returns(bool) {\r\n    return false;\r\n  }\r\n}\r\n\r\n//File: contracts/LPPCampaignFactory.sol\r\npragma solidity ^0.4.13;\r\n\r\n\r\n\r\ncontract LPPCampaignFactory is Escapable {\r\n\r\n    function LPPCampaignFactory(address _escapeHatchCaller, address _escapeHatchDestination)\r\n        Escapable(_escapeHatchCaller, _escapeHatchDestination)\r\n    {\r\n    }\r\n\r\n    function deploy(\r\n        LiquidPledging liquidPledging,\r\n        string name,\r\n        string url,\r\n        uint64 parentProject,\r\n        address reviewer,\r\n        string tokenName,\r\n        string tokenSymbol,\r\n        address escapeHatchCaller,\r\n        address escapeHatchDestination\r\n  ) {\r\n        LPPCampaign campaign = new LPPCampaign(liquidPledging, tokenName, tokenSymbol, escapeHatchCaller, escapeHatchDestination);\r\n        campaign.init(name, url, parentProject, reviewer);\r\n        campaign.changeOwnership(msg.sender);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchCaller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dac\",\"type\":\"address\"}],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerCandidate\",\"type\":\"address\"}],\"name\":\"proposeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenEscapable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"escapeHatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"liquidPledging\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"parentProject\",\"type\":\"uint64\"},{\"name\":\"reviewer\",\"type\":\"address\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"escapeHatchDestination\",\"type\":\"address\"}],\"name\":\"deploy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEscapeHatchCaller\",\"type\":\"address\"}],\"name\":\"changeHatchEscapeCaller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"escapeHatchDestination\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_escapeHatchCaller\",\"type\":\"address\"},{\"name\":\"_escapeHatchDestination\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"}],\"name\":\"EscapeHatchBlackistedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscapeHatchCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OwnershipRemoved\",\"type\":\"event\"}]", "ContractName": "LPPCampaignFactory", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000502bd2529df24a36dfee57335791be0ee62f8c74000000000000000000000000502bd2529df24a36dfee57335791be0ee62f8c74", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://0edca6ca66cd4acd766c75651d983483024bc7d1bc9e1b07dff3eab68c860315"}]}