{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\n\r\ncontract ScamStampToken {\r\n    //The Scam Stamp Token is intended to mark an address as SCAM.\r\n    //this token is used by the contract ScamStamp defined bellow\r\n    //a false ERC20 token, where transfers can be done only by \r\n    //the creator of the token.\r\n\r\n    string public constant name = \"SCAM Stamp Token\";\r\n    string public constant symbol = \"SCAM_STAMP\";\r\n    uint8 public constant decimals = 0;\r\n    uint256 public totalSupply;\r\n\r\n    // Owner of this contract\r\n    address public owner;\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    // Balances for each account\r\n    mapping(address => uint256) balances;\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    function balanceOf(address _owner) constant returns (uint balance){\r\n        return balances[_owner];\r\n    }\r\n    //Only the owner of the token can transfer.\r\n    //tokens are being generated on the fly,\r\n    //tokenSupply increases with double the amount that is required to be transfered \r\n    //if the amount isn't available to transfer\r\n    //newly generated tokens are never burned.\r\n    function transfer(address _to, uint256 _amount) onlyOwner returns (bool success){\r\n        if(_amount >= 0){\r\n            if(balances[msg.sender] >= _amount){\r\n                balances[msg.sender] -= _amount;\r\n                balances[_to] += _amount;\r\n                Transfer(msg.sender, _to, _amount);\r\n                return true;\r\n                }else{\r\n                    totalSupply += _amount + _amount;   \r\n                    balances[msg.sender] += _amount + _amount;\r\n                    balances[msg.sender] -= _amount;\r\n                    balances[_to] += _amount;\r\n                    Transfer(msg.sender, _to, _amount);\r\n                    return true;\r\n                }\r\n            }\r\n    }\r\n    function transferBack(address _from, uint256 _amount) onlyOwner returns (bool success){\r\n        if(_amount >= 0){\r\n            if(balances[_from] >= _amount){\r\n                balances[_from] -= _amount;\r\n                balances[owner] += _amount;\r\n                Transfer(_from, owner, _amount);\r\n                return true;\r\n            }else{\r\n                _amount = balances[_from];\r\n                balances[_from] -= _amount;\r\n                balances[owner] += _amount;\r\n                Transfer(_from, owner, _amount);\r\n                return true;\r\n            }\r\n            }else{\r\n                return false;\r\n            }\r\n    }\r\n\r\n\r\n    function ScamStampToken(){\r\n        owner = msg.sender;\r\n        totalSupply = 1;\r\n        balances[owner] = totalSupply;\r\n\r\n    }\r\n}\r\n\r\n\r\ncontract ScamStamp{\r\n//the contract is intended as a broker between a scammer address and the scamee\r\nmodifier onlyOwner(){\r\n    require(msg.sender == owner);\r\n    _;\r\n}\r\nmodifier hasMinimumAmountToFlag(){\r\n    require(msg.value >= pricePerUnit);\r\n    _;\r\n}\r\n\r\nfunction mul(uint a, uint b) internal returns (uint) {\r\nuint c = a * b;\r\nrequire(a == 0 || c / a == b);\r\nreturn c;\r\n}\r\n\r\nfunction div(uint a, uint b) internal returns (uint) {\r\nrequire(b > 0);\r\nuint c = a / b;\r\nrequire(a == b * c + a % b);\r\nreturn c;\r\n}\r\n\r\nfunction sub(uint a, uint b) internal returns (uint) {\r\nrequire(b <= a);\r\nreturn a - b;\r\n}\r\n\r\nfunction add(uint a, uint b) internal returns (uint) {\r\nuint c = a + b;\r\nrequire(c >= a);\r\nreturn c;\r\n}\r\n\r\n\r\naddress public owner;\r\n//the address of the ScamStampToken created by this contract\r\naddress public scamStampTokenAddress;\r\n//the actual ScamStampToken\r\nScamStampToken theScamStampToken; \r\n//the contract has a brokerage fee applied to all payable function calls\r\n//the fee is 2% of the amount sent.\r\n//the fee is directly sent to the owner of this contract\r\nuint public contractFeePercentage = 2;\r\n\r\n//the price for 1 ScamStapToken is 1 finney\r\nuint256 public pricePerUnit = 1 finney;\r\n//for a address to lose the ScamStampTokens it must pay a reliefRatio per token\r\n//for each 1 token that it holds it must pay 10 finney to make the token dissapear from they account\r\nuint256 public reliefRatio = 10;\r\n//how many times an address has been marked as SCAM\r\nmapping (address => uint256) public scamFlags;\r\n//contract statistics.\r\nuint public totalNumberOfScammers = 0;\r\nuint public totalScammedQuantity = 0;\r\nuint public totalRepaidQuantity = 0;\r\n\r\nmapping (address => mapping(address => uint256)) flaggedQuantity;\r\nmapping (address => mapping(address => uint256)) flaggedRepaid;\r\n//the address that is flagging an address as scam has an issurance\r\n//when the scammer repays the scammed amount, the insurance will be sent\r\n//to the owner of the contract\r\nmapping (address => mapping(address => uint256)) flaggerInsurance;\r\n\r\nmapping (address => mapping(address => uint256)) contractsInsuranceFee;\r\nmapping (address => address[]) flaggedIndex;\r\n//how much wei was the scammer been marked for.\r\nmapping (address => uint256) public totalScammed;\r\n//how much wei did the scammer repaid\r\nmapping (address => uint256) public totalScammedRepaid;\r\n\r\nfunction ScamStamp() {\r\nowner = msg.sender;\r\nscamStampTokenAddress = new ScamStampToken();\r\ntheScamStampToken = ScamStampToken(scamStampTokenAddress);\r\n\r\n}\r\nevent MarkedAsScam(address scammer, address by, uint256 amount);\r\n//markAsSpam: payable function. \r\n//it flags the address as a scam address by sending ScamStampTokens to it.\r\n//the minimum value sent with this function call must be  pricePerUnit - set to 1 finney\r\n//the value sent to this function will be held as insurance by this contract.\r\n//it can be withdrawn by the calee anytime before the scammer pays the debt.\r\n\r\nfunction markAsScam(address scammer) payable hasMinimumAmountToFlag{\r\n    uint256 numberOfTokens = div(msg.value, pricePerUnit);\r\n    updateFlagCount(msg.sender, scammer, numberOfTokens);\r\n\r\n    uint256 ownersFee = div( mul(msg.value, contractFeePercentage), 100 );//mul(msg.value, div(contractFeePercentage, 100));\r\n    uint256 insurance = msg.value - ownersFee;\r\n    owner.transfer(ownersFee);\r\n    flaggerInsurance[msg.sender][scammer] += insurance;\r\n    contractsInsuranceFee[msg.sender][scammer] += ownersFee;\r\n    theScamStampToken.transfer(scammer, numberOfTokens);\r\n    uint256 q = mul(reliefRatio, mul(msg.value, pricePerUnit));\r\n    MarkedAsScam(scammer, msg.sender, q);\r\n}\r\n//once an address is flagged as SCAM it can be forgiven by the flagger \r\n//unless the scammer already started to pay its debt\r\n\r\nfunction forgiveIt(address scammer) {\r\n    if(flaggerInsurance[msg.sender][scammer] > 0){\r\n        uint256 insurance = flaggerInsurance[msg.sender][scammer];\r\n        uint256 hadFee = contractsInsuranceFee[msg.sender][scammer];\r\n        uint256 numberOfTokensToForgive = div( insurance + hadFee ,  pricePerUnit);\r\n        contractsInsuranceFee[msg.sender][scammer] = 0;\r\n        flaggerInsurance[msg.sender][scammer] = 0;\r\n        totalScammed[scammer] -= flaggedQuantity[scammer][msg.sender];\r\n        totalScammedQuantity -= flaggedQuantity[scammer][msg.sender];\r\n        flaggedQuantity[scammer][msg.sender] = 0;\r\n        theScamStampToken.transferBack(scammer, numberOfTokensToForgive);\r\n\r\n        msg.sender.transfer(insurance);\r\n        Forgived(scammer, msg.sender, insurance+hadFee);\r\n    }\r\n}\r\nfunction updateFlagCount(address from, address scammer, uint256 quantity) private{\r\n    scamFlags[scammer] += 1;\r\n    if(scamFlags[scammer] == 1){\r\n        totalNumberOfScammers += 1;\r\n    }\r\n    uint256 q = mul(reliefRatio, mul(quantity, pricePerUnit));\r\n    flaggedQuantity[scammer][from] += q;\r\n    flaggedRepaid[scammer][from] = 0;\r\n    totalScammed[scammer] += q;\r\n    totalScammedQuantity += q;\r\n    addAddressToIndex(scammer, from);\r\n}\r\n\r\n\r\n\r\nfunction addAddressToIndex(address scammer, address theAddressToIndex) private returns(bool success){\r\n    bool addressFound = false;\r\n    for(uint i = 0; i < flaggedIndex[scammer].length; i++){\r\n        if(flaggedIndex[scammer][i] == theAddressToIndex){\r\n            addressFound = true;\r\n            break;\r\n        }\r\n    }\r\n    if(!addressFound){\r\n        flaggedIndex[scammer].push(theAddressToIndex);\r\n    }\r\n    return true;\r\n}\r\nmodifier toBeAScammer(){\r\n    require(totalScammed[msg.sender] - totalScammedRepaid[msg.sender] > 0);\r\n    _;\r\n}\r\nmodifier addressToBeAScammer(address scammer){\r\n    require(totalScammed[scammer] - totalScammedRepaid[scammer] > 0);\r\n    _;\r\n}\r\nevent Forgived(address scammer, address by, uint256 amount);\r\nevent PartiallyForgived(address scammer, address by, uint256 amount);\r\n//forgiveMe - function called by scammer to pay any of its debt\r\n//If the amount sent to this function is greater than the amount \r\n//that is needed to cover or debt is sent back to the scammer.\r\nfunction forgiveMe() payable toBeAScammer returns (bool success){\r\n    address scammer = msg.sender;\r\n\r\n    forgiveThis(scammer);\r\n    return true;\r\n}\r\n//forgiveMeOnBehalfOf - somebody else can pay a scammer address debt (same as above)\r\nfunction forgiveMeOnBehalfOf(address scammer) payable addressToBeAScammer(scammer) returns (bool success){\r\n\r\n        forgiveThis(scammer);\r\n\r\n        return true;\r\n    }\r\n    function forgiveThis(address scammer) private returns (bool success){\r\n        uint256 forgivenessAmount = msg.value;\r\n        uint256 contractFeeAmount =  div(mul(forgivenessAmount, contractFeePercentage), 100); \r\n        uint256 numberOfTotalTokensToForgive = div(div(forgivenessAmount, reliefRatio), pricePerUnit);\r\n        forgivenessAmount = forgivenessAmount - contractFeeAmount;\r\n        for(uint128 i = 0; i < flaggedIndex[scammer].length; i++){\r\n            address forgivedBy = flaggedIndex[scammer][i];\r\n            uint256 toForgive = flaggedQuantity[scammer][forgivedBy] - flaggedRepaid[scammer][forgivedBy];\r\n            if(toForgive > 0){\r\n                if(toForgive >= forgivenessAmount){\r\n                    flaggedRepaid[scammer][forgivedBy] += forgivenessAmount;\r\n                    totalRepaidQuantity += forgivenessAmount;\r\n                    totalScammedRepaid[scammer] += forgivenessAmount;\r\n                    forgivedBy.transfer(forgivenessAmount);\r\n                    PartiallyForgived(scammer, forgivedBy, forgivenessAmount);\r\n                    forgivenessAmount = 0;\r\n                    break;\r\n                }else{\r\n                    forgivenessAmount -= toForgive;\r\n                    flaggedRepaid[scammer][forgivedBy] += toForgive;\r\n                    totalScammedRepaid[scammer] += toForgive;\r\n                    totalRepaidQuantity += toForgive;\r\n                    forgivedBy.transfer(toForgive);\r\n                    Forgived(scammer, forgivedBy, toForgive);\r\n                }\r\n                if(flaggerInsurance[forgivedBy][scammer] > 0){\r\n                    uint256 insurance = flaggerInsurance[forgivedBy][scammer];\r\n                    contractFeeAmount += insurance;\r\n                    flaggerInsurance[forgivedBy][scammer] = 0;\r\n                    contractsInsuranceFee[forgivedBy][scammer] = 0;\r\n                }\r\n            }\r\n        }\r\n        owner.transfer(contractFeeAmount);\r\n        theScamStampToken.transferBack(scammer, numberOfTotalTokensToForgive);\r\n\r\n        if(forgivenessAmount > 0){\r\n            msg.sender.transfer(forgivenessAmount);\r\n        }\r\n        return true;\r\n    }\r\n    event DonationReceived(address by, uint256 amount);\r\n    function donate() payable {\r\n        owner.transfer(msg.value);\r\n        DonationReceived(msg.sender, msg.value);\r\n\r\n    }\r\n    function () payable {\r\n        owner.transfer(msg.value);\r\n        DonationReceived(msg.sender, msg.value);        \r\n    }\r\n    \r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBack\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "ScamStampToken", "CompilerVersion": "v0.4.12+commit.194ff033", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://5a63d8227c3296cfb3fe0a9aaf8d8b0b0adf15ce6be67ebf658b3ec658b976ab"}]}