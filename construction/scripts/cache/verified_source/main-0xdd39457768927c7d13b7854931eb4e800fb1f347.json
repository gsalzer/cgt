{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.11;\r\n\r\ncontract BLOCKCHAIN_DEPOSIT_BETA {\r\n\t\r\n\t/* CONTRACT SETUP */\r\n\r\n\tuint constant PAYOUT_INTERVAL = 1 days;\r\n\r\n\t/* NB: Solidity doesn't support fixed or floats yet, so we use promille instead of percent */\t\r\n\tuint constant DEPOSITOR_INTEREST= 10;\r\n\tuint constant INTEREST_DENOMINATOR = 1000;\r\n\r\n\t/* DATA TYPES */\r\n\r\n\t/* the payout happend */\r\n\tevent Payout(uint paidPeriods, uint depositors);\r\n\t\r\n\t/* Depositor struct: describes a single Depositor */\r\n\tstruct Depositor\r\n\t{\t\r\n\t\taddress etherAddress;\r\n\t\tuint deposit;\r\n\t\tuint depositTime;\r\n\t}\r\n\r\n\r\n\t/* the time of last payout */\r\n\tuint private contract_latestPayoutTime;\r\n\r\n\t/* Array of depositors */\r\n\tDepositor[] private contract_depositors;\r\n\r\n\t\r\n\t/* PUBLIC FUNCTIONS */\r\n\r\n\t/* contract constructor */\r\n\tfunction BLOCKCHAIN_DEPOSIT_BETA() \r\n\t{\r\n\t\tcontract_latestPayoutTime = now;\t\t\r\n\t}\r\n\r\n\t/* fallback function: called when the contract received plain ether */\r\n\tfunction() payable\r\n\t{\r\n\t\taddDepositor();\r\n\t}\r\n\r\n\tfunction Make_Deposit() payable\r\n\t{\r\n\t\taddDepositor();\t\r\n\t}\r\n\r\n\tfunction status() constant returns (uint deposit_fund_sum, uint depositorsCount, uint unpaidTime, uint unpaidIntervals)\r\n\t{\r\n\t\tdeposit_fund_sum = this.balance;\r\n\t\tdepositorsCount = contract_depositors.length;\r\n\t\tunpaidTime = now - contract_latestPayoutTime;\r\n\t\tunpaidIntervals = unpaidTime / PAYOUT_INTERVAL;\r\n\t}\r\n\r\n\r\n\t/* checks if it's time to make payouts. if so, send the ether */\r\n\tfunction performPayouts()\r\n\t{\r\n\t\tuint paidPeriods = 0;\r\n\t\tuint depositorsDepositPayout;\r\n\r\n\t\twhile(contract_latestPayoutTime + PAYOUT_INTERVAL < now)\r\n\t\t{\t\t\t\t\t\t\r\n\t\t\tuint idx;\r\n\r\n\t\t\t/* pay the depositors  */\r\n\t\t\t/* we use reverse iteration here */\r\n\t\t\tfor (idx = contract_depositors.length; idx-- > 0; )\r\n\t\t\t{\r\n\t\t\t\tif(contract_depositors[idx].depositTime > contract_latestPayoutTime + PAYOUT_INTERVAL)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tuint payout = (contract_depositors[idx].deposit * DEPOSITOR_INTEREST) / INTEREST_DENOMINATOR;\r\n\t\t\t\tif(!contract_depositors[idx].etherAddress.send(payout))\r\n\t\t\t\t\tthrow;\r\n\t\t\t\tdepositorsDepositPayout += payout;\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/* save the latest paid time */\r\n\t\t\tcontract_latestPayoutTime += PAYOUT_INTERVAL;\r\n\t\t\tpaidPeriods++;\r\n\t\t}\r\n\t\t\t\r\n\t\t/* emit the Payout event */\r\n\t\tPayout(paidPeriods, depositorsDepositPayout);\r\n\t}\r\n\r\n\t/* PRIVATE FUNCTIONS */\r\n\tfunction addDepositor() private \r\n\t{\r\n\t\tcontract_depositors.push(Depositor(msg.sender, msg.value, now));\r\n\t}\r\n\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"deposit_fund_sum\",\"type\":\"uint256\"},{\"name\":\"depositorsCount\",\"type\":\"uint256\"},{\"name\":\"unpaidTime\",\"type\":\"uint256\"},{\"name\":\"unpaidIntervals\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Make_Deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"performPayouts\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paidPeriods\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"depositors\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"}]", "ContractName": "BLOCKCHAIN_DEPOSIT_BETA", "CompilerVersion": "v0.4.11+commit.68ef5810", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://131ed23cb69655896b4ddd8436877539558448def17fcc85406c3f859d816bba"}]}