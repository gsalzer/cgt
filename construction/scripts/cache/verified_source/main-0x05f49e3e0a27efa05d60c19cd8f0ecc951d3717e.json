{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.25;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Only the owner can call this method');\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * In the event of the shortage of funds for the level payments\r\n * stabilization the contract of the stabilization fund provides backup support to the investment fund. \r\n */\r\ncontract EtherheroStabilizationFund {\r\n\r\n    address public etherHero;\r\n    uint public investFund;\r\n    uint estGas = 200000;\r\n    event MoneyWithdraw(uint balance);\r\n    event MoneyAdd(uint holding);\r\n\r\n    constructor() public {\r\n        etherHero = msg.sender;\r\n    }\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyHero() {\r\n        require(msg.sender == etherHero, 'Only Hero call');\r\n        _;\r\n    }\r\n\r\n    function ReturnEthToEtherhero() public onlyHero returns(bool) {\r\n\r\n        uint balance = address(this).balance;\r\n        require(balance > estGas, 'Not enough funds for transaction');\r\n\r\n        if (etherHero.call.value(address(this).balance).gas(estGas)()) {\r\n            emit MoneyWithdraw(balance);\r\n            investFund = address(this).balance;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        investFund += msg.value;\r\n        emit MoneyAdd(msg.value);\r\n    }\r\n}\r\n\r\ncontract Etherhero is Ownable {\r\n\r\n    using SafeMath\r\n    for uint;\r\n    // array containing information about beneficiaries\r\n    mapping(address => uint) public userDeposit;\r\n    //array containing information about the time of payment\r\n    mapping(address => uint) public userTime;\r\n    //fund fo transfer percent\r\n    address public projectFund = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;\r\n    EtherheroStabilizationFund public stubF = new EtherheroStabilizationFund();\r\n    uint public percentProjectFund = 10;\r\n    uint public percentDevFund = 1;\r\n    uint public percentStubFund = 10;\r\n    address public addressStub;\r\n    //Gas cost\r\n    uint estGas = 150000;\r\n    uint standartPercent = 30; //3%\r\n    uint responseStubFundLimit = 150; //15%\r\n    uint public minPayment = 5 finney;\r\n    //time through which you can take dividends\r\n    uint chargingTime = 1 days;\r\n\r\n    event NewInvestor(address indexed investor, uint deposit);\r\n    event dividendPayment(address indexed investor, uint value);\r\n    event NewDeposit(address indexed investor, uint value);\r\n\r\n    //public variables for DAPP\r\n    uint public counterDeposits;\r\n    uint public counterPercents;\r\n    uint public counterBeneficiaries;\r\n    uint public timeLastayment;\r\n\r\n    //Memory for user for DAPP\r\n    struct Beneficiaries {\r\n        address investorAddress;\r\n        uint registerTime;\r\n        uint percentWithdraw;\r\n        uint ethWithdraw;\r\n        uint deposits;\r\n        bool real;\r\n    }\r\n\r\n    mapping(address => Beneficiaries) beneficiaries;\r\n\r\n    constructor() public {\r\n        addressStub = stubF;\r\n    }\r\n    //Add beneficiary record\r\n    function insertBeneficiaries(address _address, uint _percentWithdraw, uint _ethWithdraw, uint _deposits) private {\r\n\r\n        Beneficiaries storage s_beneficiaries = beneficiaries[_address];\r\n\r\n        if (!s_beneficiaries.real) {\r\n            s_beneficiaries.real = true;\r\n            s_beneficiaries.investorAddress = _address;\r\n            s_beneficiaries.percentWithdraw = _percentWithdraw;\r\n            s_beneficiaries.ethWithdraw = _ethWithdraw;\r\n            s_beneficiaries.deposits = _deposits;\r\n            s_beneficiaries.registerTime = now;\r\n            counterBeneficiaries += 1;\r\n        } else {\r\n            s_beneficiaries.percentWithdraw += _percentWithdraw;\r\n            s_beneficiaries.ethWithdraw += _ethWithdraw;\r\n        }\r\n    }\r\n    \r\n    //Get beneficiary record\r\n    function getBeneficiaries(address _address) public view returns(address investorAddress, uint persentWithdraw, uint ethWithdraw, uint registerTime) {\r\n\r\n        Beneficiaries storage s_beneficiaries = beneficiaries[_address];\r\n\r\n        require(s_beneficiaries.real, 'Investor Not Found');\r\n\r\n        return (\r\n            s_beneficiaries.investorAddress,\r\n            s_beneficiaries.percentWithdraw,\r\n            s_beneficiaries.ethWithdraw,\r\n            s_beneficiaries.registerTime\r\n        );\r\n    }\r\n\r\n    modifier isIssetUser() {\r\n        require(userDeposit[msg.sender] > 0, \"Deposit not found\");\r\n        _;\r\n    }\r\n\r\n    modifier timePayment() {\r\n        require(now >= userTime[msg.sender].add(chargingTime), \"Too fast payout request\");\r\n        _;\r\n    }\r\n\r\n    function calculationOfPayment() public view returns(uint) {\r\n        uint interestRate = now.sub(userTime[msg.sender]).div(chargingTime);\r\n        //If the contribution is less than 1 ether, dividends can be received only once a day\r\n        if (userDeposit[msg.sender] < 10 ether) {\r\n            if (interestRate >= 1) {\r\n                return (1);\r\n            } else {\r\n                return (interestRate);\r\n            }\r\n        }\r\n        //If the contribution is less than 10 ether, dividends can be received only once a 3 day\r\n        if (userDeposit[msg.sender] >= 10 ether && userDeposit[msg.sender] < 50 ether) {\r\n            if (interestRate > 3) {\r\n                return (3);\r\n            } else {\r\n                return (interestRate);\r\n            }\r\n        }\r\n        //If the contribution is less than 50 ether, dividends can be received only once a 7 day\r\n        if (userDeposit[msg.sender] >= 50 ether) {\r\n            if (interestRate > 7) {\r\n                return (7);\r\n            } else {\r\n                return (interestRate);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function receivePercent() isIssetUser timePayment internal {\r\n       // verification that funds on the balance sheet are more than 15% of the total number of deposits\r\n        uint balanceLimit = counterDeposits.mul(responseStubFundLimit).div(1000);\r\n        uint payoutRatio = calculationOfPayment();\r\n        //calculate 6% of total deposits\r\n        uint remain = counterDeposits.mul(6).div(100);\r\n        \r\n        if(addressStub.balance > 0){\r\n            if (address(this).balance < balanceLimit) {\r\n                stubF.ReturnEthToEtherhero();\r\n            }\r\n        }\r\n        //If the balance is less than 6% of total deposits, stop paying\r\n        require(address(this).balance >= remain, 'contract balance is too small');\r\n\r\n        uint rate = userDeposit[msg.sender].mul(standartPercent).div(1000).mul(payoutRatio);\r\n        userTime[msg.sender] = now;\r\n        msg.sender.transfer(rate);\r\n        counterPercents += rate;\r\n        timeLastayment = now;\r\n        insertBeneficiaries(msg.sender, standartPercent, rate, 0);\r\n        emit dividendPayment(msg.sender, rate);\r\n    }\r\n\r\n    function makeDeposit() private {\r\n        uint value = msg.value;\r\n        uint calcProjectPercent = value.mul(percentProjectFund).div(100);\r\n        uint calcStubFundPercent = value.mul(percentStubFund).div(100);\r\n        \r\n        if (msg.value > 0) {\r\n            //check for minimum deposit \r\n            require(msg.value >= minPayment, 'Minimum deposit 1 finney');\r\n            \r\n            if (userDeposit[msg.sender] == 0) {\r\n                emit NewInvestor(msg.sender, msg.value);\r\n            }\r\n            \r\n            userDeposit[msg.sender] = userDeposit[msg.sender].add(msg.value);\r\n            userTime[msg.sender] = now;\r\n            insertBeneficiaries(msg.sender, 0, 0, msg.value);\r\n            projectFund.transfer(calcProjectPercent);\r\n            stubF.call.value(calcStubFundPercent).gas(estGas)();\r\n            counterDeposits += msg.value;\r\n            emit NewDeposit(msg.sender, msg.value);\r\n        } else {\r\n            receivePercent();\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.sender != addressStub) {\r\n            makeDeposit();\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"timeLastayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counterDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBeneficiaries\",\"outputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"persentWithdraw\",\"type\":\"uint256\"},{\"name\":\"ethWithdraw\",\"type\":\"uint256\"},{\"name\":\"registerTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stubF\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentProjectFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculationOfPayment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentDevFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentStubFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counterPercents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"counterBeneficiaries\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressStub\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"NewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"dividendPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"}]", "ContractName": "Etherhero", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "Library": "", "SwarmSource": "bzzr://fa38be668bf1524f5c89a1de4b44399f453e01de7632b9f01d7d83578930e087"}]}